# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Maxwell Anselm
# This file is distributed under the same license as the silverhammermba.github.io/emberb package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: silverhammermba.github.io/emberb VERSION\n"
"POT-Creation-Date: 2023-05-23 00:19+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: en\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: layout
#: _posts/2010-01-01-c.markdown:1 _posts/2012-01-01-embed.markdown:1
#: _posts/2013-01-01-extend.markdown:1 _posts/2014-01-01-examples.markdown:1
#, no-wrap
msgid "chapter"
msgstr ""

#. type: YAML Front Matter: title
#: _posts/2010-01-01-c.markdown:1
#, no-wrap
msgid "The Ruby C API"
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:6
#, markdown-text, no-wrap
msgid "Before You Start"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:10
#, markdown-text
msgid ""
"For the greatest chance of success with this guide, I recommend being fairly "
"comfortable with C and _very_ comfortable with Ruby."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:16
#, markdown-text
msgid ""
"Using Ruby's C API does not require any advanced C concepts, however the API "
"is **huge** and largely **undocumented**. After you start using it, you will "
"likely find yourself delving through the Ruby source code at some point to "
"figure out the behavior of some obscure function or macro. The Ruby source "
"uses some fairly sophisticated C, so you should at least feel comfortable "
"reading it."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:22
#, markdown-text
msgid ""
"You can think of the C API is being a big, clunky alternative to writing "
"normal Ruby code. However the simple, elegant patterns of Ruby can be pretty "
"unintuitive once translated into the language of the API. Having a strong "
"intuition for Ruby's internal logic and the ideas behind its design will go "
"a long way toward steering you toward the correct API functions."
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:23
#, markdown-text, no-wrap
msgid "The Two Paths"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:28
#, markdown-text
msgid ""
"The official Ruby interpreter is written in C. That means that everything "
"you can do in Ruby, you can also do using function calls to Ruby's C "
"API. Why in the world would you do this? There are two good reasons:"
msgstr ""

#. type: Bullet: '1. '
#: _posts/2010-01-01-c.markdown:37
#, markdown-text
msgid ""
"You're writing some fancy application in C or C++ and you want some parts of "
"your code to leverage the dynamic flexibility of Ruby. You can run the Ruby "
"interpreter inside of your application and use the API to retrieve the "
"results of Ruby code."
msgstr ""

#. type: Bullet: '2. '
#: _posts/2010-01-01-c.markdown:37
#, markdown-text
msgid ""
"You're writing some fancy application in Ruby and you want some parts of "
"your code to leverage the speed and power of C (or an existing C "
"library). You can expose C code to Ruby using the API and compile a special "
"library that Ruby can `require`."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:42
#, markdown-text
msgid ""
"You'll need to structure your C code differently depending on your goal. If "
"you want to embed the Ruby interpreter in C, read [Running Ruby in "
"C](../embed). If you want to `require` a compiled C library, read [Running C "
"in Ruby](../extend).  After you finish that, come back here to learn about "
"the API."
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:43
#, markdown-text, no-wrap
msgid "Eval"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:46
#, markdown-text
msgid "The quick 'n' dirty way to run some Ruby code from C is to `eval` it"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:50
#, markdown-text
msgid "{% highlight c %} {% include c/eval.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:55
#, markdown-text
msgid ""
"This is a good fallback if you can't find an API function for something that "
"you want to do[^wrap]. `rb_eval_string_protect()` returns the result of the "
"Ruby code and sets `state` to some nonzero value if any exception is "
"raised. `VALUE` is the C data type for all Ruby objects, as explained in the "
"next section."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:60
#, markdown-text
msgid ""
"If `state` is nonzero, `result` will be a `VALUE` representing `nil` and you "
"should handle the exception. Alternatively, you can use `rb_eval_string()` "
"which doesn't take a `state` argument and instead raises any exceptions "
"normally. See [Exceptions](#exceptions) for how to handle both of these "
"cases."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:64
#, markdown-text
msgid ""
"Unlike `eval` in Ruby, these functions evaluate the string in an isolated "
"binding&mdash;like when you `require` something. So local variables in the "
"string will not be accessible from elsewhere and vice versa."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:69
#, markdown-text
msgid ""
"However, like using `eval` in Ruby, using these functions is not a good "
"practice. It's inefficient since the parser is invoked and it somewhat "
"defeats the point of writing in C. If you just want to call some Ruby "
"method, we'll go over a better way to do that [later on](#send)."
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:70
#, markdown-text, no-wrap
msgid "VALUE"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:79
#, markdown-text
msgid ""
"Before we go any further, we need to understand `VALUE`s. Due to the danger "
"of monkeying around inside the VM, the API never lets you directly access "
"Ruby's objects[^intern]. Instead, your C code will store and pass around "
"_pointers_ to Ruby objects (like how variables in Ruby contain pointers to "
"objects). These pointers can be passed to various API functions and macros "
"that will safely access and manipulate the Ruby objects. `VALUE` is the "
"API-defined C type for these pointers."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:84
#, markdown-text
msgid ""
"Probably the most frequent question you'll have is: \"is this `VALUE` the "
"right type?\". There are a couple macros for performing this test, and both "
"take a [`T_` constant][datatypes] corresponding to the Ruby class you're "
"testing for e.g. `T_STRING`, `T_ARRAY`, etc."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:86
#, markdown-text
msgid ""
"[datatypes]: "
"https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-Data+Types"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:90
#, markdown-text
msgid "{% highlight c %} {% include c/checktype.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:96
#, markdown-text
msgid ""
"These tests work for subclasses too: if you're testing for a subclass of "
"`Array` use `T_ARRAY`, if you're testing for a subclass of `Object` use "
"`T_OBJECT`[^tdata]. That being said, these tests _do not work like `is_a?`_; "
"even though everything in Ruby `is_a? Object`, testing against `T_OBJECT` "
"will only return true for objects for which there is no better fitting "
"constant."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:99
#, markdown-text
msgid ""
"For certain classes, there are specialized macros that are a little more "
"efficient than the previous:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:103
#, markdown-text
msgid "{% highlight c %} {% include c/check_p.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:107
#, markdown-text
msgid ""
"If you want to handle a `VALUE` that could be one of a variety of types, the "
"previous macros can be a little clumsy. In that case you can use the "
"`TYPE()` macro to get the `T_` constant and handle your logic in a `switch`:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:111
#, markdown-text
msgid "{% highlight c %} {% include c/type.h %} {% endhighlight %}"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:112
#, markdown-text, no-wrap
msgid "Constants"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:121
#, markdown-text
msgid ""
"Most of the standard Ruby constants have global `VALUE`s defined for them in "
"the API so you don't need an API call to access them. Modules are prefixed "
"with `rb_m` e.g. `rb_mKernel`; classes are prefixed with `rb_c` "
"e.g. `rb_cObject`; subclasses of `Exception` are prefixed with `rb_e` "
"e.g. `rb_eRuntimeError`; and the standard IO streams are prefixed with `rb_` "
"e.g. `rb_stderr`. `nil`, `false`, and `true` are prefixed with `Q` "
"e.g. `Qnil`.[^undef] As a convenience, `Qfalse` is also false in C (`0`)."
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:122
#, markdown-text, no-wrap
msgid "Translation"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:126
#, markdown-text
msgid ""
"A few Ruby classes are analogous to C types. These classes will be your "
"primary means of transferring data between C and Ruby."
msgstr ""

#. type: Title ####
#: _posts/2010-01-01-c.markdown:127
#, markdown-text, no-wrap
msgid "Fixnum"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:133
#, markdown-text
msgid ""
"Ruby's `Fixnum` corresponds to C's `long`. The `FIX2LONG()` macro gives you "
"the `long` for a `Fixnum`. For smaller C types there's `FIX2UINT()`, "
"`FIX2INT()`, and `FIX2SHORT()`, but these will raise a `RangeError` if the "
"number wouldn't fit."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:136
#, markdown-text
msgid ""
"In the other direction, `LONG2FIX()` works for `long` **and** every smaller "
"integer C type[^chr]."
msgstr ""

#. type: Title ####
#: _posts/2010-01-01-c.markdown:137
#, markdown-text, no-wrap
msgid "Bignum"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:143
#, markdown-text
msgid ""
"Ruby's `Bignum` is for anything bigger than a `Fixnum`, so it works if you "
"need to work with `long long`, for example. `rb_big2ll()` and `rb_big2ull()` "
"will get you `long long` and `unsigned long long` from a `Bignum` (or raise "
"a `RangeError` if appropriate)."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:145 _posts/2010-01-01-c.markdown:152
#, markdown-text
msgid "See [Numeric](#numeric) for the reverse direction."
msgstr ""

#. type: Title ####
#: _posts/2010-01-01-c.markdown:146
#, markdown-text, no-wrap
msgid "Float"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:150
#, markdown-text
msgid ""
"Ruby's `Float` corresponds to C's `double`. The `RFLOAT_VALUE()` macro gives "
"you the `double` for a `Float`."
msgstr ""

#. type: Title ####
#: _posts/2010-01-01-c.markdown:153
#, markdown-text, no-wrap
msgid "Numeric"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:158
#, markdown-text
msgid ""
"There are a host of \"NUM\" macros that try to be more duck-typish about "
"things.  These will convert their C types to whatever Ruby `Numeric` "
"subclass seems appropriate:"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:166
#, markdown-text
msgid "`INT2NUM()` for `int`"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:166
#, markdown-text
msgid "`UINT2NUM()` for `unsigned int`"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:166
#, markdown-text
msgid "`LONG2NUM()` for `long`"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:166
#, markdown-text
msgid "`ULONG2NUM()` for `unsigned long`"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:166
#, markdown-text
msgid "`LL2NUM()` for `long long`"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:166
#, markdown-text
msgid "`ULL2NUM()` for `unsigned long long`"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:166
#, markdown-text
msgid "`DBL2NUM()` for `double`"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:171
#, markdown-text
msgid ""
"And there are macros for the opposite direction, which will try to convert "
"whatever `Numeric` to the desired C type. These will raise a `RangeError` if "
"the value wouldn't fit or `TypeError` if there is no implicit numeric "
"conversion (so you can safely pass non-`Numeric` objects)."
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
#, markdown-text
msgid "`NUM2CHR()` for `char` (works for `unsigned char` too)"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
#, markdown-text
msgid "`NUM2SHORT()` for `short`"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
#, markdown-text
msgid "`NUM2USHORT()` for `unsigned short`"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
#, markdown-text
msgid "`NUM2INT()` for `int`"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
#, markdown-text
msgid "`NUM2UINT()` for `unsigned int`"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
#, markdown-text
msgid "`NUM2LONG()` for `long`"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
#, markdown-text
msgid "`NUM2ULONG()` for `unsigned long`"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
#, markdown-text
msgid "`NUM2LL()` for `long long`"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
#, markdown-text
msgid "`NUM2ULL()` for `unsigned long long`"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
#, markdown-text
msgid "`NUM2DBL()` for `double`"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:189
#, markdown-text
msgid ""
"A **major** gotcha with these is that _none_ of the macros for converting to "
"unsigned types raise an exception if you pass a negative value (surprisingly "
"this [isn't a bug][bug]). `NUM2CHR()` also has a couple quirks: it will only "
"raise a `RangeError` if the value is too big for an _int_ and when passed a "
"string it returns the numeric value of the first character rather than "
"raising a `TypeError`."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:192
#, markdown-text
msgid ""
"If you know that the conversion is safe, you should prefer the macros from "
"the previous sections as they skip the range checks."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:194
#, markdown-text
msgid "[bug]: https://bugs.ruby-lang.org/issues/9089"
msgstr ""

#. type: Title ####
#: _posts/2010-01-01-c.markdown:195
#, markdown-text, no-wrap
msgid "String"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:203
#, markdown-text
msgid ""
"Ruby's `String` kinda corresponds to C's `char*`. The simplest macro is "
"`StringValueCStr()` which returns a null-terminated `char*` for a "
"`String`. The problem here is that a Ruby `String` _might contain nulls_ - "
"in which case `StringValueCStr()` will raise an `ArgumentError`! Instead you "
"can use the macros `StringValuePtr()` and `RSTRING_LEN()` to get a (possibly "
"unterminated)  `char*` and the string's length as a `long`."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:211
#, markdown-text
msgid ""
"Conversely, if you have a null-terminated `char*`, you can use "
"`rb_str_new_cstr()` to create a Ruby `String`. And if you want your `String` "
"to contain nulls, use `rb_str_new()` which takes a `char*` and the string's "
"length (as a `long`). The encodings of these strings will be `ASCII-8BIT`, "
"which is often undesirable in Ruby. You can pass the string `VALUE` to "
"`rb_str_export_locale()` to get a new `VALUE` with your locale's "
"encoding[^wchar]."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:218
#, markdown-text
msgid ""
"If you want to build more complex strings, you can do so using the "
"`printf`-like function `rb_sprintf()`. This accepts all of the usual "
"conversion specifiers, but also accepts an API-defined specifier `PRIsVALUE` "
"which takes a corresponding `VALUE` argument. This conversion specifier "
"substitutes a string by sending the object `to_s`. You can substitute the "
"result of `inspect` instead by adding the `+` flag."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:222
#, markdown-text
msgid "{% highlight c %} {% include c/printf.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:227
#, markdown-text
msgid ""
"This custom specifier should work for any `printf`-like function in the "
"API.  `PRIsVALUE` works by hijacking the `i` conversion specifier, so when "
"printing an `int` you should use `d` to ensure that Ruby doesn't think it's "
"actually a `VALUE`."
msgstr ""

#. type: Title ####
#: _posts/2010-01-01-c.markdown:228
#, markdown-text, no-wrap
msgid "Symbol"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:236
#, markdown-text
msgid ""
"The API defines a C type `ID` which corresponds to Ruby's `Symbol`. Just "
"like how Ruby passes around `Symbol`s as method or variable names, many API "
"calls that need a method or variable name use an `ID`. To convert between a "
"`Symbol` and an `ID` use the `SYM2ID()` and `ID2SYM()` macros. Instead of a "
"`Symbol` you may want to convert to/from a `char*` C string. To get an `ID` "
"from a `char*` use `rb_intern()` and for the reverse use `rb_id2name()`."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:246
#, markdown-text
msgid ""
"Since many API functions require an `ID` and in many cases you will not have "
"the appropriate `ID` at hand, the API also defines a slew of functions that "
"instead take a `char*` and which do the `rb_intern()` call for you. Since "
"these functions are often more readable and the overhead of the "
"`rb_intern()` call is negligible, I have opted to use the `char*` versions "
"of the API functions wherever possible in this guide. If you find yourself "
"frequently using a certain C string in API calls, you may see some "
"performance benefit by storing the `ID` and using the `ID` versions of the "
"functions (though you'll have to look these up yourself in the Ruby "
"headers)."
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:247
#, markdown-text, no-wrap
msgid "Send"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:253
#, markdown-text
msgid ""
"This section contains API functions for directly calling Ruby methods. You "
"should prefer these functions to `rb_eval_string()` and the like whenever "
"possible. They are faster since they skip the parser and allow for some "
"compile-time checks."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:255
#, markdown-text
msgid "The easiest way to send an object a method looks like this:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:259
#, markdown-text
msgid "{% highlight c %} {% include c/funcall.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:261
#, markdown-text
msgid "This is roughly equivalent to the Ruby code"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:265
#, markdown-text
msgid "{% highlight ruby %} {% include c/funcall.rb %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:270
#, markdown-text
msgid ""
"The first argument is the receiver. The next is the [`ID`](#symbol) for the "
"method name. The third argument is the number of method arguments, which is "
"needed since `rb_funcall()` is a varargs function. Then come the actual "
"method arguments."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:274
#, markdown-text
msgid ""
"Alternatively, you can use `rb_funcallv()` where the fourth argument is a "
"`VALUE*` pointing to a C array of arguments. This also has the variant "
"`rb_funcallv_public()` which is like `public_send` in Ruby."
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:275
#, markdown-text, no-wrap
msgid "Passing Blocks"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:279
#, markdown-text
msgid ""
"If you want to pass a `Proc` as the block to a method, that's easy. The "
"function is just like `rb_funcallv()` but with the proc on the end."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:283
#, markdown-text
msgid "{% highlight c %} {% include c/proc.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:287
#, markdown-text
msgid ""
"If you don't have a proc for the block, you'll need to define a certain kind "
"of C function to represent the block. Then there's a different variant of "
"`rb_funcallv()` but with a couple extra arguments for the block:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:291
#, markdown-text
msgid "{% highlight c %} {% include c/block.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:297
#, markdown-text
msgid ""
"The last argument to `rb_block_call()` is helpful for passing in values "
"outside the block function's scope, but in this example we don't need it "
"(thus `nil`). I also recommend against using the first argument to your "
"block function unless you're **sure** that only one value was yielded. You "
"can always get all the arguments from `argv`, so why not play it "
"safe?[^break]"
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:298
#, markdown-text, no-wrap
msgid "Builtins"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:305
#, markdown-text
msgid ""
"Many of Ruby's built-in classes have API functions defined for their most "
"useful methods. Using them can save you from the verbosity of always using "
"`rb_funcall()` and can provide more compile-time checks. There are far too "
"many functions to list here, so I recommend checking them out in the header "
"`ruby/intern.h`."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:309
#, markdown-text
msgid ""
"Functions are generally named like `rb_(class)_(method)` and take at least "
"one `VALUE` argument (the receiver). E.g. `rb_ary_pop()` for `Array#pop`, "
"`rb_obj_dup()` for `Object#dup`, etc."
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:310
#, markdown-text, no-wrap
msgid "Require"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:314
#, markdown-text
msgid ""
"The API can also load some Ruby code from a script. There's an equivalent to "
"`require`:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:318
#, markdown-text
msgid "{% highlight c %} {% include c/require.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:321
#, markdown-text
msgid ""
"As with `require`, these could raise exceptions. Read the [next "
"section](#exceptions) for how to handle them."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:323
#, markdown-text
msgid ""
"There are also functions for `load` if you want to load a script multiple "
"times:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:327
#, markdown-text
msgid "{% highlight c %} {% include c/load.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:331
#, markdown-text
msgid ""
"Just like [`load` in Ruby][rbload], these functions can wrap the loaded code "
"in an anonymous module to protect the global namespace. Just pass a nonzero "
"value for the second argument."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:333
#, markdown-text
msgid "[rbload]: http://www.ruby-doc.org/core/Kernel.html#method-i-load"
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:334
#, markdown-text, no-wrap
msgid "Exceptions"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:336
#, markdown-text, no-wrap
msgid "Raise"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:339
#, markdown-text
msgid "To raise an exception, use:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:343
#, markdown-text
msgid "{% highlight c %} {% include c/raise.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:348
#, markdown-text
msgid ""
"The first and second arguments are the exception class and "
"message&mdash;like `raise` in Ruby. The big difference is that the message "
"is a format string [just like in `rb_sprintf()`](#string), letting you more "
"easily build a useful message."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:355
#, markdown-text
msgid ""
"You can also construct exception objects directly using `rb_exc_new_cstr`, "
"`rb_exc_new`, and `rb_exc_new_str`. All of these accept an exception class "
"as their first argument and then they work just like their [string](#string)  "
"counterparts, constructing an exception using a null-terminated string, "
"non-null-terminated string, and a `String` object, resp. Then you can raise "
"your exception object with `rb_exc_raise`."
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:356
#, markdown-text, no-wrap
msgid "Rescue"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:361
#, markdown-text
msgid ""
"There are several ways to rescue exceptions using the API. All of them "
"require the code you're protecting to be in a function that takes and "
"returns a single `VALUE`."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:365
#, markdown-text
msgid "{% highlight c %} {% include c/danger.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:369
#, markdown-text
msgid ""
"Unless you wanted to rescue a function of exactly this type, you will "
"probably need to make a wrapper function in this format that runs the "
"desired code. The way to access a rescued exception is also independent of "
"the way it is rescued:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:373
#, markdown-text
msgid "{% highlight c %} {% include c/handle.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:378
#, markdown-text
msgid ""
"`rb_errinfo()` essentially gives you the `VALUE` of Ruby's `$!` (which will "
"be `Qnil` if no exception occurred). Unlike in Ruby, you must manually clear "
"the exception after reading it[^clear]. Otherwise later API calls might read "
"the old value and think another exception has occurred."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:382
#, markdown-text
msgid ""
"Next we will go over several methods of rescuing; you can use whichever you "
"like, but I think that generally the right choice is determined by your "
"[use-case](#the-two-paths) of the API."
msgstr ""

#. type: Title ####
#: _posts/2010-01-01-c.markdown:383
#, markdown-text, no-wrap
msgid "rb_rescue2"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:389
#, markdown-text
msgid ""
"If you're compiling a library to be loaded by Ruby, you have it easy. Any "
"exceptions raised in the API can be rescued as usual in your Ruby code. If "
"you want to rescue an exception in the API, you can use `rb_rescue2()` which "
"is similar to Ruby's `rescue`."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:393
#, markdown-text
msgid "{% highlight c %} {% include c/rescue2.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:402
#, markdown-text
msgid ""
"The first two arguments are the function to protect and its argument, the "
"next two are the function to call if an exception is raised and its "
"argument.  `rb_rescue2()` is a varargs function, so after that comes a list "
"of the exception classes you want to rescue. The last argument should always "
"be `0` to indicate the end of the class list. Like `rescue` in Ruby, any "
"exceptions not in this list will not be rescued. If you just want to rescue "
"`StandardError` (like a blank `rescue` in Ruby), you can use `rb_rescue()` "
"which takes just the first four arguments of `rb_rescue2()`."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:406
#, markdown-text
msgid ""
"The API does not provide an easy way to run different rescue code for "
"different exception classes as Ruby does. You'll need to rescue all the "
"classes you want at once and use some kind of switch to handle them "
"separately."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:413
#, markdown-text
msgid ""
"The API also does not directly provide an equivalent to Ruby's `else` "
"i.e. code to run when _no_ exception was raised. One way to do this is using "
"the return value of `rb_rescue2()`. If no exception is raised, it returns "
"the return value of the first (dangerous) function, otherwise the return "
"value of the second (rescue) function. By having these return, say, `Qtrue` "
"and `Qfalse` you can detect which case you are in."
msgstr ""

#. type: Title ####
#: _posts/2010-01-01-c.markdown:414
#, markdown-text, no-wrap
msgid "rb_protect"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:421
#, markdown-text
msgid ""
"If you're embedding the Ruby interpreter in C, you need to be _extremely "
"careful_ when calling API functions that could raise exceptions: **an "
"uncaught exception will segfault the VM and kill your program**. You could "
"call `rb_rescue2()` with `rb_eException`, but there's another approach for "
"rescuing all exceptions:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:425
#, markdown-text
msgid "{% highlight c %} {% include c/protect.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:431
#, markdown-text
msgid ""
"Like `rb_rescue2()`, the first two arguments are for calling the function to "
"protect. However, like `rb_eval_string_protect()`, if an exception is raised "
"it returns `Qnil` and sets `state` to some nonzero value. If you want to "
"re-raise the exception, pass `state` to `rb_jump_tag()` (this also works for "
"the state from the other `*_protect()` functions)."
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:432
#, markdown-text, no-wrap
msgid "Ensure"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:439
#, markdown-text
msgid ""
"`rb_ensure()` is similar to `rb_rescue()` except that it doesn't do anything "
"about exceptions and the second function is _always_ called after the "
"first.  That may sound simple enough, but that means that if you want the "
"usual `begin; rescue; ensure; end` structure as in Ruby, you'll need another "
"layer of wrapping:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:443
#, markdown-text
msgid "{% highlight c %} {% include c/ensure.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:448
#, markdown-text
msgid ""
"Like `ensure` in Ruby, the return value of `ensure_func()` is never used. If "
"no exception occurs, `rb_rescue()` will return the value of `begin_func()` "
"which returns the value of `dangerous_func()`. If an exception does occur, "
"`rb_rescue()` returns the value of `rescue_func()`."
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:449
#, markdown-text, no-wrap
msgid "Definitions, Declarations"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:454
#, markdown-text
msgid ""
"So far we've been creating and modifying objects directly in the VM's "
"memory, but none of our API calls have had a visible effect _within the Ruby "
"code_: a `String` made with `rb_str_new_cstr()` can only be accessed from C "
"by default."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:463
#, markdown-text
msgid ""
"There are a few ways to make things visible to Ruby but they all work the "
"same general way: by defining some name that Ruby can access e.g. a variable "
"name, a method name, etc. A general warning though: unlike Ruby, **the API "
"lets you give things invalid names**. Ruby will raise a `SyntaxError` or "
"`NameError` if you try to name a class `foo` (not constant) or an instance "
"variable `bar` (no `@`), but the API will happily create them. The API "
"handles this by **not exposing invalid names to Ruby**. Since that's "
"probably not what you want, double check the names you choose!"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:469
#, markdown-text
msgid ""
"Most of the API functions in this section correspond closely to "
"metaprogramming methods in Ruby. When you're trying to do something using "
"the API, it can be helpful to think about how you would do it in Ruby using "
"only metaprogramming method calls. For example, rather than `class Foo; def "
"bar; end; end`, think `Foo = Class.new; Foo.define_method(:bar) {}`."
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:470
#, markdown-text, no-wrap
msgid "Global Variables"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:473
#, markdown-text
msgid "The simplest way to deal with globals is:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:477
#, markdown-text
msgid "{% highlight c %} {% include c/global.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:480
#, markdown-text
msgid ""
"If you're frequently accessing Ruby's globals, you can set up a `VALUE` "
"which will be automatically synchronized with one."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:484
#, markdown-text
msgid "{% highlight c %} {% include c/global2.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:491
#, markdown-text
msgid ""
"The `VALUE` should be initialized before you create the global in Ruby and "
"it should be global in C as well&mdash;you don't want it to go out of scope "
"while Ruby is using it! For `rb_define_hooked_variable()`, you can pass "
"`NULL` for the getter/setter if you want to synchronize normally for that "
"operation. Or you can throw out `global` entirely with "
"`rb_define_virtual_variable()` though of course the getter and setter _must_ "
"be defined in that case."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:495
#, markdown-text
msgid ""
"If you ever create a global `VALUE` in C which is _not_ exposed to Ruby, you "
"must tell the garbage collector about it to prevent it from being "
"prematurely cleaned up:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:499
#, markdown-text
msgid "{% highlight c %} {% include c/gc.h %} {% endhighlight %}"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:500
#, markdown-text, no-wrap
msgid "Class and Instance Variables"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:504
#, markdown-text
msgid ""
"Getting/setting instance variables is similar to the simple way of accessing "
"globals, but of course you need an object to get the variable from."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:508
#, markdown-text
msgid "{% highlight c %} {% include c/ivar.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:511
#, markdown-text
msgid ""
"There isn't an automatic way to synchronize instance variables like you can "
"with globals."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:513
#, markdown-text
msgid "To iterate over all instance variables, use `rb_ivar_foreach`."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:516
#, markdown-text
msgid ""
"For class variables, the methods are `rb_cv_get()` and `rb_cv_set()` and of "
"course the first argument should be a class object."
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:517
#, markdown-text, no-wrap
msgid "Constants ####"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:520
#, markdown-text
msgid "Constants are defined similarly, but with the module to define them under:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:524
#, markdown-text
msgid "{% highlight c %} {% include c/constant.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:528
#, markdown-text
msgid ""
"You undefine a constant by setting it to `Qundef`. Getting a constant's "
"`VALUE` is a little nuanced. The API function you call depends on what you "
"want to happen if the constant is _not_ defined in the module you specify:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:532
#, markdown-text
msgid "{% highlight c %} {% include c/const_get.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:534
#, markdown-text
msgid "All of these API calls will get private constants too."
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:535
#, markdown-text, no-wrap
msgid "Modules and Classes"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:538
#, markdown-text
msgid "Defining modules is super easy."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:542
#, markdown-text
msgid "{% highlight c %} {% include c/module.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:544
#, markdown-text
msgid "Classes work the same way but they also need a superclass."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:548
#, markdown-text
msgid "{% highlight c %} {% include c/class.h %} {% endhighlight %}"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:549
#, markdown-text, no-wrap
msgid "Methods"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:555
#, markdown-text
msgid ""
"Here's where it gets interesting. There are many kinds of API calls for "
"defining methods, but before you use any of them you'll need a C function "
"that the method calls. The function must return a `VALUE` and have one "
"`VALUE` argument for the receiver of the method. There are three ways you "
"can define its other arguments:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:559
#, markdown-text
msgid "{% highlight c %} {% include c/methodc.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:564
#, markdown-text
msgid ""
"So really the API only lets you define two types of methods: ones that take "
"a fixed number of arguments, and ones that slurp up all of their "
"arguments. What about all of Ruby's fancy argument features? Where are "
"optional arguments, options hashes, blocks, and all the mixtures of those?"
msgstr ""

#. type: Title ####
#: _posts/2010-01-01-c.markdown:565
#, markdown-text, no-wrap
msgid "Parsing Arguments"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:572
#, markdown-text
msgid ""
"Well, if you accept a variable number of arguments you could code all of "
"that logic yourself in the method, and make it _behave_ like it has a "
"fancier method definition in Ruby. Thankfully, the API has a shortcut for "
"doing exactly that.  To use it, you should use the C array function "
"definition, then you can pass `argc` and `argv` along to:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:576
#, markdown-text
msgid "{% highlight c %} {% include c/scan.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:581
#, markdown-text
msgid ""
"Here `fmt` is a format string describing how the method arguments would look "
"in Ruby. The string can have at most 6 characters, where each character "
"describes a different section of the arguments. The six sections and their "
"corresponding characters are (in order):"
msgstr ""

#. type: Bullet: '1. '
#: _posts/2010-01-01-c.markdown:588
#, markdown-text
msgid "The number of leading mandatory arguments: a digit"
msgstr ""

#. type: Bullet: '2. '
#: _posts/2010-01-01-c.markdown:588
#, markdown-text
msgid "The number of optional arguments: a digit"
msgstr ""

#. type: Bullet: '3. '
#: _posts/2010-01-01-c.markdown:588
#, markdown-text
msgid "A splatted argument: `*`"
msgstr ""

#. type: Bullet: '4. '
#: _posts/2010-01-01-c.markdown:588
#, markdown-text
msgid "The number of trailing mandatory arguments: a digit"
msgstr ""

#. type: Bullet: '5. '
#: _posts/2010-01-01-c.markdown:588
#, markdown-text
msgid "Keyword arguments: `:`"
msgstr ""

#. type: Bullet: '6. '
#: _posts/2010-01-01-c.markdown:588
#, markdown-text
msgid "A block argument: `&`"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:598
#, markdown-text
msgid ""
"Each section is optional, so you can leave out the characters for things you "
"don't need. Be aware that the parsing of the format string is greedy: `1*` "
"describes a method with one mandatory argument and a splat. If you want one "
"_optional_ argument and a splat you must specify `01*`. Following the format "
"string, you must pass a `VALUE*` for each _Ruby_ argument. The number of "
"pointers passed should equal the \"total\" of the six sections, though you "
"can pass `NULL` for an argument you don't care about. For example the format "
"string `21*&` should have 5 `VALUE*`s passed (2 mandatory, 1 optional, 1 "
"splatted, 1 block)."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:601
#, markdown-text
msgid ""
"`rb_scan_args()` unpacks `argv` using the `VALUE*`s you pass it and will "
"raise a fitting exception if the wrong number of arguments were passed."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:605
#, markdown-text
msgid "{% highlight c %} {% include c/methodex.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:609
#, markdown-text
msgid ""
"You can also use the return value of `rb_scan_args()` to determine how the "
"function was called. It returns the number of arguments that were passed in "
"Ruby."
msgstr ""

#. type: Title ####
#: _posts/2010-01-01-c.markdown:610
#, markdown-text, no-wrap
msgid "Handling Blocks"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:613
#, markdown-text
msgid "There are two ways to check if your C method has been called with a block:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:617
#, markdown-text
msgid "{% highlight c %} {% include c/checkblock.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:622
#, markdown-text
msgid ""
"There are two ways to capture the block as a proc. If you're using "
"`rb_scan_args()` for your method arguments, just include `&` in your format "
"string to get it. If you aren't using `rb_scan_args()`, there's an API call "
"equivalent to `Proc.new` which converts the method's block to a proc:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:625
#, markdown-text, no-wrap
msgid ""
"    VALUE block;\n"
"    block = rb_block_proc();\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:627
#, markdown-text
msgid "If you don't want to capture the block, there are a few ways to yield to it:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:631
#, markdown-text
msgid "{% highlight c %} {% include c/yield.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:634
#, markdown-text
msgid ""
"There's also `rb_yield_values2()` which is like `rb_yield_values()` but "
"instead of varargs the second argument is a `VALUE*`[^yield]."
msgstr ""

#. type: Title ####
#: _posts/2010-01-01-c.markdown:635
#, markdown-text, no-wrap
msgid "Super"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:638
#, markdown-text
msgid "You might want to call `super` in your method."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:642
#, markdown-text
msgid "{% highlight c %} {% include c/super.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:648
#, markdown-text
msgid ""
"Unlike in Ruby `rb_call_super()` will **not** implicitly pass along the "
"method arguments to the super if you give it no arguments. You must "
"explicitly pass the correct `argc` and `argv` (it _does_ automatically pass "
"`self`). For that reason I recommend using the C array style of method "
"definition if you want to use `rb_call_super()`."
msgstr ""

#. type: Title ####
#: _posts/2010-01-01-c.markdown:649
#, markdown-text, no-wrap
msgid "Definition"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:655
#, markdown-text
msgid ""
"Setting up the C function is the hard part, now it's easy to define the "
"method in Ruby. Every API call to create a method takes at least the method "
"name (`char*`), a pointer to your C function, and an `argc` describing its "
"arguments.  `argc` should be:"
msgstr ""

#. type: Bullet: '1. '
#: _posts/2010-01-01-c.markdown:660
#, markdown-text
msgid ""
"For a fixed number of arguments, the number of arguments (not counting the "
"receiver)"
msgstr ""

#. type: Bullet: '2. '
#: _posts/2010-01-01-c.markdown:660
#, markdown-text
msgid "For a variable number of arguments in a C array, `-1`"
msgstr ""

#. type: Bullet: '3. '
#: _posts/2010-01-01-c.markdown:660
#, markdown-text
msgid "For a variable number of arguments in a Ruby Array, `-2`"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:662
#, markdown-text
msgid "Everything is pretty self-explanatory from there:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:666
#, markdown-text
msgid "{% highlight c %} {% include c/methodr.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:670
#, markdown-text
msgid ""
"There's also a shortcut for defining a method in a module _and_ its "
"singleton class. This is used a lot in `Math`, for example, letting you "
"`include Math` to avoid typing `Math.` before every method call."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:674
#, markdown-text
msgid "{% highlight c %} {% include c/modulefunc.h %} {% endhighlight %}"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:675
#, markdown-text, no-wrap
msgid "Other Stuff"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:678
#, markdown-text
msgid "Some simple API functions for class/method definitions:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:682
#, markdown-text
msgid "{% highlight c %} {% include c/etc.h %} {% endhighlight %}"
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:683
#, markdown-text, no-wrap
msgid "Data"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:690
#, markdown-text
msgid ""
"By now you should be able to create and manipulate Ruby classes using the "
"API, but how can you create a Ruby class that encapsulates data from the C "
"world? If your data can be naturally translated into `VALUE`s it's easy: "
"convert and assign to instance variables as usual. But what if your data "
"have no Ruby analog (e.g. data structures defined by some C library)?"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:697
#, markdown-text
msgid ""
"The API lets you encapsulate C data by creating a `VALUE` of the desired "
"class and then storing a `void*` pointing to the C data inside the Ruby "
"object. Then whenever you need access to the C data, you can unpack the "
"pointer and cast it back to the correct type. But where does this "
"encapsulation occur? Let's answer that question with a question: what "
"happens when you tell Ruby to create an object using `new`? Basically this:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:701
#, markdown-text
msgid "{% highlight ruby %} {% include c/new.rb %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:707
#, markdown-text
msgid ""
"Before calling the _instance method_ `initialize` that we know so well, "
"`new` first calls the _class method_ `allocate` to actually create the "
"object. That is the method you'll need to define if you want your objects to "
"wrap C data. The following example creates a class `Foo` which wraps an "
"`int` that can be set by `initialize`:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:711
#, markdown-text
msgid "{% highlight c %} {% include c/wrap.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:719
#, markdown-text
msgid ""
"In most cases you'll probably be wrapping something more complicated (like a "
"`struct`), but the principles will be the same. After allocating the C data, "
"we use the `TypedData_Wrap_Struct()`[^oldwrap] macro to wrap the pointer in "
"a `VALUE`. This wrapping takes three arguments: the class of the object "
"(`self` because we're in a class method), a pointer to a struct, and the "
"data pointer to be wrapped. The tricky part is the struct pointer; it "
"provides additional information for internal use by Ruby:"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:736
#, markdown-text
msgid ""
"`wrap_struct_name` is a string used by Ruby to identify your type. It "
"doesn't really matter what it is as long as it's sensible and unique"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:736
#, markdown-text
msgid ""
"`function` is a struct containing several function pointers for use by the "
"garbage collector"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:736
#, markdown-text
msgid ""
"`dmark` will be described later, but as long your C data doesn't point to "
"any Ruby objects you don't need it"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:736
#, markdown-text
msgid ""
"`dfree` will be called when your object is destroyed and should free all "
"memory allocated by the object"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:736
#, markdown-text
msgid ""
"`dsize` is called by Ruby to check how much memory your object is taking "
"up.  It _can_ be omitted, but it's polite to include it"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:736
#, markdown-text
msgid ""
"`data` can point to arbitrary data. Think of it as wrapping C data at a "
"class level. Also not manadatory"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:736
#, markdown-text
msgid ""
"`flags` lets you enable additional optimizations when your objects are "
"garbage collected. As long as your `dfree` function doesn't unlock the "
"[GVL](#c-in-ruby-threads) (why would you do that???) you can safely set it "
"to `RUBY_TYPED_FREE_IMMEDIATELY` for a slight performance improvement"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:741
#, markdown-text
msgid ""
"If you don't set some of these members, you should zero them out so that "
"Ruby doesn't accidentally read garbage data. That's why I used C99's "
"[designated initializer][desinit] syntax in the example above: any members "
"you omit will be safely cleared by the compiler."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:743
#, markdown-text
msgid "[desinit]: https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:747
#, markdown-text
msgid ""
"`VALUE`s that wrap C data will have type `T_DATA` with respect to the "
"[`TYPE()` macro](#value). This helps ensure a clear separation between "
"native Ruby objects and those wrapping C data."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:752
#, markdown-text
msgid ""
"Once you've done all of that work to wrap up the C data, getting it back out "
"is easy: `TypedData_Get_Struct()` takes the object to unwrap, the C type of "
"the underlying data, the same struct pointer as before, and the pointer to "
"assign the data to."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:758
#, markdown-text
msgid ""
"This separation of allocation and initialization doesn't jive with "
"[RAII][raii], so if you're using C++ you will probably want to use "
"[placement new][place] when wrapping data. If you're having trouble "
"splitting up allocation and initialization, you can just wrap your data in a "
"`struct` and do the _actual_ allocation in `initialize`."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:761
#, markdown-text
msgid ""
"[raii]: http://wikipedia.org/wiki/Resource_Acquisition_Is_Initialization "
"[place]: http://en.cppreference.com/w/cpp/language/new#Allocation"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:769
#, markdown-text
msgid ""
"In simple cases (like the previous example) you can make your code a little "
"less verbose. If the function to free your data just calls `free()` as in "
"the example, you can pass `RUBY_DEFAULT_FREE` for `dfree` and Ruby will free "
"it for you (**don't** use `NULL` unless you like memory leaks). Similarly, "
"if your allocation is just a `malloc()` as in the example, the macro "
"`TypedData_Make_Struct()` does the allocation for you _and_ wraps it. We "
"could shorten the previous example as such:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:773
#, markdown-text
msgid "{% highlight c %} {% include c/makestruct.h %} {% endhighlight %}"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:774
#, markdown-text, no-wrap
msgid "Marking"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:783
#, markdown-text
msgid ""
"That `dmark` pointer in the type structure above is the pointer to your "
"object's \"mark function\". This is so named because of the garbage "
"collector's \"mark and sweep\" algorithm. The basic idea behind mark and "
"sweep is that when the garbage collector needs to free up memory, it "
"performs two passes: the first (mark) pass iterates through every "
"_referenced_ Ruby object and marks it as active, then the second (sweep) "
"pass iterates through every _allocated_ Ruby object and frees the ones that "
"haven't been marked active."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:793
#, markdown-text
msgid ""
"This is relevant to wrapping C data because it's possible that you might "
"wrap a C `struct` which contains a Ruby `VALUE`&mdash;which the garbage "
"collector is responsible for cleaning up. Since the garbage collector is "
"only aware of `VALUE`s referenced _by Ruby_ (not by C pointers), it won't be "
"able to mark the referenced `VALUE` as active. The result is that as soon as "
"the garbage collector needs to free up some memory, your C data is going to "
"end up with a reference to a nonexistent Ruby object. Note that this kind of "
"wrapping of Ruby data inside C data is a really bad idea, precisely because "
"of this kind of issue. But if you really must..."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:797
#, markdown-text
msgid ""
"In the following example, we'll wrap a C `struct` which contains a "
"`VALUE`. The mark function has the same signature as the free function and "
"all it has to do is mark any `VALUE`s in the `struct`:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:801
#, markdown-text
msgid "{% highlight c %} {% include c/mark.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:806
#, markdown-text
msgid ""
"If your `struct` contains a pointer to a C array of `VALUE`s, you can "
"instead use `rb_gc_mark_locations()` which takes two arguments: the pointers "
"to the start and end of the array (the end being equal to the starting "
"pointer plus the array length).[^maybe]"
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:807
#, markdown-text, no-wrap
msgid "Threading"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:809
#, markdown-text, no-wrap
msgid "Ruby in C Threads"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:819
#, markdown-text
msgid ""
"If you're making a lot of API calls and running a lot of Ruby code from C, "
"at some point you might catch yourself thinking, \"I'm running all of these "
"slow Ruby methods using the API. Maybe I can thread things to keep my code "
"fast!\" That's a reasonable thought, but when you act on it keep in mind "
"that **the Ruby VM is not at all thread safe**. Ideally, all of your API "
"code should run in a single thread. If not, you'll probably need to wrap "
"every API call with a locked mutex to make sure that you never ever have "
"multiple threads interacting with the API at the same time."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:822
#, markdown-text
msgid ""
"If you just want to create normal Ruby `Thread`s using the API (and don't "
"mind the GVL, as described in the next section), there's an easy way to do "
"that:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:826
#, markdown-text
msgid "{% highlight c %} {% include c/thread.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:829
#, markdown-text
msgid ""
"Other `Thread` functions are in `ruby/intern.h` (but there's always "
"`rb_funcall()` for everything else)."
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:830
#, markdown-text, no-wrap
msgid "C in Ruby Threads"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:838
#, markdown-text
msgid ""
"On the other hand, if you expose some heavy C code to Ruby with the API (if "
"you're writing an extension that wraps a C library, for example), you should "
"spend some time thinking about a nasty thing called the global VM lock "
"(GVL).  Because most of the API is not `Thread` safe, the GVL locks down "
"almost all Ruby code so that only a single `Thread` can run at a time. This "
"is the reason why you'll often hear people say that `Thread` does not allow "
"true parallelism."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:850
#, markdown-text
msgid ""
"The VM also applies the GVL to any C code you expose to Ruby. That's why you "
"can use the API without worrying about it exploding when someone calls your "
"C code from inside a `Thread`. The downside of this is that if your C code "
"takes a while to run, you won't see any performance benefit from calling it "
"in a `Thread` because **it will block all other threads** while it runs. But "
"the GVL is only needed to protect API calls. If you have some C code that "
"doesn't use the API, you can tell the VM to release the GVL before running "
"your code in a thread and to reacquire it when it completes, allowing for "
"true parallelism.  Locking and unlocking the GVL does carry a performance "
"hit, so only resort to this if you notice that you're having significant "
"problems due to blocked threads."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:854
#, markdown-text
msgid ""
"The code to do this is considered so fancy by the Ruby developers that you "
"actually need to include another header to use it. First we'll look at the "
"slightly simpler way to release the GVL:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:858
#, markdown-text
msgid "{% highlight c %} {% include c/gvl2.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:861
#, markdown-text
msgid ""
"Since the function that is run without the GVL gets and returns data using "
"`void*`, you may want to define a `struct` for passing data via pointers."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:866
#, markdown-text
msgid ""
"If you unlock the GVL as above you will find that while your code does run "
"in parallel, it can't be interrupted (by signals, `Thread.kill`, etc.)! To "
"allow for that you must pass an unblocking function using the last two "
"arguments:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:870
#, markdown-text
msgid "{% highlight c %} {% include c/gvl.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:875
#, markdown-text
msgid ""
"The unblocking function is called in the event of an interrupt. To make it "
"work, you will probably need to pass a pointer to both functions that can be "
"used to communicate an interrupt from one to the other. The interrupted "
"function should perform any necessary cleanup before returning early."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:880
#, markdown-text
msgid ""
"Alternatively, if the interrupted function doesn't _need_ to perform any "
"special cleanup, you can use the built in unblocking function "
"`RUBY_UBF_IO`[^ubf] (which ignores the unblocking argument). That simply "
"forwards the interrupt to the running thread.[^int]"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:884
#, markdown-text
msgid ""
"If you go through all of that effort to release the GVL only to find that "
"you need to make an API call in your unlocked thread, there's a function to "
"temporarily reacquire the GVL:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:888
#, markdown-text
msgid "{% highlight c %} {% include c/with_gvl.h %} {% endhighlight %}"
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:889
#, markdown-text, no-wrap
msgid "See Also"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:891
#, markdown-text, no-wrap
msgid "extension.rdoc"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:897
#, markdown-text
msgid ""
"Ruby does have [official API documentation][readme]. It's a bit spotty and "
"has some poor recommendations (in my opinion), but it is also a little more "
"exhaustive on certain topics. In many cases this is because I intentionally "
"skipped something that I either found not useful or better documented "
"elsewhere."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:899
#, markdown-text
msgid "[readme]: https://github.com/ruby/ruby/blob/master/doc/extension.rdoc"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:900
#, markdown-text, no-wrap
msgid "Headers"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:910
#, markdown-text
msgid ""
"I think some of the handiest resources are the Ruby headers themselves. The "
"full API (i.e. everything you get by including `ruby.h`) easily consists of "
"a thousand functions, macros, constants, and globals&mdash;most of which "
"have never been documented. However _most_ things are reasonably named and "
"you should be able to figure out what they do from the header. Most "
"everything you need should be in the headers `ruby/ruby.h` and "
"`ruby/intern.h`. The former has all of the VM and metaprogramming functions, "
"the latter has all of the functions for interacting with Ruby's built in "
"classes."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:914
#, markdown-text
msgid ""
"There are also some headers _not_ pulled in by `ruby.h` which you can "
"include to get additional API functionality. Maybe one day I'll write "
"another section to this guide going over them:"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:923
#, markdown-text
msgid "`ruby/debug.h` (experimental) functions for profiling and tracing code"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:923
#, markdown-text
msgid "`ruby/encoding.h` functions for working with string encodings"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:923
#, markdown-text
msgid "`ruby/io.h` additional functions for Ruby's IO class"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:923
#, markdown-text
msgid "`ruby/re.h` additional functions for Ruby's Regexp class"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:923
#, markdown-text
msgid "`ruby/thread.h` functions for working with the [GVL](#c-in-ruby-threads)"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:923
#, markdown-text
msgid ""
"`ruby/version.h` functions for version introspection. Do not use this as "
"feature-detection code!"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:923
#, markdown-text
msgid "`ruby/vm.h` (experimental) functions for VM control"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:924
#, markdown-text, no-wrap
msgid "Source"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:928
#, markdown-text
msgid ""
"If you find some function in the header that isn't documented anywhere, your "
"next stop should be the Ruby source code."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:932
#, markdown-text
msgid ""
"{% highlight shell_session %} $ git clone https://github.com/ruby/ruby.git "
"{% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:937
#, markdown-text
msgid ""
"When reading through the source code, always keep the headers at hand: there "
"are lots of really useful functions in there that _look_ like they should be "
"in the API, but actually aren't. In most cases there should be an API "
"function elsewhere that wraps the call to the useful function."
msgstr ""

#. type: YAML Front Matter: title
#: _posts/2010-01-01-c.markdown:938 _posts/2014-01-01-examples.markdown:1
#, markdown-text, no-wrap
msgid "Examples"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:942
#, markdown-text
msgid ""
"Head over to the [Examples](../examples) page for short, compilable examples "
"of the API in action."
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:943
#, markdown-text, no-wrap
msgid "Contribute"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:949
#, markdown-text
msgid ""
"Now that you've finished reading my guide, did you notice something "
"significant that I left out? Did I make some stupid mistake? Check out the "
"[source][gh] for this site on Github and you can report issues, submit pull "
"requests, and download all of the code examples."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:951
#, markdown-text
msgid "[gh]: https://github.com/silverhammermba/emberb"
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:952 _posts/2012-01-01-embed.markdown:123
#: _posts/2013-01-01-extend.markdown:128
#, markdown-text, no-wrap
msgid "Footnotes"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:958
#, markdown-text, no-wrap
msgid ""
"[^intern]: That's a blatant lie. The API _definitely_ lets you mess around\n"
"           with the internal data structures of objects (look for things "
"with\n"
"           names starting with capital R). But it's generally not a good "
"idea\n"
"           and not necessary.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:963
#, markdown-text, no-wrap
msgid ""
"[^undef]: There's also `Qundef` representing an undefined value, but\n"
"          this has no Ruby equivalent and is [rarely](#handling-blocks)\n"
"          [used](#constants-1). In fact, outside of those rare occassions,\n"
"          `Qundef` can segfault the VM if Ruby was expecting a normal "
"`VALUE`.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:966
#, markdown-text, no-wrap
msgid ""
"[^wrap]: There's also `rb_eval_string_wrap()` which _should_ be useful, but "
"is\n"
"         actually the same as `rb_eval_string_protect()` due to a "
"[bug][bug2].\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:969
#, markdown-text, no-wrap
msgid ""
"[^chr]: There is a `CHR2FIX()` macro, but in my tests this sometimes gave\n"
"        unexpected results. `LONG2FIX()` should work.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:973
#, markdown-text, no-wrap
msgid ""
"[^wchar]: I don't know what the best way is to handle `wchar_t`. In my tests "
"I had\n"
"          some success just treating them as `char`s, but I think that may "
"have\n"
"          been a happy accident, and could certainly fail on different "
"platforms.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:978
#, markdown-text, no-wrap
msgid ""
"[^clear]: The documentation [states][control] that \"You have to clear the "
"error\n"
"          info [when] ignoring the caught exception\" during "
"`rb_protect`. But I\n"
"          can't find any documentation of when it would be cleared for\n"
"          you&mdash;it seems like you _always_ have to clear it.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:981
#, markdown-text, no-wrap
msgid ""
"[^yield]: And there's `rb_yield_block()` which takes two unused arguments "
"and is\n"
"          never called by anything in Ruby. Odd.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:985
#, markdown-text, no-wrap
msgid ""
"[^break]: The documentation [mentions][control] `rb_iter_break()` and\n"
"          `rb_iter_break_value()` for breaking out of a block, but can't "
"you\n"
"          just return early? I can't think of a use-case for these.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:991
#, markdown-text, no-wrap
msgid ""
"[^int]: There is also the function `rb_thread_call_without_gvl2()`. The\n"
"        documentation in `thread.c` says that if it \"detects interrupt, "
"it\n"
"        returns immediately,\" but I'm not sure what this means. If the\n"
"        unblocking function doesn't kill the thread, it still waits for "
"the\n"
"        thread to finish on its own before returning.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:994
#, markdown-text, no-wrap
msgid ""
"[^ubf]: You can also use `RUBY_UBF_PROCESS`, but this seems to be a "
"leftover\n"
"        from deprecated code and has the exact same effect.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:999
#, markdown-text, no-wrap
msgid ""
"[^oldwrap]: The `TypedData*` macros are the preferred way to wrap data "
"since\n"
"            Ruby 1.9.2. If you're using an older version of Ruby you can "
"check\n"
"            out an older version of this guide on Github to see how it used "
"to\n"
"            be done.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:1002
#, markdown-text, no-wrap
msgid ""
"[^maybe]: There's also the enigmatically named `rb_gc_mark_maybe()`, but I'm "
"not\n"
"          sure when it is needed.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:1004
#, markdown-text
msgid "[^tdata]: Or use `T_DATA` if the object [wraps a C pointer](#data)."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:1006
#, markdown-text
msgid ""
"[control]: "
"https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-Control+Structure "
"[bug2]: https://bugs.ruby-lang.org/issues/10466"
msgstr ""

#. type: Title ##
#: _posts/2012-01-01-embed.markdown:1 _posts/2014-01-01-examples.markdown:6
#, markdown-text, no-wrap
msgid "Running Ruby in C"
msgstr ""

#. type: Title ##
#: _posts/2012-01-01-embed.markdown:6 _posts/2013-01-01-extend.markdown:6
#, markdown-text, no-wrap
msgid "Compiling"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:12
#, markdown-text
msgid ""
"Embedding Ruby requires one header `ruby.h`, which includes a "
"platform-specific header `ruby/config.h`. You will probably need to tell "
"your compiler about the include paths for these headers. You will also need "
"to link with the Ruby lib.  On my machine, my minimal compiler options are"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:16
#, markdown-text
msgid ""
"{% highlight shell_session %} $ gcc -I/usr/include/ruby-{{ site.rbversion "
"}}.0 -I/usr/include/ruby-{{ site.rbversion }}.0/x86_64-linux -lruby {% "
"endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:19
#, markdown-text
msgid ""
"Though, if available, you should really use `pkg-config` to get the "
"appropriate options for your distribution:"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:23
#, markdown-text
msgid ""
"{% highlight shell_session %} $ pkg-config --cflags --libs ruby-{{ "
"site.rbversion }} {% endhighlight %}"
msgstr ""

#. type: Title ##
#: _posts/2012-01-01-embed.markdown:24
#, markdown-text, no-wrap
msgid "Startup, Teardown"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:29
#, markdown-text
msgid ""
"Including the Ruby interpreter in your C/C++ program is pretty simple. Just "
"include the header, call a startup function in `main` before you use the "
"API, and a cleanup function after you're done:"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:33
#, markdown-text
msgid "{% highlight c %} {% include embed/simple.c %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:38
#, markdown-text
msgid ""
"If the VM fails to start during `ruby_init()` it will print an error and "
"exit your program! If you would rather have a softer error, you can instead "
"call `ruby_setup()` which returns a nonzero value if a failure occurred "
"(unfortunately it is not clear how to get a message for the error[^err])."
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:43
#, markdown-text
msgid ""
"If an error occurs during `rb_cleanup()`, it returns a nonzero "
"value&mdash;otherwise it returns the argument you passed it. This allows a "
"little shortcut for returning an error status if the cleanup fails (as "
"demonstrated in the previous example)."
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:52
#, markdown-text
msgid ""
"_Technically_ you don't have to call `ruby_init`/`ruby_setup` in `main`, but "
"the Ruby VM assumes that all future Ruby code will be run from the same "
"stack frame or a lower one (for garbage collection purposes). The easiest "
"way to ensure this is to do set up at the top-level of your program, though "
"other approaches could work. But it would be a bad idea, for example, to "
"init Ruby in some deeply-nested function, pop a bunch of stack frames, and "
"then run a bunch of Ruby code.  {: .alert .alert-danger}"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:58
#, markdown-text
msgid ""
"During cleanup, the VM might evaluate more Ruby code (if you passed a block "
"to `at_exit`, for example) which could raise an exception. `ruby_cleanup()` "
"handles these by returning a nonzero value and printing an error message. If "
"you instead call `ruby_finalize()` they will be raised normally (see the "
"section on [Exceptions](../c#rescue) for how to handle them)."
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:60
#, markdown-text
msgid "Here's an alternative example:"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:64
#, markdown-text
msgid "{% highlight c %} {% include embed/advanced.c %} {% endhighlight %}"
msgstr ""

#. type: Title ###
#: _posts/2012-01-01-embed.markdown:65
#, markdown-text, no-wrap
msgid "Limitations"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:73
#, markdown-text
msgid ""
"Other than the stack frame warning above, there is another limitation: you "
"only get one Ruby VM per process. The startup/teardown might make it look "
"like you can keep on destroying and rebuilding the VM over and over again, "
"but `ruby_cleanup` only makes sure that your Ruby code is all cleaned up and "
"done.  It doesn't fully clean up the VM state such that it is ready to be "
"re-initialized: if you call `ruby_init` again, it will fail."
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:76
#, markdown-text
msgid ""
"If for some reason you need multiple Ruby VMs in your program, you will need "
"to spin them off in multiple processes to bypass this limitation."
msgstr ""

#. type: Title ##
#: _posts/2012-01-01-embed.markdown:77
#, markdown-text, no-wrap
msgid "Tweaking the VM"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:82
#, markdown-text
msgid ""
"You now have a bare-bones Ruby VM running, but you may want to set up a "
"little more stuff before you start running Ruby code. To set the name of the "
"Ruby script (e.g. `$0`) for error messages and such, use"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:86
#, markdown-text
msgid "{% highlight c %} ruby_script(\"new name\")  {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:88
#, markdown-text
msgid "To set up the load path so that gems can be loaded with `require`, use"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:92
#, markdown-text
msgid "{% highlight c %} ruby_init_loadpath()  {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:96
#, markdown-text
msgid ""
"You can also pass options to the VM just like you would to `ruby` on the "
"command line. This is handy for stuff like setting the warning level or "
"verbose mode[^opt]."
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:100
#, markdown-text
msgid "{% highlight c %} {% include embed/options.c %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:106
#, markdown-text
msgid ""
"The arguments to `ruby_options` are `argc` and `argv` just like a main "
"function.  And just like the main of the `ruby` program, the VM expects to "
"get some Ruby code when you call it. If you don't give it the filename of a "
"script to load or code to run with `-e`, it will try to read from "
"`stdin`. If you want to set options but _not_ run any Ruby code, you can "
"pass it an empty line: `\"-e \"`."
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:115
#, markdown-text
msgid ""
"`ruby_options()` returns a \"node\" that represents the compiled Ruby "
"code. In some cases (such as a syntax error) the node will be invalid and "
"you shouldn't run it. `ruby_executable_node()` checks for this. If the node "
"is valid, you can run it with `ruby_exec_node()`. The state returned by "
"`ruby_executable_node()` (through the pointer) and by `ruby_exec_node()` "
"will be nonzero if an exception was raised while compiling or running the "
"code. You can [read the exception yourself](../c#rescue), or just pass "
"`state` to `ruby_cleanup()` and it will print an appropriate error message."
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:118
#, markdown-text
msgid ""
"Ruby currently doesn't support any other way of compiling and running code "
"separately[^load]."
msgstr ""

#. type: Title ##
#: _posts/2012-01-01-embed.markdown:119 _posts/2013-01-01-extend.markdown:105
#, markdown-text, no-wrap
msgid "Success"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:122
#, markdown-text
msgid "Now you're ready to interact with Ruby! Go back to the [C API](../c)."
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:127
#, markdown-text, no-wrap
msgid ""
"[^err]: `ruby_init()` uses `error_print()` to get an error message, but "
"this\n"
"        function isn't exposed to the API. Is this a normal exception?\n"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:131
#, markdown-text, no-wrap
msgid ""
"[^opt]: In my tests I couldn't get flags like `-w` and `-v` to do "
"anything. This\n"
"        could be related to `ruby_prog_init()`. And really it should be "
"possible\n"
"        to do this without parsing command line options.\n"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:133
#, markdown-text, no-wrap
msgid ""
"[^load]: It looks like the function `rb_load_file()` should do this, but I\n"
"         haven't had any luck getting it to work.\n"
msgstr ""

#. type: Title ##
#: _posts/2013-01-01-extend.markdown:1 _posts/2014-01-01-examples.markdown:35
#, markdown-text, no-wrap
msgid "Running C in Ruby"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:11
#, markdown-text
msgid ""
"Compiling C code to be loaded as a Ruby extension requires some fancy "
"compiler options. Ruby's [`mkmf` stdlib][mkmf] makes it easy to do this by "
"generating an appropriate makefile for you."
msgstr ""

#. type: Title ###
#: _posts/2013-01-01-extend.markdown:12
#, markdown-text, no-wrap
msgid "Preparation"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:15
#, markdown-text
msgid "First create the file `extconf.rb` in the same directory as your C code:"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:19
#, markdown-text
msgid "{% highlight ruby %} {% include extend/ext/extconf.rb %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:22
#, markdown-text
msgid ""
"The preparation section should perform actions similar to the standard UNIX "
"[`configure` script][conf] e.g."
msgstr ""

#. type: Bullet: '* '
#: _posts/2013-01-01-extend.markdown:26
#, markdown-text
msgid "Check features of the current platform"
msgstr ""

#. type: Bullet: '* '
#: _posts/2013-01-01-extend.markdown:26
#, markdown-text
msgid "Check for existence of required libraries and functions"
msgstr ""

#. type: Bullet: '* '
#: _posts/2013-01-01-extend.markdown:26
#, markdown-text
msgid "Check for programs needed for building"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:28
#, markdown-text
msgid "[conf]: http://en.wikipedia.org/wiki/Configure_script"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:32
#, markdown-text
msgid ""
"The most common of these actions are provided by `mkmf` (but you have all of "
"Ruby at your disposal if you need it). For example, an extension which uses "
"SDL2 and needs to know how big `int`s are might call:"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:36
#, markdown-text
msgid "{% highlight ruby %} {% include extend/ext/exex.rb %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:40
#, markdown-text
msgid ""
"`create_header` creates the file `extconf.h` containing preprocessor "
"definitions based on the results of the `mkmf` functions you called "
"previously. For this example, `extconf.h` might contain"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:44
#, markdown-text
msgid "{% highlight c %} {% include extend/ext/exh.h %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:52
#, markdown-text
msgid ""
"This header should be included in your C files so that you can adapt your "
"code to a variety of platforms. Note that you can and should abort the "
"`extconf.rb` script if a `mkmf` function returns a value that indicates that "
"the build will fail. For example, if SDL2 is a _requirement_ of your "
"extension you should exit with some meaningful error message if "
"`have_library('SDL2')` returns `false`.  This is preferred to generating the "
"Makefile anyway and leaving the user with an opaque compiler error."
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:57
#, markdown-text
msgid ""
"`create_makefile` obviously creates the Makefile, but its argument is "
"especially important: it defines the entry point of your C code, the name of "
"the compiled library, and thus the argument for `require` in Ruby! This "
"should be the name of your extension."
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:63
#, markdown-text
msgid ""
"You can modify a few of the generated Makefile variables by modifying the "
"corresponding globals in Ruby: `$CFLAGS`, `$CPPFLAGS`, and "
"`$LDFLAGS`[^glob].  You can also use the `$objs` global to define a list of "
"object files for the Makefile if its method of automatically generating "
"targets doesn't work for your extension."
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:68
#, markdown-text
msgid ""
"All of the `mkmf` functions and their options are well-documented "
"[online][mkmf]. In addition to the functions for generating `extconf.h`, "
"there are a variety of functions for handling different source file layouts, "
"different file dependencies, etc."
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:70
#, markdown-text
msgid "[mkmf]: http://www.ruby-doc.org/stdlib/libdoc/mkmf/rdoc/MakeMakefile.html"
msgstr ""

#. type: Title ###
#: _posts/2013-01-01-extend.markdown:71
#, markdown-text, no-wrap
msgid "Execution"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:74
#, markdown-text
msgid "The rest couldn't be simpler"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:79
#, markdown-text
msgid "{% highlight shell_session %} $ ruby extconf.rb $ make {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:81
#, markdown-text
msgid "[^argv]But of course that won't do anything without some C code to compile."
msgstr ""

#. type: Title ##
#: _posts/2013-01-01-extend.markdown:82
#, markdown-text, no-wrap
msgid "Init"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:89
#, markdown-text
msgid ""
"In your C code, you'll want to include `ruby.h` to access the API. Other "
"than that the only requirement is to define a function for the Ruby VM to "
"call when your library is `require`d. The name of the function is determined "
"by the argument you passed to `create_makefile` in `extconf.rb`. We used "
"\"foobar\" in our example, so we'll create `foobar.c` containing"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:93
#, markdown-text
msgid "{% highlight c %} {% include extend/ext/foobar.c %} {% endhighlight %}"
msgstr ""

#. type: Title ###
#: _posts/2013-01-01-extend.markdown:94
#, markdown-text, no-wrap
msgid "Filenames"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:101
#, markdown-text
msgid ""
"If your extension has only a single C file, you should name it after your "
"extension as we did above. If your extensions has multiple C files _do not_ "
"name any of them after your extension. This is because the Makefile may "
"generate a `.o` file named after your extension for the linking stage, which "
"would cause a conflict if you also have a `.c` file which compiles to that "
"filename."
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:104
#, markdown-text
msgid ""
"Also avoid naming any files `conftest.c` as this file may be written to by "
"`mkmf`."
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:111
#, markdown-text
msgid ""
"Now make should compile a `.so` (or some other library) file which you can "
"`require` in Ruby. You can fill in your `Init` function with plain C code, "
"but you'll probably want to go back and learn about the [C API](../c) to do "
"more interesting stuff."
msgstr ""

#. type: Title ##
#: _posts/2013-01-01-extend.markdown:112
#, markdown-text, no-wrap
msgid "Gem"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:118
#, markdown-text
msgid ""
"After you've got your extension working nicely, you may want to bundle it up "
"as an easily distributable Ruby gem. rubygems.org has a [detailed "
"guide][rbg] on creating gems, but as far as C extensions go you just need to "
"tell the spec about `extconf.rb`[^rbg]:"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:122
#, markdown-text
msgid "{% highlight ruby %} {% include extend/foobar.gemspec %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:125
#, markdown-text
msgid ""
"If your gem includes multiple independent extensions, you can organize them "
"in subdirectories of `ext/` and pass all of the `extconf.rb`s to the spec."
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:127
#, markdown-text
msgid "[rbg]: http://guides.rubygems.org/make-your-own-gem/"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:131
#, markdown-text
msgid "[^glob]: Check the [official documentation][globals]."
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:135
#, markdown-text, no-wrap
msgid ""
"[^argv]: The official documentation [hints][makefile] that `mkmf` parses "
"certain\n"
"         command line flags e.g.  `--vendor`. But I can't find this "
"documented\n"
"         anywhere.\n"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:137
#, markdown-text
msgid ""
"[^rbg]: "
"[http://guides.rubygems.org/gems-with-extensions/](http://guides.rubygems.org/gems-with-extensions/)"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:139
#, markdown-text
msgid ""
"[globals]: "
"https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-Prepare+extconf.rb "
"[makefile]: "
"https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-Generate+Makefile"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:14
#, markdown-text
msgid ""
"This example is a simple little game of tag. In the game there are two "
"squares: the blue square is controlled using the arrow keys on the keyboard "
"while the red square is controlled by a Ruby script. To make this work, "
"we'll use the C API to define a little Ruby API that the script can access, "
"and every couple of frames we'll call a method defined in the Ruby script "
"and pass objects encapsulating the data for the two squares."
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:16
#, markdown-text
msgid "The Ruby script can look something like this:"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:20
#, markdown-text
msgid "{% highlight ruby %} {% include examples/ai.rb %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:24
#, markdown-text
msgid ""
"The C code uses SDL2 for graphics and input and uses `stat()` (which may not "
"be very portable) to hot-reload the AI script whenever the file is changed "
". Here's `tag.c`:"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:28
#, markdown-text
msgid "{% highlight c %} {% include examples/tag.c %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:30
#, markdown-text
msgid "The Makefile is nothing special:"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:34
#, markdown-text
msgid "{% highlight make %} {% include examples/Makefile %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:42
#, markdown-text
msgid ""
"This example is a Ruby C extension that wraps the [GMP][gmp] C library for "
"arbitrary precision arithmetic. This is far from a complete example: it only "
"wraps the integer functions, implements only the basic functionality of the "
"library, and doesn't bother nicely integrating with Ruby's existing numeric "
"types. If you want a _really_ full example, check out the [GMP gem][gem]."
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:45
#, markdown-text
msgid "[gmp]: https://gmplib.org/ [gem]: https://github.com/srawlins/gmp"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:47
#, markdown-text
msgid "Everything is in `gmp.c` where we define our `GMP::Integer` class:"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:51
#, markdown-text
msgid "{% highlight c %} {% include examples/ext/gmp.c %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:53
#, markdown-text
msgid "The `extconf.rb` is really simple."
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:57
#, markdown-text
msgid ""
"{% highlight ruby %} {% include examples/ext/extconf.rb %} {% endhighlight "
"%}"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:59
#, markdown-text
msgid "And now you can finally find out what your name means in base 62:"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:63
#, markdown-text
msgid "{% highlight ruby %} {% include examples/gmp_ex.rb %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:70
#, markdown-text
msgid ""
"For this example I tried to do everything in C, but practically that isn't "
"necessary (or desirable). If one of your C methods just calls a bunch of API "
"functions (like `to_i` and `==` in the example), you're probably only saving "
"yourself a couple CPU cycles compared to implementing the method in "
"Ruby. And of course that comes at the cost of needing to spend more time "
"writing C and less time writing Ruby. "
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:75
#, markdown-text
msgid ""
"A common convention when writing extensions is to only implement the "
"\"meat\" of the extension in C and to do everything else in a regular Ruby "
"script that pulls in the compiled library. For example, we could have "
"written a `gmp.rb` script to significantly simplify our extension:"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:78
#, markdown-text
msgid "{% highlight ruby %} {% include examples/gmp.rb %} {% endhighlight %}"
msgstr ""

#. type: Plain text
#: README.md:3
#, markdown-text
msgid ""
"This is the source for my online guide to Ruby's C API. Visit the live site "
"[here][io]."
msgstr ""

#. type: Plain text
#: README.md:5
#, markdown-text
msgid "[io]: http://silverhammermba.github.io/emberb"
msgstr ""

#. type: Title #
#: README.md:6
#, markdown-text, no-wrap
msgid "Why I'm Making This Guide"
msgstr ""

#. type: Plain text
#: README.md:11
#, markdown-text
msgid ""
"Oh my god there are so [many][g] [freaking][f] [guides][e] [to][d] "
"[Ruby's][c] [C][b] [API][a]. Why make another one? Because from what I've "
"seen of the others:"
msgstr ""

#. type: Bullet: '* '
#: README.md:18
#, markdown-text
msgid "Most of them are outdated"
msgstr ""

#. type: Bullet: '* '
#: README.md:18
#, markdown-text
msgid "Most fail to cover different approaches when they are available"
msgstr ""

#. type: Bullet: '* '
#: README.md:18
#, markdown-text
msgid "Many cover only very specific use-cases"
msgstr ""

#. type: Bullet: '* '
#: README.md:18
#, markdown-text
msgid "Many have bad recommendations"
msgstr ""

#. type: Bullet: '* '
#: README.md:18
#, markdown-text
msgid "Many fail to explain _when_ and _why_ things are needed"
msgstr ""

#. type: Bullet: '* '
#: README.md:18
#, markdown-text
msgid "Many try to be exhaustive rather getting the reader up and running quickly"
msgstr ""

#. type: Plain text
#: README.md:22
#, markdown-text
msgid ""
"And it struck me that all of these problems come from these guides largely "
"being on media that do not promote community-driven updates. So I'm writing "
"a new guide that doesn't suck and is on Github so you too can help make it "
"not suck."
msgstr ""

#. type: Plain text
#: README.md:29
#, markdown-text
msgid ""
"[a]: "
"http://clalance.blogspot.com/2011/01/writing-ruby-extensions-in-c-part-1.html "
"[b]: https://raw.githubusercontent.com/ruby/ruby/master/doc/extension.rdoc "
"[c]: http://blog.jacius.info/ruby-c-extension-cheat-sheet/ [d]: "
"http://hugopl.github.io/2014/04/09/Embedding-Ruby-2.1-into-a-Cpp-application.html "
"[e]: https://gist.github.com/jefftrull/1305431 [f]: "
"http://metaeditor.sourceforge.net/embed/ [g]: "
"http://ruby-doc.com/docs/ProgrammingRuby/html/ext_ruby.html"
msgstr ""

#. type: YAML Front Matter: layout
#: index.markdown:1
#, no-wrap
msgid "default"
msgstr ""

#. type: YAML Front Matter: title
#: index.markdown:1
#, no-wrap
msgid "The Definitive Guide to Ruby's C API"
msgstr ""

#. type: Plain text
#: index.markdown:10
#, markdown-text, no-wrap
msgid ""
"<div class=\"container\">\n"
"<div class=\"jumbotron\">\n"
"This site is a complete, practical guide to using Ruby's C API. Get "
"started\n"
"[here][start].\n"
msgstr ""

#. type: Plain text
#: index.markdown:17
#, markdown-text, no-wrap
msgid ""
"This site is generated from a [Github repo][repo]. If something isn't "
"working\n"
"the way I described it or you notice a gaping hole in the guide, please "
"[submit\n"
"an issue][iss]. If you know a better way of doing something than I do, "
"please\n"
"consider [submitting a pull request][pull].\n"
"</div>\n"
"</div>\n"
msgstr ""

#. type: Plain text
#: index.markdown:21
#, markdown-text
msgid ""
"[start]: c [repo]: https://github.com/silverhammermba/emberb [iss]: "
"https://github.com/silverhammermba/emberb/issues/new [pull]: "
"https://github.com/silverhammermba/emberb/pulls"
msgstr ""
