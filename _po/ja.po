# Japanese translations for emberb
# emberbに対する和訳
# Copyright (C) 2022 gemmaro.
# This file is distributed under the same license as the emberb.
#
msgid ""
msgstr ""
"Project-Id-Version: https://silverhammermba.github.io/emberb/\n"
"POT-Creation-Date: 2022-05-23 23:00+0900\n"
"PO-Revision-Date: 2023-02-23 18:17+0900\n"
"Last-Translator: gemmaro <gemmaro.dev@gmail.com>\n"
"Language-Team: none\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: YAML Front Matter: layout
#: _posts/2010-01-01-c.markdown:1 _posts/2012-01-01-embed.markdown:1
#: _posts/2013-01-01-extend.markdown:1 _posts/2014-01-01-examples.markdown:1
#, no-wrap
msgid "chapter"
msgstr "chapter"

#. type: YAML Front Matter: title
#: _posts/2010-01-01-c.markdown:1
#, no-wrap
msgid "The Ruby C API"
msgstr "RubyのC API"

#. type: Title ##
#: _posts/2010-01-01-c.markdown:6
#, no-wrap
msgid "Before You Start"
msgstr "始める前に"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:10
msgid ""
"For the greatest chance of success with this guide, I recommend being fairly "
"comfortable with C and _very_ comfortable with Ruby."
msgstr "このガイドを完全に理解するためには、C言語はそこそこ、Rubyは _かなり_ 慣れ親しんでいるとよいでしょう。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:16
msgid ""
"Using Ruby's C API does not require any advanced C concepts, however the API "
"is **huge** and largely **undocumented**. After you start using it, you will "
"likely find yourself delving through the Ruby source code at some point to "
"figure out the behavior of some obscure function or macro. The Ruby source "
"uses some fairly sophisticated C, so you should at least feel comfortable "
"reading it."
msgstr ""
"RubyのC APIを使うのに発展的なC言語の概念は要りませんが、\n"
"APIは**膨大**で大半が**文書化されていません**。\n"
"APIを使い始めだすと、いつの日にか、\n"
"はっきりしない関数やマクロの振舞いを見つけるためにRubyのソースコードを探ることになるでしょう。\n"
"Rubyのソースはそこそこ洗練されたC言語で書かれているので、\n"
"すいすい読めはするでしょうけれども。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:22
msgid ""
"You can think of the C API is being a big, clunky alternative to writing "
"normal Ruby code. However the simple, elegant patterns of Ruby can be pretty "
"unintuitive once translated into the language of the API. Having a strong "
"intuition for Ruby's internal logic and the ideas behind its design will go "
"a long way toward steering you toward the correct API functions."
msgstr ""
"C APIは、普通のRubyのコードよりもデカくてゴチャっとした書き方だと見なせます。\n"
"とはいえ、簡素で明快なRubyの様式は、ひとたびAPIの言葉に翻訳されるとかなり非直感的になることがあります。\n"
"Rubyの内部論理と設計の背後にある思想に裏打ちされたしっかりとした直感があれば、\n"
"長い旅路のさなかでも正しいAPI関数へと進み続けられるでしょう。"

#. type: Title ##
#: _posts/2010-01-01-c.markdown:23
#, no-wrap
msgid "The Two Paths"
msgstr "分岐点"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:28
msgid ""
"The official Ruby interpreter is written in C. That means that everything "
"you can do in Ruby, you can also do using function calls to Ruby's C API. "
"Why in the world would you do this? There are two good reasons:"
msgstr ""
"公式のRubyインタプリタはC言語で書かれています。\n"
"Rubyでできるあらゆることは、RubyのC APIを呼び出す関数を使ってもできます。\n"
"いったいなぜそんなことをするのでしょうか？\n"
"もっともな理由が2つあります。"

#. type: Bullet: '1. '
#: _posts/2010-01-01-c.markdown:37
msgid ""
"You're writing some fancy application in C or C++ and you want some parts of "
"your code to leverage the dynamic flexibility of Ruby. You can run the Ruby "
"interpreter inside of your application and use the API to retrieve the "
"results of Ruby code."
msgstr ""
"意匠を凝らしたC言語ないしC++のアプリケーションを書いている最中で、\n"
"Rubyの動的な柔軟性をコードのいくつかの箇所に使って、\n"
"効果を引き出そうとするとき。\n"
"アプリケーションの内部でRubyインタプリタを実行でき、\n"
"Rubyのコードの結果をAPIで受け取ることができます。"

#. type: Bullet: '2. '
#: _posts/2010-01-01-c.markdown:37
msgid ""
"You're writing some fancy application in Ruby and you want some parts of "
"your code to leverage the speed and power of C (or an existing C library). "
"You can expose C code to Ruby using the API and compile a special library "
"that Ruby can `require`."
msgstr ""
"意匠を凝らしたRubyのアプリケーションを書いている最中で、\n"
"C言語（もしくは既にあるC言語のライブラリ）の速度と能力を\n"
"コードのいくつかの箇所に使って、\n"
"効果を引き出そうとするとき。\n"
"APIを使えば、RubyにC言語のコードをさらけ出すことができます。\n"
"そうしてできた特別なライブラリをコンパイルするとRubyから `require` できます。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:42
msgid ""
"You'll need to structure your C code differently depending on your goal. If "
"you want to embed the Ruby interpreter in C, read [Running Ruby in C](../"
"embed). If you want to `require` a compiled C library, read [Running C in "
"Ruby](../extend).  After you finish that, come back here to learn about the "
"API."
msgstr ""
"目標によってC言語のコードの組み立てかたは変わってきます。\n"
"C言語にRubyインタプリタを組込みたければ、\n"
"[C言語でRubyを実行する](../embed.ja)をお読みください。\n"
"コンパイルされたC言語のライブラリを `require` したければ、\n"
"[RubyでC言語を実行する](../extend.ja)をお読みください。\n"
"どちらかを読み終えたら、ここに戻ってきてAPIについて学びましょう。"

#. type: Title ##
#: _posts/2010-01-01-c.markdown:43
#, no-wrap
msgid "Eval"
msgstr "Eval"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:46
msgid "The quick 'n' dirty way to run some Ruby code from C is to `eval` it"
msgstr "ちゃちゃっと雑にCでRubyを動かすには、 `eval` します。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:50
msgid "{% highlight c %} {% include c/eval.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/eval.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:55
msgid ""
"This is a good fallback if you can't find an API function for something that "
"you want to do[^wrap]. `rb_eval_string_protect()` returns the result of the "
"Ruby code and sets `state` to some nonzero value if any exception is raised. "
"`VALUE` is the C data type for all Ruby objects, as explained in the next "
"section."
msgstr ""
"これはやりたいことのためのAPI関数が見つからないときは選択肢に入ります[^wrap]。\n"
"`rb_eval_string_protect()` はRubyのコードの結果を返し、\n"
"何か例外が発生したときはゼロではない値を `state` に設定します。\n"
"`VALUE` はあらゆるRubyのオブジェクトのためのCのデータ型です。\n"
"次の節で後述します。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:60
msgid ""
"If `state` is nonzero, `result` will be a `VALUE` representing `nil` and you "
"should handle the exception. Alternatively, you can use `rb_eval_string()` "
"which doesn't take a `state` argument and instead raises any exceptions "
"normally. See [Exceptions](#exceptions) for how to handle both of these "
"cases."
msgstr ""
"`state` がゼロではないとき、\n"
"`result` は `nil` を表す `VALUE` になっているでしょうから、\n"
"そのときは例外に対処しなければいけません。\n"
"代わりに `rb_eval_string()` を使うこともできます。\n"
"この関数は引数 `state` を取らず、通常の方法で例外を発生させます。\n"
"これら2つの場合での制御方法については[例外](#exceptions)節を参照してください。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:64
msgid ""
"Unlike `eval` in Ruby, these functions evaluate the string in an isolated "
"binding&mdash;like when you `require` something. So local variables in the "
"string will not be accessible from elsewhere and vice versa."
msgstr ""
"Rubyでの `eval` とは異なり、\n"
"これらの関数は独立の束縛状態で評価します。\n"
"ちょうど何かを `require` するときと同じです。\n"
"したがって文字列中のローカル変数は他の場所から参照できませんし、逆もまた然りです。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:69
msgid ""
"However, like using `eval` in Ruby, using these functions is not a good "
"practice. It's inefficient since the parser is invoked and it somewhat "
"defeats the point of writing in C. If you just want to call some Ruby "
"method, we'll go over a better way to do that [later on](#send)."
msgstr ""
"しかし、Rubyで `eval` するときのように、\n"
"これらの関数を使うことはあまりよくありません。\n"
"パーサが起動されなければいけないのが非効率ですし、\n"
"Cで書くことの利点が失われています。\n"
"Rubyのメソッドを呼びたいだけであれば、\n"
"もっといい方法を[後述](#send)します。"

#. type: Title ##
#: _posts/2010-01-01-c.markdown:70
#, no-wrap
msgid "VALUE"
msgstr "VALUE"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:79
msgid ""
"Before we go any further, we need to understand `VALUE`s. Due to the danger "
"of monkeying around inside the VM, the API never lets you directly access "
"Ruby's objects[^intern]. Instead, your C code will store and pass around "
"_pointers_ to Ruby objects (like how variables in Ruby contain pointers to "
"objects). These pointers can be passed to various API functions and macros "
"that will safely access and manipulate the Ruby objects. `VALUE` is the API-"
"defined C type for these pointers."
msgstr ""
"先に進む前に、\n"
"`VALUE` について理解しなければいけません。\n"
"VMの内部をめちゃくちゃにしてしまう危険があるので、\n"
"APIからは直接Rubyのオブジェクトを扱えません[^intern]。\n"
"その代わり、CのコードはRubyのオブジェクトへの _ポインタ_ を保持したり受け渡したりします（Rubyの変数がオブジェクトへのポインタを持つのと同じです）。\n"
"ポインタはさまざまなAPIの関数やマクロに渡すことができ、\n"
"そのためRubyのオブジェクトに安全にアクセスしたり操作したりできます。\n"
"`VALUE` はAPIで定義されたCの型で、このポインタを扱います。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:84
msgid ""
"Probably the most frequent question you'll have is: \"is this `VALUE` the "
"right type?\". There are a couple macros for performing this test, and both "
"take a [`T_` constant][datatypes] corresponding to the Ruby class you're "
"testing for e.g. `T_STRING`, `T_ARRAY`, etc."
msgstr ""
"おそらく最も頻繁に湧いてくる疑問は次のようなものでしょう。\n"
"「この `VALUE` は正しい型なのだろうか？」\n"
"この疑問に答えるマクロは2つあり、\n"
"そのどちらも[`T_` 定数](datatypes)を引数に取ります。\n"
"この定数は比較したい型に対応するRubyのクラスです。\n"
"例えば `T_STRING` や `T_ARRAY` などです。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:86
msgid ""
"[datatypes]: https://github.com/ruby/ruby/blob/master/doc/extension."
"rdoc#label-Data+Types"
msgstr "[datatypes]: https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-Data+Types"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:90
msgid "{% highlight c %} {% include c/checktype.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/checktype.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:96
msgid ""
"These tests work for subclasses too: if you're testing for a subclass of "
"`Array` use `T_ARRAY`, if you're testing for a subclass of `Object` use "
"`T_OBJECT`[^tdata]. That being said, these tests _do not work like `is_a?`_; "
"even though everything in Ruby `is_a? Object`, testing against `T_OBJECT` "
"will only return true for objects for which there is no better fitting "
"constant."
msgstr ""
"この検査はサブクラスでも同様にはたらきます。\n"
"`Array` のサブクラスであることを確認したいときは `T_ARRAY` を使いますし、\n"
"`Object` のサブクラスであることを確認したいときには `T_OBJECT` を使います[^tdata]。\n"
"つまり、この検査は _`is_a?` と同じではない_ ということでもあります。\n"
"Rubyのありとあらゆるものについて `is_a? Object` であるにせよ、\n"
"`T_OBJECT` に対する検査は、\n"
"他にもっと適した定数がないときにのみ真となります。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:99
msgid ""
"For certain classes, there are specialized macros that are a little more "
"efficient than the previous:"
msgstr "特定のクラスには、前述したものより少し効率的なマクロが使えます。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:103
msgid "{% highlight c %} {% include c/check_p.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/check_p.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:107
msgid ""
"If you want to handle a `VALUE` that could be one of a variety of types, the "
"previous macros can be a little clumsy. In that case you can use the "
"`TYPE()` macro to get the `T_` constant and handle your logic in a `switch`:"
msgstr ""
"いくつかの型を取りうる `VALUE` を扱いたいときは、\n"
"前述のマクロはちょっと不恰好です。\n"
"そんな場合は `TYPE()` マクロを使って `T_` 定数を取得し、\n"
"`switch` 文で制御できます。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:111
msgid "{% highlight c %} {% include c/type.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/type.h %}\n"
"{% endhighlight %}"

#. type: Title ###
#: _posts/2010-01-01-c.markdown:112
#, no-wrap
msgid "Constants"
msgstr "定数"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:121
msgid ""
"Most of the standard Ruby constants have global `VALUE`s defined for them in "
"the API so you don't need an API call to access them. Modules are prefixed "
"with `rb_m` e.g. `rb_mKernel`; classes are prefixed with `rb_c` e.g. "
"`rb_cObject`; subclasses of `Exception` are prefixed with `rb_e` e.g. "
"`rb_eRuntimeError`; and the standard IO streams are prefixed with `rb_` e.g. "
"`rb_stderr`. `nil`, `false`, and `true` are prefixed with `Q` e.g. `Qnil`."
"[^undef] As a convenience, `Qfalse` is also false in C (`0`)."
msgstr ""
"ほとんどの標準的なRubyの定数はAPIで大域的な `VALUE` が定義されています。\n"
"したがってそれらの定数を使うのにAPIの呼び出しは要りません。\n"
"モジュールは `rb_m` で前置されます。\n"
"たとえば `rb_mKernel` です。\n"
"クラスは `rb_c` で前置されます。\n"
"たとえば `rb_cObject` です。\n"
"`Exception` のサブクラスは `rb_e` で前置されます。\n"
"たとえば `rb_eRubtimeError` です。\n"
"標準的なIOストリームは `rb_` で前置されます。\n"
"たとえば `rb_stderr` です。\n"
"`nil`, `false`, `true` は `Q` で前置されます。\n"
"例えば `Qnil` です。\n"
"[^undef] 便宜上、 `Qfalse` はCの偽値 (`0`) でもあります。"

#. type: Title ###
#: _posts/2010-01-01-c.markdown:122
#, no-wrap
msgid "Translation"
msgstr "変換"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:126
msgid ""
"A few Ruby classes are analogous to C types. These classes will be your "
"primary means of transferring data between C and Ruby."
msgstr ""
"いくつかのRubyのクラスはCの型に対応します。\n"
"この対応する組み合わせは、CとRubyの間のデータのやりとりをするには一番です。"

#. type: Title ####
#: _posts/2010-01-01-c.markdown:127
#, no-wrap
msgid "Fixnum"
msgstr "Fixnum"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:133
msgid ""
"Ruby's `Fixnum` corresponds to C's `long`. The `FIX2LONG()` macro gives you "
"the `long` for a `Fixnum`. For smaller C types there's `FIX2UINT()`, "
"`FIX2INT()`, and `FIX2SHORT()`, but these will raise a `RangeError` if the "
"number wouldn't fit."
msgstr ""
"Rubyの `Fixnum` はCの `long` に対応します。\n"
"`FIX2LONG()` マクロにより、 `long` を `Fixnum` に変換できます。\n"
"より小さいCの型については、\n"
"`FIX2UINT()`, `FIX2INT()`, `FIX2SHORT()` があります。\n"
"しかし、これらのマクロは変換時に数値が大きすぎて収まらない場合は `RangeError` を生じます。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:136
msgid ""
"In the other direction, `LONG2FIX()` works for `long` **and** every smaller "
"integer C type[^chr]."
msgstr ""
"逆向きの変換もできて、\n"
"`LONG2FIX()` は `long` *に加えて* `long` より小さい全てのCの整数型からの変換に使えます。"

#. type: Title ####
#: _posts/2010-01-01-c.markdown:137
#, no-wrap
msgid "Bignum"
msgstr "Bignum"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:143
msgid ""
"Ruby's `Bignum` is for anything bigger than a `Fixnum`, so it works if you "
"need to work with `long long`, for example. `rb_big2ll()` and `rb_big2ull()` "
"will get you `long long` and `unsigned long long` from a `Bignum` (or raise "
"a `RangeError` if appropriate)."
msgstr ""
"Rubyの `Bignum` は `Fixnum` より大きいあらゆる整数に使えます。\n"
"例えば `long long` が必要なときとかです。\n"
"`rb_big2()` と `rb_big2u()` を使えば、 `Bignum` から\n"
"それぞれ `long long` や `unsigned long long` に直せます。\n"
"（もしくは `RangeError` が発生します。）"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:145 _posts/2010-01-01-c.markdown:152
msgid "See [Numeric](#numeric) for the reverse direction."
msgstr "逆向きの変換については [数値](#numeric) を参照してください。"

#. type: Title ####
#: _posts/2010-01-01-c.markdown:146
#, no-wrap
msgid "Float"
msgstr "Float"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:150
msgid ""
"Ruby's `Float` corresponds to C's `double`. The `RFLOAT_VALUE()` macro gives "
"you the `double` for a `Float`."
msgstr ""
"Rubyの `Float` はCの `double` に対応します。\n"
"`RFLOAT_VALUE()` マクロを使えば、 `Float` から `double` が得られます。"

#. type: Title ####
#: _posts/2010-01-01-c.markdown:153
#, no-wrap
msgid "Numeric"
msgstr "Numeric"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:158
msgid ""
"There are a host of \"NUM\" macros that try to be more duck-typish about "
"things.  These will convert their C types to whatever Ruby `Numeric` "
"subclass seems appropriate:"
msgstr ""
"たくさんの \"NUM\" マクロがあり、\n"
"ダックタイピングっぽい使いかたをしています。\n"
"これらのマクロはCの型を適切と思われるRubyの `Numeric` のサブクラス（のインスタンス）に変換します。"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:166
msgid "`INT2NUM()` for `int`"
msgstr "`INT2NUM()` は `int` からの変換用"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:166
msgid "`UINT2NUM()` for `unsigned int`"
msgstr "`UINT2NUM()` は `unsigned int` からの変換用"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:166
msgid "`LONG2NUM()` for `long`"
msgstr "`LONG2NUM()` は `long` からの変換用"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:166
msgid "`ULONG2NUM()` for `unsigned long`"
msgstr "`ULONG2NUM()` は `unsigned long` からの変換用"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:166
msgid "`LL2NUM()` for `long long`"
msgstr "`LL2NUM()` は `long long` からの変換用"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:166
msgid "`ULL2NUM()` for `unsigned long long`"
msgstr "`ULL2NUM()` は `unsigned long long` からの変換用"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:166
msgid "`DBL2NUM()` for `double`"
msgstr "`DBL2NUM()` は `double` からの変換用"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:171
msgid ""
"And there are macros for the opposite direction, which will try to convert "
"whatever `Numeric` to the desired C type. These will raise a `RangeError` if "
"the value wouldn't fit or `TypeError` if there is no implicit numeric "
"conversion (so you can safely pass non-`Numeric` objects)."
msgstr ""
"そして、逆方向のマクロもあります。\n"
"これらのマクロは、あらゆる `Numeric` な数値から欲しいCの型の値への変換を試みるものです。\n"
"値が範囲に収まらなかったときは `RangeError` を発生させますし、\n"
"暗黙の数値の変換ができなかったときは `TypeError` が発生します。\n"
"（なので `Numeric` ではないオブジェクトを渡しても大丈夫です。）"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
msgid "`NUM2CHR()` for `char` (works for `unsigned char` too)"
msgstr "`NUM2CHR()` は `char` からの変換用（`unsigned char` からでも変換できます）"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
msgid "`NUM2SHORT()` for `short`"
msgstr "`NUM2SHORT()` は `short` からの変換用"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
msgid "`NUM2USHORT()` for `unsigned short`"
msgstr "`NUM2USHORT()` は `unsigned short` からの変換用"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
msgid "`NUM2INT()` for `int`"
msgstr "`NUM2INT()` は `int` からの変換用"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
msgid "`NUM2UINT()` for `unsigned int`"
msgstr "`NUM2UINT()` は `unsigned int` からの変換用"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
msgid "`NUM2LONG()` for `long`"
msgstr "`NUM2LONG()` は `long` からの変換用"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
msgid "`NUM2ULONG()` for `unsigned long`"
msgstr "`NUM2ULONG()` は `unsigned long` からの変換用"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
msgid "`NUM2LL()` for `long long`"
msgstr "`NUM2LL()` は `long long` からの変換用"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
msgid "`NUM2ULL()` for `unsigned long long`"
msgstr "`NUM2ULL()` は `unsigned long long` からの変換用"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
msgid "`NUM2DBL()` for `double`"
msgstr "`NUM2DBL()` は `double` からの変換用"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:189
msgid ""
"A **major** gotcha with these is that _none_ of the macros for converting to "
"unsigned types raise an exception if you pass a negative value (surprisingly "
"this [isn't a bug][bug]). `NUM2CHR()` also has a couple quirks: it will only "
"raise a `RangeError` if the value is too big for an _int_ and when passed a "
"string it returns the numeric value of the first character rather than "
"raising a `TypeError`."
msgstr ""
"これらのマクロについて **特に** 注意すべき点は、\n"
"符号なしの型に変換に変換する *どの* マクロも、負値を渡したときに例外が発生しないということです。\n"
"（驚くべきことに[バグではありません][bug]。）\n"
"`NUM2CHR()` にはもう2つ妙なところがあります。\n"
"変換前の値が _int_ には大きすぎるときに `RangeError` のみ生じることと、\n"
"文字列を渡したときに `TypeError` を発生させず最初の文字の数値を返すということです。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:192
msgid ""
"If you know that the conversion is safe, you should prefer the macros from "
"the previous sections as they skip the range checks."
msgstr ""
"変換が安全だとわかっていれば、\n"
"前の節のマクロのほうを使うべきです。\n"
"なぜなら範囲の確認を省けるためです。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:194
msgid "[bug]: https://bugs.ruby-lang.org/issues/9089"
msgstr "[bug]: https://bugs.ruby-lang.org/issues/9089"

#. type: Title ####
#: _posts/2010-01-01-c.markdown:195
#, no-wrap
msgid "String"
msgstr "String"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:203
msgid ""
"Ruby's `String` kinda corresponds to C's `char*`. The simplest macro is "
"`StringValueCStr()` which returns a null-terminated `char*` for a `String`. "
"The problem here is that a Ruby `String` _might contain nulls_ - in which "
"case `StringValueCStr()` will raise an `ArgumentError`! Instead you can use "
"the macros `StringValuePtr()` and `RSTRING_LEN()` to get a (possibly "
"unterminated)  `char*` and the string's length as a `long`."
msgstr ""
"Rubyの `String` はだいたいCの `char*` に対応します。\n"
"もっとも簡素なマクロは `StringValueCStr()` です。\n"
"このマクロは `String` からnull終端付きの `char*` を返します。\n"
"ただしこれには問題があって、Rubyの `String` が *nullを含むかもしれません*。\n"
"そのような場合には `StringValueCStr()` は `ArgumentError` を発生させます！\n"
"その代わりに `StringValuePtr()` マクロと `RSTRING_LEN()` マクロを使えば、それぞれ\n"
"（終端が付いていない可能性がある） `char*` とその長さの `long` 値を取得できます。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:211
msgid ""
"Conversely, if you have a null-terminated `char*`, you can use "
"`rb_str_new_cstr()` to create a Ruby `String`. And if you want your `String` "
"to contain nulls, use `rb_str_new()` which takes a `char*` and the string's "
"length (as a `long`). The encodings of these strings will be `ASCII-8BIT`, "
"which is often undesirable in Ruby. You can pass the string `VALUE` to "
"`rb_str_export_locale()` to get a new `VALUE` with your locale's "
"encoding[^wchar]."
msgstr ""
"逆に、null終端付きの `char*` からRubyの `String` への変換には、\n"
"`rb_str_new_cstr()` が使えます。\n"
"そして、もし `String` にnullを含めたいときは、\n"
"`rb_str_new()` を使います。\n"
"`rb_str_new()` は `char*` と文字列の長さ（型は `long`）を引数に取ります。\n"
"これらの文字列のエンコーディングは `ASCII-8BIT` なのですが、\n"
"Ruby側のコードで望んだものではないこともあります。\n"
"そんなときは文字列の `VALUE` を `rb_str_export_locale()` に渡して、\n"
"自分のロケールのエンコーディングでの `VALUE` を取得することができます。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:218
msgid ""
"If you want to build more complex strings, you can do so using the `printf`-"
"like function `rb_sprintf()`. This accepts all of the usual conversion "
"specifiers, but also accepts an API-defined specifier `PRIsVALUE` which "
"takes a corresponding `VALUE` argument. This conversion specifier "
"substitutes a string by sending the object `to_s`. You can substitute the "
"result of `inspect` instead by adding the `+` flag."
msgstr ""
"もっと複雑な文字列を構築したければ、\n"
"`printf` のような関数 `rb_sprintf()` でできます。\n"
"この関数では通常の変換での全ての指定子だけではなく、\n"
"APIで定義された指定子 `PRIsVALUE` も使えます。\n"
"`PRIsVALUE` は対応する `VALUE` を引数に取ります。\n"
"この変換指定子はオブジェクトに `to_s` メッセージを送って文字列にに置き換えます。\n"
"`+` フラグを加えることで `inspect` を使った結果の文字列に置き換えることもできます。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:222
msgid "{% highlight c %} {% include c/printf.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/printf.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:227
msgid ""
"This custom specifier should work for any `printf`-like function in the "
"API.  `PRIsVALUE` works by hijacking the `i` conversion specifier, so when "
"printing an `int` you should use `d` to ensure that Ruby doesn't think it's "
"actually a `VALUE`."
msgstr ""
"この自前の指定子はAPIにあるあらゆる `printf` っぽい関数で使えるでしょう。\n"
"`PRIsVALUE` は `i` 変換指定子を乗っ取ることで実現されているので、\n"
"`int` を文字列にするときは `d` を使って、\n"
"Rubyに「それって実は `VALUE` なんじゃないか」と勘違いさせないようにするべきです。"

#. type: Title ####
#: _posts/2010-01-01-c.markdown:228
#, no-wrap
msgid "Symbol"
msgstr "Symbol"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:236
msgid ""
"The API defines a C type `ID` which corresponds to Ruby's `Symbol`. Just "
"like how Ruby passes around `Symbol`s as method or variable names, many API "
"calls that need a method or variable name use an `ID`. To convert between a "
"`Symbol` and an `ID` use the `SYM2ID()` and `ID2SYM()` macros. Instead of a "
"`Symbol` you may want to convert to/from a `char*` C string. To get an `ID` "
"from a `char*` use `rb_intern()` and for the reverse use `rb_id2name()`."
msgstr ""
"APIではRubyの `Symbol` に対応するCの型 `ID` が定義されています。\n"
"Rubyが `Symbol` をメソッドや変数名として受け渡しするように、\n"
"多くのAPI呼び出しでメソッドや変数の名前を `ID` を使うようにしています。\n"
"`Symbol` と `ID` を変換するには、 `SYM2ID()` と `ID2SYM()` マクロを使います。\n"
"`Symbol` ではなくCの文字列 `char*` との双方向に変換したいときもあるでしょう。\n"
"`char*` から `ID` を取得するためには `rb_intern()` を、\n"
"その逆向きでは `rb_id2name()` を使います。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:246
msgid ""
"Since many API functions require an `ID` and in many cases you will not have "
"the appropriate `ID` at hand, the API also defines a slew of functions that "
"instead take a `char*` and which do the `rb_intern()` call for you. Since "
"these functions are often more readable and the overhead of the "
"`rb_intern()` call is negligible, I have opted to use the `char*` versions "
"of the API functions wherever possible in this guide. If you find yourself "
"frequently using a certain C string in API calls, you may see some "
"performance benefit by storing the `ID` and using the `ID` versions of the "
"functions (though you'll have to look these up yourself in the Ruby headers)."
msgstr ""
"多くのAPI関数が `ID` を必要としていますが、\n"
"適切な `ID` が手元にないことも沢山あるでしょう。\n"
"そのため、代わりに `char*` を引数に取って自動で `rb_intern()` してくれる関数も沢山あります。\n"
"これらの関数はより読みやすく、 `rb_intern()` の呼び出しでのオーバーヘッドは無視できる程度なので、\n"
"この導入記事では可能な限り `char*` バージョンのAPI関数が使われる傾向にあります。\n"
"特定のCの文字列をAPIの呼出しで頻繁に使う場合は、\n"
"`ID` に変換して保管しておき、\n"
"`ID` バージョンの関数を使うことでいくらかのパフォーマンス向上を確かめられるかもしれません。\n"
"（Rubyのヘッダから自分で見つける必要がありますが。）"

#. type: Title ##
#: _posts/2010-01-01-c.markdown:247
#, no-wrap
msgid "Send"
msgstr "send"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:253
msgid ""
"This section contains API functions for directly calling Ruby methods. You "
"should prefer these functions to `rb_eval_string()` and the like whenever "
"possible. They are faster since they skip the parser and allow for some "
"compile-time checks."
msgstr ""
"この節には直接Rubyのメソッドを呼び出すAPI関数が含まれます。\n"
"`rb_eval_string()`などよりも可能なときはいつでもこれらの関数を贔屓すべきです。\n"
"これらの関数は構文解析の過程が飛ばされますしいくつかのコンパイル時検査が免除されるのでより速いのです。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:255
msgid "The easiest way to send an object a method looks like this:"
msgstr "一番簡単な方法はオブジェクトにメソッドをこのように送ることです。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:259
msgid "{% highlight c %} {% include c/funcall.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/funcall.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:261
msgid "This is roughly equivalent to the Ruby code"
msgstr "これは大雑把には次のRubyコードと同じです。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:265
msgid "{% highlight ruby %} {% include c/funcall.rb %} {% endhighlight %}"
msgstr ""
"{% highlight ruby %}\n"
"{% include c/funcall.rb %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:270
msgid ""
"The first argument is the receiver. The next is the [`ID`](#symbol) for the "
"method name. The third argument is the number of method arguments, which is "
"needed since `rb_funcall()` is a varargs function. Then come the actual "
"method arguments."
msgstr ""
"最初の引数はレシーバです。\n"
"その次はメソッド名用の[`ID`](#symbol)です。\n"
"3つ目の引数はメソッド引数の数です。\n"
"これの引数は`rb_funcall()`がvarargs関数であることから必要になります。\n"
"それから実際メソッド引数に行き着きます。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:274
msgid ""
"Alternatively, you can use `rb_funcallv()` where the fourth argument is a "
"`VALUE*` pointing to a C array of arguments. This also has the variant "
"`rb_funcallv_public()` which is like `public_send` in Ruby."
msgstr ""
"その代わりに、4つ目の引数が引数のCの配列を指す`VALUE*`であるような、`rb_funcallv()`を使うことができます。\n"
"これにもRubyでの`public_send`のような派生`rb_funcallv_public()`があります。"

#. type: Title ###
#: _posts/2010-01-01-c.markdown:275
#, no-wrap
msgid "Passing Blocks"
msgstr "ブロックを渡す"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:279
msgid ""
"If you want to pass a `Proc` as the block to a method, that's easy. The "
"function is just like `rb_funcallv()` but with the proc on the end."
msgstr ""
"`Proc`をブロックとしてメソッドに渡したければ話は早いです。\n"
"関数はほぼ`rb_funcallv()`と同じですが後ろにprocが付きます。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:283
msgid "{% highlight c %} {% include c/proc.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/proc.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:287
msgid ""
"If you don't have a proc for the block, you'll need to define a certain kind "
"of C function to represent the block. Then there's a different variant of "
"`rb_funcallv()` but with a couple extra arguments for the block:"
msgstr ""
"ブロック用のprocがなければ、ブロックを表現する何らかの類のC関数を定義する必要があります。\n"
"それから`rb_funcallv()`の異なる派生でブロック用に2つ引数が追加されたものがあります。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:291
msgid "{% highlight c %} {% include c/block.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/block.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:297
msgid ""
"The last argument to `rb_block_call()` is helpful for passing in values "
"outside the block function's scope, but in this example we don't need it "
"(thus `nil`). I also recommend against using the first argument to your "
"block function unless you're **sure** that only one value was yielded. You "
"can always get all the arguments from `argv`, so why not play it safe?"
"[^break]"
msgstr ""
"`rb_block_call()`への最後の引数はブロック関数のスコープの外側にある値を渡すのに便利ですが、この例ではその必要はありません（なので`nil`にしています）。\n"
"また、1つの値だけがyieldされることを**確信**していない限り、最初の引数を使うことはお勧めしません。\n"
"いつでも全ての引数を`argv`から手に入れられるので、危うきに近寄らずともいいじゃないですか[^break]。"

#. type: Title ##
#: _posts/2010-01-01-c.markdown:298
#, no-wrap
msgid "Builtins"
msgstr "組み込みの機能"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:305
msgid ""
"Many of Ruby's built-in classes have API functions defined for their most "
"useful methods. Using them can save you from the verbosity of always using "
"`rb_funcall()` and can provide more compile-time checks. There are far too "
"many functions to list here, so I recommend checking them out in the header "
"`ruby/intern.h`."
msgstr ""
"多くのRubyの組み込みクラスには、その中でも飛びっきり便利なメソッド用に定義されたAPI関数があります。\n"
"それらを使えば、`rb_funcall()`を使ってばかりで冗長になるのを避けられたり、より良いコンパイル時の検証がもたらされるかもしれません。\n"
"関数があまりにも多すぎて一覧にするにはここは狭すぎるので、ヘッダファイル`ruby/intern.h`を眺めることを推奨します。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:309
msgid ""
"Functions are generally named like `rb_(class)_(method)` and take at least "
"one `VALUE` argument (the receiver). E.g. `rb_ary_pop()` for `Array#pop`, "
"`rb_obj_dup()` for `Object#dup`, etc."
msgstr ""
"関数はおおよそ`rb_（クラス）_（メソッド）`のように命名されていて少なくとも1つの`VALUE`引数（レシーバ）を取ります。\n"
"例えば`rb_ary_pop()`は`Array#pop`用ですし、`rb_obj_dup()`は`Object#dup`用、といった具合です。"

#. type: Title ##
#: _posts/2010-01-01-c.markdown:310
#, no-wrap
msgid "Require"
msgstr "require"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:314
msgid ""
"The API can also load some Ruby code from a script. There's an equivalent to "
"`require`:"
msgstr ""
"APIでは何らかのRubyコードをスクリプトから読み込むこともできます。\n"
"`require`と等価なものがあります。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:318
msgid "{% highlight c %} {% include c/require.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/require.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:321
msgid ""
"As with `require`, these could raise exceptions. Read the [next section]"
"(#exceptions) for how to handle them."
msgstr ""
"`require`するときは例外が発生し得ます。\n"
"対処方法については[次節](#exceptions)を読んでください。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:323
msgid ""
"There are also functions for `load` if you want to load a script multiple "
"times:"
msgstr "スクリプトを複数回読み込みたければ`load`用の関数もあります。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:327
msgid "{% highlight c %} {% include c/load.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/load.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:331
msgid ""
"Just like [`load` in Ruby][rbload], these functions can wrap the loaded code "
"in an anonymous module to protect the global namespace. Just pass a nonzero "
"value for the second argument."
msgstr ""
"ちょうど[Rubyの`load`](rbload)と同じように、こうした関数は読み込まれたコードを匿名のモジュールに包んで大域名前空間を保護するのに使えます。\n"
"ただ非ゼロの値を2つ目の引数に渡せばよいです。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:333
msgid "[rbload]: http://www.ruby-doc.org/core/Kernel.html#method-i-load"
msgstr "[rbload]: http://www.ruby-doc.org/core/Kernel.html#method-i-load"

#. type: Title ##
#: _posts/2010-01-01-c.markdown:334
#, no-wrap
msgid "Exceptions"
msgstr "例外"

#. type: Title ###
#: _posts/2010-01-01-c.markdown:336
#, no-wrap
msgid "Raise"
msgstr "raise"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:339
msgid "To raise an exception, use:"
msgstr "例外を投げるには以下を使ってください。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:343
msgid "{% highlight c %} {% include c/raise.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/raise.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:348
msgid ""
"The first and second arguments are the exception class and message&mdash;"
"like `raise` in Ruby. The big difference is that the message is a format "
"string [just like in `rb_sprintf()`](#string), letting you more easily build "
"a useful message."
msgstr ""
"1つ目と2つ目の引数は例外クラスと文言で、Rubyの`raise`に見えます。\n"
"大きな違いは文言が（ちょうど`rb_sprintf()`のような）書式文字列である点で、役立つ文言をより簡単に構築できます。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:355
msgid ""
"You can also construct exception objects directly using `rb_exc_new_cstr`, "
"`rb_exc_new`, and `rb_exc_new_str`. All of these accept an exception class "
"as their first argument and then they work just like their [string]"
"(#string)  counterparts, constructing an exception using a null-terminated "
"string, non-null-terminated string, and a `String` object, resp. Then you "
"can raise your exception object with `rb_exc_raise`."
msgstr ""
"また`rb_exc_new_cstr`、`rb_exc_new`、`rb_exc_new_str`を直接使って例外オブジェクトを構築することもできます。\n"
"これら全ては例外クラスを1つ目の引数に受け付けて、そうしてちょうど対応する[文字列](#string)にしたがってはたらきます。\n"
"例外はそれぞれnull終端文字列、非null終端文字列、`String`オブジェクトを使って構築されます。\n"
"それから`rb_exc_raise`で例外オブジェクトを投げられます。"

#. type: Title ###
#: _posts/2010-01-01-c.markdown:356
#, no-wrap
msgid "Rescue"
msgstr "rescue"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:361
msgid ""
"There are several ways to rescue exceptions using the API. All of them "
"require the code you're protecting to be in a function that takes and "
"returns a single `VALUE`."
msgstr ""
"APIを使って例外を補足するにはいくつか方法があります。\n"
"全て保護しているコードが単一の`VALUE`を取って返す関数の中にある必要があります。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:365
msgid "{% highlight c %} {% include c/danger.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/danger.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:369
msgid ""
"Unless you wanted to rescue a function of exactly this type, you will "
"probably need to make a wrapper function in this format that runs the "
"desired code. The way to access a rescued exception is also independent of "
"the way it is rescued:"
msgstr ""
"厳密にこの型の関数を救出したいのでない限り、恐らくこの形式で所望のコードを走らせる梱包関数を作る必要があるでしょう。\n"
"救出された例外にアクセスする方法もまた救出される方法とは独立です。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:373
msgid "{% highlight c %} {% include c/handle.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/handle.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:378
msgid ""
"`rb_errinfo()` essentially gives you the `VALUE` of Ruby's `$!` (which will "
"be `Qnil` if no exception occurred). Unlike in Ruby, you must manually clear "
"the exception after reading it[^clear]. Otherwise later API calls might read "
"the old value and think another exception has occurred."
msgstr ""
"`rb_errinfo()`は欠かせないRubyの`$!`（1つも例外が起こらなければ`Qnil`になります）の`VALUE`を与えます。\n"
"Rubyとは異なり読んだ後で例外を手動で消し去らなければなりません[^clear]。\n"
"さもなくばその後のAPI呼び出しが古い値を読んで別の例外が起こったと考えるかもしれません。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:382
msgid ""
"Next we will go over several methods of rescuing; you can use whichever you "
"like, but I think that generally the right choice is determined by your [use-"
"case](#the-two-paths) of the API."
msgstr ""
"次に救出のいくつかの方法を眺めていきます。\n"
"どれでも好きなものを使ってよいですが、一般的には正しい選択はAPIの[用途](#the-two-paths)により決定されると考えています。"

#. type: Title ####
#: _posts/2010-01-01-c.markdown:383
#, no-wrap
msgid "rb_rescue2"
msgstr "rb_rescue2"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:389
msgid ""
"If you're compiling a library to be loaded by Ruby, you have it easy. Any "
"exceptions raised in the API can be rescued as usual in your Ruby code. If "
"you want to rescue an exception in the API, you can use `rb_rescue2()` which "
"is similar to Ruby's `rescue`."
msgstr ""
"Rubyによって読み込まれるライブラリをコンパイルしている場合、話は簡単です。\n"
"APIで投げられるいかなる例外もいつも通りRubyのコードで救出できます。\n"
"APIで例外を救出したければRubyの`rescue`と似ている`rb_rescue2()`を使うことができます。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:393
msgid "{% highlight c %} {% include c/rescue2.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/rescue2.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:402
msgid ""
"The first two arguments are the function to protect and its argument, the "
"next two are the function to call if an exception is raised and its "
"argument.  `rb_rescue2()` is a varargs function, so after that comes a list "
"of the exception classes you want to rescue. The last argument should always "
"be `0` to indicate the end of the class list. Like `rescue` in Ruby, any "
"exceptions not in this list will not be rescued. If you just want to rescue "
"`StandardError` (like a blank `rescue` in Ruby), you can use `rb_rescue()` "
"which takes just the first four arguments of `rb_rescue2()`."
msgstr ""
"始めから2つの引数は保護する関数とその引数です。\n"
"その次の2つは例外が投げられた場合に呼ばれる関数とその引数です。\n"
"`rb_rescue2()`はvarargs関数なのでその後には救出したい例外クラスのリストが来ます。\n"
"最後の引数は常に`0`でクラスのリストの末尾を示します。\n"
"Rubyの`rescue`のようにこのリストにないどんな例外も救出されることはありません。\n"
"もし（Rubyでの空の`rescue`のように）`StandardError`を救出したいだけなら、`rb_rescue2()`の最初の4つの引数だけを取る`rb_rescue()`を使うことができます。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:406
msgid ""
"The API does not provide an easy way to run different rescue code for "
"different exception classes as Ruby does. You'll need to rescue all the "
"classes you want at once and use some kind of switch to handle them "
"separately."
msgstr ""
"APIはRubyとは違ってそれぞれの例外クラス用に救出コードを走らせる簡単な方法を提供していません。\n"
"一度に欲しい全てのクラスを救出してswitchの類を使って個別に取り扱う必要があります。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:413
msgid ""
"The API also does not directly provide an equivalent to Ruby's `else` i.e. "
"code to run when _no_ exception was raised. One way to do this is using the "
"return value of `rb_rescue2()`. If no exception is raised, it returns the "
"return value of the first (dangerous) function, otherwise the return value "
"of the second (rescue) function. By having these return, say, `Qtrue` and "
"`Qfalse` you can detect which case you are in."
msgstr ""
"またAPIはRubyの`else`と等価なもの、つまり _何らの_ 例外も投げられなかったときに走るコード、を直接は提供していません。\n"
"これをする1つの方法は`rb_rescue2()`の返り値を使うことです。\n"
"もし1つも例外が投げられなければ最初の（危険な）関数の返り値を、さもなくば2つ目の（救出）関数の返り値を返します。\n"
"これらが返すもの、ここでは`Qtrue`と`Qfalse`としましょう、を受け取ることによって、どちらの場合にあるのかを検出できます。"

#. type: Title ####
#: _posts/2010-01-01-c.markdown:414
#, no-wrap
msgid "rb_protect"
msgstr "rb_protect"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:421
msgid ""
"If you're embedding the Ruby interpreter in C, you need to be _extremely "
"careful_ when calling API functions that could raise exceptions: **an "
"uncaught exception will segfault the VM and kill your program**. You could "
"call `rb_rescue2()` with `rb_eException`, but there's another approach for "
"rescuing all exceptions:"
msgstr ""
"RubyインタプリタをCに埋め込みたい場合、例外を投げ得るAPI関数を呼ぶときは _極めて慎重_ にならねばなりません。\n"
"**捕捉されない例外はVMをセグフォルトさせてプログラムをキルする**のです。\n"
"`rb_eException`と共に`rb_rescue2()`を呼ぶようにできますが、全ての例外を救出する別の手法があります。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:425
msgid "{% highlight c %} {% include c/protect.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/protect.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:431
msgid ""
"Like `rb_rescue2()`, the first two arguments are for calling the function to "
"protect. However, like `rb_eval_string_protect()`, if an exception is raised "
"it returns `Qnil` and sets `state` to some nonzero value. If you want to re-"
"raise the exception, pass `state` to `rb_jump_tag()` (this also works for "
"the state from the other `*_protect()` functions)."
msgstr ""
"`rb_rescue2()`と同様、最初2つの引数は保護する関数を呼び出すためのものです。\n"
"しかし、`rb_eval_string_protect()`のように、例外が投げられれば`Qnil`を返し`state`を非ゼロの値に設定します。\n"
"例外を再度投げたければ`state`を`rb_jump_tag()`に渡してください（これは他の`*_protect()`関数からの状態についても動作します）。"

#. type: Title ###
#: _posts/2010-01-01-c.markdown:432
#, no-wrap
msgid "Ensure"
msgstr "ensure"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:439
msgid ""
"`rb_ensure()` is similar to `rb_rescue()` except that it doesn't do anything "
"about exceptions and the second function is _always_ called after the "
"first.  That may sound simple enough, but that means that if you want the "
"usual `begin; rescue; ensure; end` structure as in Ruby, you'll need another "
"layer of wrapping:"
msgstr ""
"`rb_ensure()`は`rb_rescue()`に似ていますが例外を関知しないことと2つ目の関数が _常に_ 1つ目のものの後に呼ばれる点が例外です。\n"
"充分に単純に思われるかもしれませんが、これが意味しているのは、もしRubyでするような通常の`begin; rescue; end`の構造が欲しければ、梱包に別の層が必要になってくるということです。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:443
msgid "{% highlight c %} {% include c/ensure.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/ensure.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:448
msgid ""
"Like `ensure` in Ruby, the return value of `ensure_func()` is never used. If "
"no exception occurs, `rb_rescue()` will return the value of `begin_func()` "
"which returns the value of `dangerous_func()`. If an exception does occur, "
"`rb_rescue()` returns the value of `rescue_func()`."
msgstr ""
"Rubyでの`ensure`のように、`ensure_func()`の返り値は決して使われません。\n"
"何も例外が起きなければ`rb_rescue()`は`begin_func()`の値を返します。\n"
"ここで`begin_func()`は`dangerous_func()`の値を返します。\n"
"もし例外が発生したら`rb_rescue()`は`rescue_func()`の値を返します。"

#. type: Title ##
#: _posts/2010-01-01-c.markdown:449
#, no-wrap
msgid "Definitions, Declarations"
msgstr "定義、宣言"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:454
msgid ""
"So far we've been creating and modifying objects directly in the VM's "
"memory, but none of our API calls have had a visible effect _within the Ruby "
"code_: a `String` made with `rb_str_new_cstr()` can only be accessed from C "
"by default."
msgstr ""
"ここまでVMのメモリ内で直接オブジェクトを作ったり変更したりしてきましたが、どのAPI呼び出しも _Rubyのコードの内部_ での目に見える効果はありませんでした。\n"
"`rb_str_new_cstr()`で作られた`String`は、既定ではCからのみアクセスできます。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:463
msgid ""
"There are a few ways to make things visible to Ruby but they all work the "
"same general way: by defining some name that Ruby can access e.g. a variable "
"name, a method name, etc. A general warning though: unlike Ruby, **the API "
"lets you give things invalid names**. Ruby will raise a `SyntaxError` or "
"`NameError` if you try to name a class `foo` (not constant) or an instance "
"variable `bar` (no `@`), but the API will happily create them. The API "
"handles this by **not exposing invalid names to Ruby**. Since that's "
"probably not what you want, double check the names you choose!"
msgstr ""
"Rubyから見えるようにするにはいくつかの方法がありますが、全て同じ汎用的な仕組みではたらきます。\n"
"その共通するところはRubyがアクセスできる何らかの名前を定義するという点です。\n"
"例えば変数名やメソッド名などなどです。\n"
"しかし注意を呼び掛けておきましょう。\n"
"Rubyとは違い、**APIでは不正な名前を与えることができます**。\n"
"クラスに`foo`（定数でない）やインスタンス変数に`bar`（`@`がない）を名付けようとするとRubyは`SyntaxError`や`NameError`を投げるでしょうが、APIは嬉々としてそうした名前で作ります。\n"
"APIはこれを **不正な名前をRubyにさらけ出さない** ようにして扱います。\n"
"恐らくそれはしたいことではないので、選ぶ名前は二重確認してくださいね。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:469
msgid ""
"Most of the API functions in this section correspond closely to "
"metaprogramming methods in Ruby. When you're trying to do something using "
"the API, it can be helpful to think about how you would do it in Ruby using "
"only metaprogramming method calls. For example, rather than `class Foo; def "
"bar; end; end`, think `Foo = Class.new; Foo.define_method(:bar) {}`."
msgstr ""
"この節のほとんどのAPI関数はRubyのメタプログラミングに近いです。\n"
"APIを使って何かしようとするときは、Rubyでメタプログラミングのメソッド呼び出しだけを使ってするとしたらどうするだろうと考えると役立つことがあります。\n"
"例えば`class Foo; def bar; end`とするより、`Foo = Class.new; Foo.define_method(:bar) {}`と考えるのです。"

#. type: Title ###
#: _posts/2010-01-01-c.markdown:470
#, no-wrap
msgid "Global Variables"
msgstr "大域変数"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:473
msgid "The simplest way to deal with globals is:"
msgstr "大域変数を扱う一番簡単な方法は以下です。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:477
msgid "{% highlight c %} {% include c/global.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/global.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:480
msgid ""
"If you're frequently accessing Ruby's globals, you can set up a `VALUE` "
"which will be automatically synchronized with one."
msgstr "Rubyの大域変数に頻繁にアクセスするときは`VALUE`を準備しておけば自動的に同期が取られます。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:484
msgid "{% highlight c %} {% include c/global2.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/global2.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:491
msgid ""
"The `VALUE` should be initialized before you create the global in Ruby and "
"it should be global in C as well&mdash;you don't want it to go out of scope "
"while Ruby is using it! For `rb_define_hooked_variable()`, you can pass "
"`NULL` for the getter/setter if you want to synchronize normally for that "
"operation. Or you can throw out `global` entirely with "
"`rb_define_virtual_variable()` though of course the getter and setter _must_ "
"be defined in that case."
msgstr ""
"`VALUE`はRubyで大域変数を作る前に初期化するべきで、そうしておけばCでも大域変数になります。\n"
"Rubyが使っている間はスコープを外れてほしくはないですからね。\n"
"`rb_define_hooked_variable()`にすると、そうした操作で通常の同期をしたい場合にゲッターやセッターに`NULL`を渡すことができます。\n"
"もしくは`rb_define_virtual_variable()`では完全に`global`を投げ出すこともできますが、もちろんゲッターとセッターはそうした場合で定義されている _必要_ があります。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:495
msgid ""
"If you ever create a global `VALUE` in C which is _not_ exposed to Ruby, you "
"must tell the garbage collector about it to prevent it from being "
"prematurely cleaned up:"
msgstr "Rubyに露出 _しない_ 大域変数`VALUE`をCで作ったならば、中途半端に掃除されてしまうのを防ぐためにガベージコレクタにそのことを伝えなければなりません。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:499
msgid "{% highlight c %} {% include c/gc.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/gc.h %}\n"
"{% endhighlight %}"

#. type: Title ###
#: _posts/2010-01-01-c.markdown:500
#, no-wrap
msgid "Class and Instance Variables"
msgstr "クラスとインスタンス変数"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:504
msgid ""
"Getting/setting instance variables is similar to the simple way of accessing "
"globals, but of course you need an object to get the variable from."
msgstr "インスタンス変数の取得と設定は大域変数にアクセスする単純な方法と似ていますが、もちろん変数を取得してくるオブジェクトが必要です。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:508
msgid "{% highlight c %} {% include c/ivar.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/ivar.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:511
msgid ""
"There isn't an automatic way to synchronize instance variables like you can "
"with globals."
msgstr "大域変数でしたようにインスタンス変数を同期する自動化された方法はありません。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:513
msgid "To iterate over all instance variables, use `rb_ivar_foreach`."
msgstr "全てのインスタンス変数を巡回するには`rb_ivar_foreach`を使ってください。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:516
msgid ""
"For class variables, the methods are `rb_cv_get()` and `rb_cv_set()` and of "
"course the first argument should be a class object."
msgstr "クラス変数については、メソッドは`rb_cv_get()`と`rb_cv_set()`がありもちろん最初の引数はクラスオブジェクトです。"

#. type: Title ###
#: _posts/2010-01-01-c.markdown:517
#, no-wrap
msgid "Constants ####"
msgstr "定数"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:520
msgid ""
"Constants are defined similarly, but with the module to define them under:"
msgstr "定数は似たように定義されていますが、それらを配下に置くためのモジュールを伴います。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:524
msgid "{% highlight c %} {% include c/constant.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/constant.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:528
msgid ""
"You undefine a constant by setting it to `Qundef`. Getting a constant's "
"`VALUE` is a little nuanced. The API function you call depends on what you "
"want to happen if the constant is _not_ defined in the module you specify:"
msgstr ""
"`Qundef`を設定すると定数は未定義にされます。\n"
"定数の`VALUE`の取得は微妙に違ってきます。\n"
"呼び出すべきAPI関数は、定数が指定されたモジュールで定義されて _いない_ ときに何が起こってほしいのかに依ります。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:532
msgid "{% highlight c %} {% include c/const_get.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/const_get.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:534
msgid "All of these API calls will get private constants too."
msgstr "これら全てのAPIはプライベート定数も取得します。"

#. type: Title ###
#: _posts/2010-01-01-c.markdown:535
#, no-wrap
msgid "Modules and Classes"
msgstr "モジュールとクラス"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:538
msgid "Defining modules is super easy."
msgstr "モジュールの定義は超簡単です。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:542
msgid "{% highlight c %} {% include c/module.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/module.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:544
msgid "Classes work the same way but they also need a superclass."
msgstr "クラスは同じやり方ですがスーパークラスも必要です。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:548
msgid "{% highlight c %} {% include c/class.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/class.h %}\n"
"{% endhighlight %}"

#. type: Title ###
#: _posts/2010-01-01-c.markdown:549
#, no-wrap
msgid "Methods"
msgstr "メソッド"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:555
msgid ""
"Here's where it gets interesting. There are many kinds of API calls for "
"defining methods, but before you use any of them you'll need a C function "
"that the method calls. The function must return a `VALUE` and have one "
"`VALUE` argument for the receiver of the method. There are three ways you "
"can define its other arguments:"
msgstr "ここから面白くなってきます。メソッド定義のためのAPI呼び出しには多くの種類がありますが、どれかを使う前にそのメソッドを呼び出すC関数が必要です。その関数は`VALUE`を返しメソッドのレシーバ用の`VALUE`引数を1つ持たねばなりません。他の引数を定義するのには3つの方法があります。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:559
msgid "{% highlight c %} {% include c/methodc.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/methodc.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:564
msgid ""
"So really the API only lets you define two types of methods: ones that take "
"a fixed number of arguments, and ones that slurp up all of their arguments. "
"What about all of Ruby's fancy argument features? Where are optional "
"arguments, options hashes, blocks, and all the mixtures of those?"
msgstr "なので本当のところAPIでは2つの種類のメソッドのみが定義できるのです。且つは固定数の引数を取り、且つは全ての引数を一飲みします。Rubyの素敵な引数の機能はどうなったのでしょうか。オプション引数、オプションハッシュ、ブロック、これらの混在はどこにあるのでしょうか。"

#. type: Title ####
#: _posts/2010-01-01-c.markdown:565
#, no-wrap
msgid "Parsing Arguments"
msgstr "引数を解析する"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:572
msgid ""
"Well, if you accept a variable number of arguments you could code all of "
"that logic yourself in the method, and make it _behave_ like it has a "
"fancier method definition in Ruby. Thankfully, the API has a shortcut for "
"doing exactly that.  To use it, you should use the C array function "
"definition, then you can pass `argc` and `argv` along to:"
msgstr "さて、様々な個数の引数を受け付ける場合は全ての仕組みをメソッドで自力でコードにすることができ、Rubyで凝ったメソッド定義したような感じで _振る舞う_ ようにできます。ありがたいことにAPIにはちょうどそういうことをするための早道があります。それを使うにはC配列関数の定義を使うとよく、それから`argc`と`argv`を以下の流れに沿って渡すことができます。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:576
msgid "{% highlight c %} {% include c/scan.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/scan.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:581
msgid ""
"Here `fmt` is a format string describing how the method arguments would look "
"in Ruby. The string can have at most 6 characters, where each character "
"describes a different section of the arguments. The six sections and their "
"corresponding characters are (in order):"
msgstr "ここで`fmt`はメソッド引数がRubyでどのような見た目をしているのかを記述する書式文字列です。文字列は最大6個の文字を持つことができ、そこではそれぞれの文字はそれぞれ異なる節の引数を記述するのです。6つの節と（順番通りに）対応する文字は以下の通りです。"

#. type: Bullet: '1. '
#: _posts/2010-01-01-c.markdown:588
msgid "The number of leading mandatory arguments: a digit"
msgstr "先頭にある必須引数の数：数字"

#. type: Bullet: '2. '
#: _posts/2010-01-01-c.markdown:588
msgid "The number of optional arguments: a digit"
msgstr "オプション引数の数：数字"

#. type: Bullet: '3. '
#: _posts/2010-01-01-c.markdown:588
msgid "A splatted argument: `*`"
msgstr "展開される引数：`*`"

#. type: Bullet: '4. '
#: _posts/2010-01-01-c.markdown:588
msgid "The number of trailing mandatory arguments: a digit"
msgstr "後ろに続く必須引数の数：数字"

#. type: Bullet: '5. '
#: _posts/2010-01-01-c.markdown:588
msgid "Keyword arguments: `:`"
msgstr "キーワード引数：`:`"

#. type: Bullet: '6. '
#: _posts/2010-01-01-c.markdown:588
msgid "A block argument: `&`"
msgstr "ブロック引数：`&`"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:598
msgid ""
"Each section is optional, so you can leave out the characters for things you "
"don't need. Be aware that the parsing of the format string is greedy: `1*` "
"describes a method with one mandatory argument and a splat. If you want one "
"_optional_ argument and a splat you must specify `01*`. Following the format "
"string, you must pass a `VALUE*` for each _Ruby_ argument. The number of "
"pointers passed should equal the \"total\" of the six sections, though you "
"can pass `NULL` for an argument you don't care about. For example the format "
"string `21*&` should have 5 `VALUE*`s passed (2 mandatory, 1 optional, 1 "
"splatted, 1 block)."
msgstr "それぞれの節は省略できるので、必要ではないものについてはそのための文字を空けたままにできます。書式文字列の解析は貪欲に行われる点に注意してください。`1*`は必須引数と展開を持つメソッドを示しています。1つの _オプション_ 引数と展開であってほしければ`01*`と指定せねばなりません。書式文字列にしたがってそれぞれの _Ruby_ の引数用に`VALUE*`を渡さなければなりません。渡されるポインタの数は6つの節の「合計」に等しいのですが、関心のない引数については`NULL`を渡すことができます。例えば書式文字列`21*&`には5つの`VALUE*`が渡されなければなりません（2つの必須引数、1つのオプション引数、1つの展開、1つのブロックです）。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:601
msgid ""
"`rb_scan_args()` unpacks `argv` using the `VALUE*`s you pass it and will "
"raise a fitting exception if the wrong number of arguments were passed."
msgstr "`rb_scan_args()`は渡した`VALUE*`を使って`argv`を開封し、もし誤った数の引数が渡されたときは符牒が合わない旨の例外を投げます。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:605
msgid "{% highlight c %} {% include c/methodex.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/methodex.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:609
msgid ""
"You can also use the return value of `rb_scan_args()` to determine how the "
"function was called. It returns the number of arguments that were passed in "
"Ruby."
msgstr "`rb_scan_args()`の返り値を使って関数がどう呼ばれたのかを確定することもできます。そうすることでRubyで渡された引数の数が返ります。"

#. type: Title ####
#: _posts/2010-01-01-c.markdown:610
#, no-wrap
msgid "Handling Blocks"
msgstr "ブロックの扱い"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:613
msgid ""
"There are two ways to check if your C method has been called with a block:"
msgstr "Cのメソッドがブロック付きで呼ばれたかどうかを確認する方法は2つあります。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:617
msgid "{% highlight c %} {% include c/checkblock.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/checkblock.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:622
msgid ""
"There are two ways to capture the block as a proc. If you're using "
"`rb_scan_args()` for your method arguments, just include `&` in your format "
"string to get it. If you aren't using `rb_scan_args()`, there's an API call "
"equivalent to `Proc.new` which converts the method's block to a proc:"
msgstr "Procとしてブロックを捕捉する方法は2つあります。メソッド引数に`rb_scan_args()`を使っている場合、書式文字列に`&`を含めるだけで取得できます。`rb_scan_args()`を使っていなければメソッドのブロックをProcに変換する`Proc.new`と等価なAPI呼び出しがあります。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:625
#, no-wrap
msgid ""
"    VALUE block;\n"
"    block = rb_block_proc();\n"
msgstr ""
"    VALUE block;\n"
"    block = rb_block_proc();\n"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:627
msgid ""
"If you don't want to capture the block, there are a few ways to yield to it:"
msgstr "ブロックを捉えたくなければyieldする方法が2つあります。"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:631
msgid "{% highlight c %} {% include c/yield.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/yield.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:634
msgid ""
"There's also `rb_yield_values2()` which is like `rb_yield_values()` but "
"instead of varargs the second argument is a `VALUE*`[^yield]."
msgstr "`rb_yield_values()`のような`rb_yield_values2()`もあり、varargs`の代わりに2つ目の引数が`VALUE*`になっています[^yield]。"

#. type: Title ####
#: _posts/2010-01-01-c.markdown:635
#, no-wrap
msgid "Super"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:638
msgid "You might want to call `super` in your method."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:642
msgid "{% highlight c %} {% include c/super.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/super.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:648
msgid ""
"Unlike in Ruby `rb_call_super()` will **not** implicitly pass along the "
"method arguments to the super if you give it no arguments. You must "
"explicitly pass the correct `argc` and `argv` (it _does_ automatically pass "
"`self`). For that reason I recommend using the C array style of method "
"definition if you want to use `rb_call_super()`."
msgstr ""

#. type: Title ####
#: _posts/2010-01-01-c.markdown:649
#, no-wrap
msgid "Definition"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:655
msgid ""
"Setting up the C function is the hard part, now it's easy to define the "
"method in Ruby. Every API call to create a method takes at least the method "
"name (`char*`), a pointer to your C function, and an `argc` describing its "
"arguments.  `argc` should be:"
msgstr ""

#. type: Bullet: '1. '
#: _posts/2010-01-01-c.markdown:660
msgid ""
"For a fixed number of arguments, the number of arguments (not counting the "
"receiver)"
msgstr ""

#. type: Bullet: '2. '
#: _posts/2010-01-01-c.markdown:660
msgid "For a variable number of arguments in a C array, `-1`"
msgstr ""

#. type: Bullet: '3. '
#: _posts/2010-01-01-c.markdown:660
msgid "For a variable number of arguments in a Ruby Array, `-2`"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:662
msgid "Everything is pretty self-explanatory from there:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:666
msgid "{% highlight c %} {% include c/methodr.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/methodr.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:670
msgid ""
"There's also a shortcut for defining a method in a module _and_ its "
"singleton class. This is used a lot in `Math`, for example, letting you "
"`include Math` to avoid typing `Math.` before every method call."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:674
msgid "{% highlight c %} {% include c/modulefunc.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/modulefunc.h %}\n"
"{% endhighlight %}"

#. type: Title ###
#: _posts/2010-01-01-c.markdown:675
#, no-wrap
msgid "Other Stuff"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:678
msgid "Some simple API functions for class/method definitions:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:682
msgid "{% highlight c %} {% include c/etc.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/etc.h %}\n"
"{% endhighlight %}"

#. type: Title ##
#: _posts/2010-01-01-c.markdown:683
#, no-wrap
msgid "Data"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:690
msgid ""
"By now you should be able to create and manipulate Ruby classes using the "
"API, but how can you create a Ruby class that encapsulates data from the C "
"world? If your data can be naturally translated into `VALUE`s it's easy: "
"convert and assign to instance variables as usual. But what if your data "
"have no Ruby analog (e.g. data structures defined by some C library)?"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:697
msgid ""
"The API lets you encapsulate C data by creating a `VALUE` of the desired "
"class and then storing a `void*` pointing to the C data inside the Ruby "
"object. Then whenever you need access to the C data, you can unpack the "
"pointer and cast it back to the correct type. But where does this "
"encapsulation occur? Let's answer that question with a question: what "
"happens when you tell Ruby to create an object using `new`? Basically this:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:701
msgid "{% highlight ruby %} {% include c/new.rb %} {% endhighlight %}"
msgstr ""
"{% highlight ruby %}\n"
"{% include c/new.rb %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:707
msgid ""
"Before calling the _instance method_ `initialize` that we know so well, "
"`new` first calls the _class method_ `allocate` to actually create the "
"object. That is the method you'll need to define if you want your objects to "
"wrap C data. The following example creates a class `Foo` which wraps an "
"`int` that can be set by `initialize`:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:711
msgid "{% highlight c %} {% include c/wrap.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/wrap.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:719
msgid ""
"In most cases you'll probably be wrapping something more complicated (like a "
"`struct`), but the principles will be the same. After allocating the C data, "
"we use the `TypedData_Wrap_Struct()`[^oldwrap] macro to wrap the pointer in "
"a `VALUE`. This wrapping takes three arguments: the class of the object "
"(`self` because we're in a class method), a pointer to a struct, and the "
"data pointer to be wrapped. The tricky part is the struct pointer; it "
"provides additional information for internal use by Ruby:"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:736
msgid ""
"`wrap_struct_name` is a string used by Ruby to identify your type. It "
"doesn't really matter what it is as long as it's sensible and unique"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:736
msgid ""
"`function` is a struct containing several function pointers for use by the "
"garbage collector"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:736
msgid ""
"`dmark` will be described later, but as long your C data doesn't point to "
"any Ruby objects you don't need it"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:736
msgid ""
"`dfree` will be called when your object is destroyed and should free all "
"memory allocated by the object"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:736
msgid ""
"`dsize` is called by Ruby to check how much memory your object is taking "
"up.  It _can_ be omitted, but it's polite to include it"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:736
msgid ""
"`data` can point to arbitrary data. Think of it as wrapping C data at a "
"class level. Also not manadatory"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:736
msgid ""
"`flags` lets you enable additional optimizations when your objects are "
"garbage collected. As long as your `dfree` function doesn't unlock the [GVL]"
"(#c-in-ruby-threads) (why would you do that???) you can safely set it to "
"`RUBY_TYPED_FREE_IMMEDIATELY` for a slight performance improvement"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:741
msgid ""
"If you don't set some of these members, you should zero them out so that "
"Ruby doesn't accidentally read garbage data. That's why I used C99's "
"[designated initializer][desinit] syntax in the example above: any members "
"you omit will be safely cleared by the compiler."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:743
msgid "[desinit]: https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:747
msgid ""
"`VALUE`s that wrap C data will have type `T_DATA` with respect to the "
"[`TYPE()` macro](#value). This helps ensure a clear separation between "
"native Ruby objects and those wrapping C data."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:752
msgid ""
"Once you've done all of that work to wrap up the C data, getting it back out "
"is easy: `TypedData_Get_Struct()` takes the object to unwrap, the C type of "
"the underlying data, the same struct pointer as before, and the pointer to "
"assign the data to."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:758
msgid ""
"This separation of allocation and initialization doesn't jive with [RAII]"
"[raii], so if you're using C++ you will probably want to use [placement new]"
"[place] when wrapping data. If you're having trouble splitting up allocation "
"and initialization, you can just wrap your data in a `struct` and do the "
"_actual_ allocation in `initialize`."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:761
msgid ""
"[raii]: http://wikipedia.org/wiki/Resource_Acquisition_Is_Initialization "
"[place]: http://en.cppreference.com/w/cpp/language/new#Allocation"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:769
msgid ""
"In simple cases (like the previous example) you can make your code a little "
"less verbose. If the function to free your data just calls `free()` as in "
"the example, you can pass `RUBY_DEFAULT_FREE` for `dfree` and Ruby will free "
"it for you (**don't** use `NULL` unless you like memory leaks). Similarly, "
"if your allocation is just a `malloc()` as in the example, the macro "
"`TypedData_Make_Struct()` does the allocation for you _and_ wraps it. We "
"could shorten the previous example as such:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:773
msgid "{% highlight c %} {% include c/makestruct.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/makestruct.h %}\n"
"{% endhighlight %}"

#. type: Title ###
#: _posts/2010-01-01-c.markdown:774
#, no-wrap
msgid "Marking"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:783
msgid ""
"That `dmark` pointer in the type structure above is the pointer to your "
"object's \"mark function\". This is so named because of the garbage "
"collector's \"mark and sweep\" algorithm. The basic idea behind mark and "
"sweep is that when the garbage collector needs to free up memory, it "
"performs two passes: the first (mark) pass iterates through every "
"_referenced_ Ruby object and marks it as active, then the second (sweep) "
"pass iterates through every _allocated_ Ruby object and frees the ones that "
"haven't been marked active."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:793
msgid ""
"This is relevant to wrapping C data because it's possible that you might "
"wrap a C `struct` which contains a Ruby `VALUE`&mdash;which the garbage "
"collector is responsible for cleaning up. Since the garbage collector is "
"only aware of `VALUE`s referenced _by Ruby_ (not by C pointers), it won't be "
"able to mark the referenced `VALUE` as active. The result is that as soon as "
"the garbage collector needs to free up some memory, your C data is going to "
"end up with a reference to a nonexistent Ruby object. Note that this kind of "
"wrapping of Ruby data inside C data is a really bad idea, precisely because "
"of this kind of issue. But if you really must..."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:797
msgid ""
"In the following example, we'll wrap a C `struct` which contains a `VALUE`. "
"The mark function has the same signature as the free function and all it has "
"to do is mark any `VALUE`s in the `struct`:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:801
msgid "{% highlight c %} {% include c/mark.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/mark.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:806
msgid ""
"If your `struct` contains a pointer to a C array of `VALUE`s, you can "
"instead use `rb_gc_mark_locations()` which takes two arguments: the pointers "
"to the start and end of the array (the end being equal to the starting "
"pointer plus the array length).[^maybe]"
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:807
#, no-wrap
msgid "Threading"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:809
#, no-wrap
msgid "Ruby in C Threads"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:819
msgid ""
"If you're making a lot of API calls and running a lot of Ruby code from C, "
"at some point you might catch yourself thinking, \"I'm running all of these "
"slow Ruby methods using the API. Maybe I can thread things to keep my code "
"fast!\" That's a reasonable thought, but when you act on it keep in mind "
"that **the Ruby VM is not at all thread safe**. Ideally, all of your API "
"code should run in a single thread. If not, you'll probably need to wrap "
"every API call with a locked mutex to make sure that you never ever have "
"multiple threads interacting with the API at the same time."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:822
msgid ""
"If you just want to create normal Ruby `Thread`s using the API (and don't "
"mind the GVL, as described in the next section), there's an easy way to do "
"that:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:826
msgid "{% highlight c %} {% include c/thread.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/thread.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:829
msgid ""
"Other `Thread` functions are in `ruby/intern.h` (but there's always "
"`rb_funcall()` for everything else)."
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:830
#, no-wrap
msgid "C in Ruby Threads"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:838
msgid ""
"On the other hand, if you expose some heavy C code to Ruby with the API (if "
"you're writing an extension that wraps a C library, for example), you should "
"spend some time thinking about a nasty thing called the global VM lock "
"(GVL).  Because most of the API is not `Thread` safe, the GVL locks down "
"almost all Ruby code so that only a single `Thread` can run at a time. This "
"is the reason why you'll often hear people say that `Thread` does not allow "
"true parallelism."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:850
msgid ""
"The VM also applies the GVL to any C code you expose to Ruby. That's why you "
"can use the API without worrying about it exploding when someone calls your "
"C code from inside a `Thread`. The downside of this is that if your C code "
"takes a while to run, you won't see any performance benefit from calling it "
"in a `Thread` because **it will block all other threads** while it runs. But "
"the GVL is only needed to protect API calls. If you have some C code that "
"doesn't use the API, you can tell the VM to release the GVL before running "
"your code in a thread and to reacquire it when it completes, allowing for "
"true parallelism.  Locking and unlocking the GVL does carry a performance "
"hit, so only resort to this if you notice that you're having significant "
"problems due to blocked threads."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:854
msgid ""
"The code to do this is considered so fancy by the Ruby developers that you "
"actually need to include another header to use it. First we'll look at the "
"slightly simpler way to release the GVL:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:858
msgid "{% highlight c %} {% include c/gvl2.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/gvl2.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:861
msgid ""
"Since the function that is run without the GVL gets and returns data using "
"`void*`, you may want to define a `struct` for passing data via pointers."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:866
msgid ""
"If you unlock the GVL as above you will find that while your code does run "
"in parallel, it can't be interrupted (by signals, `Thread.kill`, etc.)! To "
"allow for that you must pass an unblocking function using the last two "
"arguments:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:870
msgid "{% highlight c %} {% include c/gvl.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/gvl.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:875
msgid ""
"The unblocking function is called in the event of an interrupt. To make it "
"work, you will probably need to pass a pointer to both functions that can be "
"used to communicate an interrupt from one to the other. The interrupted "
"function should perform any necessary cleanup before returning early."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:880
msgid ""
"Alternatively, if the interrupted function doesn't _need_ to perform any "
"special cleanup, you can use the built in unblocking function "
"`RUBY_UBF_IO`[^ubf] (which ignores the unblocking argument). That simply "
"forwards the interrupt to the running thread.[^int]"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:884
msgid ""
"If you go through all of that effort to release the GVL only to find that "
"you need to make an API call in your unlocked thread, there's a function to "
"temporarily reacquire the GVL:"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:888
msgid "{% highlight c %} {% include c/with_gvl.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/with_gvl.h %}\n"
"{% endhighlight %}"

#. type: Title ##
#: _posts/2010-01-01-c.markdown:889
#, no-wrap
msgid "See Also"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:891
#, no-wrap
msgid "extension.rdoc"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:897
msgid ""
"Ruby does have [official API documentation][readme]. It's a bit spotty and "
"has some poor recommendations (in my opinion), but it is also a little more "
"exhaustive on certain topics. In many cases this is because I intentionally "
"skipped something that I either found not useful or better documented "
"elsewhere."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:899
msgid "[readme]: https://github.com/ruby/ruby/blob/master/doc/extension.rdoc"
msgstr "[readme]: https://github.com/ruby/ruby/blob/master/doc/extension.rdoc"

#. type: Title ###
#: _posts/2010-01-01-c.markdown:900
#, no-wrap
msgid "Headers"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:910
msgid ""
"I think some of the handiest resources are the Ruby headers themselves. The "
"full API (i.e. everything you get by including `ruby.h`) easily consists of "
"a thousand functions, macros, constants, and globals&mdash;most of which "
"have never been documented. However _most_ things are reasonably named and "
"you should be able to figure out what they do from the header. Most "
"everything you need should be in the headers `ruby/ruby.h` and `ruby/intern."
"h`. The former has all of the VM and metaprogramming functions, the latter "
"has all of the functions for interacting with Ruby's built in classes."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:914
msgid ""
"There are also some headers _not_ pulled in by `ruby.h` which you can "
"include to get additional API functionality. Maybe one day I'll write "
"another section to this guide going over them:"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:923
msgid "`ruby/debug.h` (experimental) functions for profiling and tracing code"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:923
msgid "`ruby/encoding.h` functions for working with string encodings"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:923
msgid "`ruby/io.h` additional functions for Ruby's IO class"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:923
msgid "`ruby/re.h` additional functions for Ruby's Regexp class"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:923
msgid ""
"`ruby/thread.h` functions for working with the [GVL](#c-in-ruby-threads)"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:923
msgid ""
"`ruby/version.h` functions for version introspection. Do not use this as "
"feature-detection code!"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:923
msgid "`ruby/vm.h` (experimental) functions for VM control"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:924
#, no-wrap
msgid "Source"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:928
msgid ""
"If you find some function in the header that isn't documented anywhere, your "
"next stop should be the Ruby source code."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:932
msgid ""
"{% highlight shell_session %} $ git clone https://github.com/ruby/ruby.git "
"{% endhighlight %}"
msgstr ""
"{% highlight shell_session %}\n"
"$ git clone https://github.com/ruby/ruby.git\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:937
msgid ""
"When reading through the source code, always keep the headers at hand: there "
"are lots of really useful functions in there that _look_ like they should be "
"in the API, but actually aren't. In most cases there should be an API "
"function elsewhere that wraps the call to the useful function."
msgstr ""

#. type: YAML Front Matter: title
#: _posts/2010-01-01-c.markdown:938 _posts/2014-01-01-examples.markdown:1
#, no-wrap
msgid "Examples"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:942
msgid ""
"Head over to the [Examples](../examples) page for short, compilable examples "
"of the API in action."
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:943
#, no-wrap
msgid "Contribute"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:949
msgid ""
"Now that you've finished reading my guide, did you notice something "
"significant that I left out? Did I make some stupid mistake? Check out the "
"[source][gh] for this site on Github and you can report issues, submit pull "
"requests, and download all of the code examples."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:951
msgid "[gh]: https://github.com/silverhammermba/emberb"
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:952 _posts/2012-01-01-embed.markdown:123
#: _posts/2013-01-01-extend.markdown:128
#, no-wrap
msgid "Footnotes"
msgstr "脚註"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:958
#, no-wrap
msgid ""
"[^intern]: That's a blatant lie. The API _definitely_ lets you mess around\n"
"           with the internal data structures of objects (look for things with\n"
"           names starting with capital R). But it's generally not a good idea\n"
"           and not necessary.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:963
#, no-wrap
msgid ""
"[^undef]: There's also `Qundef` representing an undefined value, but\n"
"          this has no Ruby equivalent and is [rarely](#handling-blocks)\n"
"          [used](#constants-1). In fact, outside of those rare occassions,\n"
"          `Qundef` can segfault the VM if Ruby was expecting a normal `VALUE`.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:966
#, no-wrap
msgid ""
"[^wrap]: There's also `rb_eval_string_wrap()` which _should_ be useful, but is\n"
"         actually the same as `rb_eval_string_protect()` due to a [bug][bug2].\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:969
#, no-wrap
msgid ""
"[^chr]: There is a `CHR2FIX()` macro, but in my tests this sometimes gave\n"
"        unexpected results. `LONG2FIX()` should work.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:973
#, no-wrap
msgid ""
"[^wchar]: I don't know what the best way is to handle `wchar_t`. In my tests I had\n"
"          some success just treating them as `char`s, but I think that may have\n"
"          been a happy accident, and could certainly fail on different platforms.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:978
#, no-wrap
msgid ""
"[^clear]: The documentation [states][control] that \"You have to clear the error\n"
"          info [when] ignoring the caught exception\" during `rb_protect`. But I\n"
"          can't find any documentation of when it would be cleared for\n"
"          you&mdash;it seems like you _always_ have to clear it.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:981
#, no-wrap
msgid ""
"[^yield]: And there's `rb_yield_block()` which takes two unused arguments and is\n"
"          never called by anything in Ruby. Odd.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:985
#, no-wrap
msgid ""
"[^break]: The documentation [mentions][control] `rb_iter_break()` and\n"
"          `rb_iter_break_value()` for breaking out of a block, but can't you\n"
"          just return early? I can't think of a use-case for these.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:991
#, no-wrap
msgid ""
"[^int]: There is also the function `rb_thread_call_without_gvl2()`. The\n"
"        documentation in `thread.c` says that if it \"detects interrupt, it\n"
"        returns immediately,\" but I'm not sure what this means. If the\n"
"        unblocking function doesn't kill the thread, it still waits for the\n"
"        thread to finish on its own before returning.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:994
#, no-wrap
msgid ""
"[^ubf]: You can also use `RUBY_UBF_PROCESS`, but this seems to be a leftover\n"
"        from deprecated code and has the exact same effect.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:999
#, no-wrap
msgid ""
"[^oldwrap]: The `TypedData*` macros are the preferred way to wrap data since\n"
"            Ruby 1.9.2. If you're using an older version of Ruby you can check\n"
"            out an older version of this guide on Github to see how it used to\n"
"            be done.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:1002
#, no-wrap
msgid ""
"[^maybe]: There's also the enigmatically named `rb_gc_mark_maybe()`, but I'm not\n"
"          sure when it is needed.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:1004
msgid "[^tdata]: Or use `T_DATA` if the object [wraps a C pointer](#data)."
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:1006
msgid ""
"[control]: https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-"
"Control+Structure [bug2]: https://bugs.ruby-lang.org/issues/10466"
msgstr ""
"[control]: https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-Control+Structure\n"
"[bug2]: https://bugs.ruby-lang.org/issues/10466"

#. type: Title ##
#: _posts/2012-01-01-embed.markdown:1 _posts/2014-01-01-examples.markdown:6
#, no-wrap
msgid "Running Ruby in C"
msgstr "CでRubyを実行する"

#. type: Title ##
#: _posts/2012-01-01-embed.markdown:6 _posts/2013-01-01-extend.markdown:6
#, no-wrap
msgid "Compiling"
msgstr "コンパイルする"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:12
msgid ""
"Embedding Ruby requires one header `ruby.h`, which includes a platform-"
"specific header `ruby/config.h`. You will probably need to tell your "
"compiler about the include paths for these headers. You will also need to "
"link with the Ruby lib.  On my machine, my minimal compiler options are"
msgstr ""
"Rubyを組込むには `ruby.h` という1つのヘッダファイルが必要です。\n"
"このファイルはプラットフォーム固有のヘッダである `ruby/config.h` を含めます。\n"
"場合によってはコンパイラにヘッダファイルの含めるファイルパスを指定する必要があります。\n"
"Rubyライブラリと接続する必要もあります。\n"
"私の環境では、最小のコンパイラオプションは以下のようになります。"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:16
msgid ""
"{% highlight shell_session %} $ gcc -I/usr/include/ruby-{{ site."
"rbversion }}.0 -I/usr/include/ruby-{{ site.rbversion }}.0/x86_64-linux -"
"lruby {% endhighlight %}"
msgstr ""
"{% highlight shell_session %}\n"
"$ gcc -I/usr/include/ruby-{{ site.rbversion }}.0 -I/usr/include/ruby-{{ site.rbversion }}.0/x86_64-linux -lruby\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:19
msgid ""
"Though, if available, you should really use `pkg-config` to get the "
"appropriate options for your distribution:"
msgstr ""
"しかしもし可能であれば、ぜひとも `pkg-config` を使って、\n"
"各々のディストリビューションに適したオプションが得られるようにするべきです。"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:23
msgid ""
"{% highlight shell_session %} $ pkg-config --cflags --libs ruby-{{ site."
"rbversion }} {% endhighlight %}"
msgstr ""
"{% highlight shell_session %}\n"
"$ pkg-config --cflags --libs ruby-{{ site.rbversion }}\n"
"{% endhighlight %}"

#. type: Title ##
#: _posts/2012-01-01-embed.markdown:24
#, no-wrap
msgid "Startup, Teardown"
msgstr "起動と終了"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:29
msgid ""
"Including the Ruby interpreter in your C/C++ program is pretty simple. Just "
"include the header, call a startup function in `main` before you use the "
"API, and a cleanup function after you're done:"
msgstr ""
"RubyインタプリタをCやC++のプログラムに含めることはとても簡単です。\n"
"ヘッダーを含めて、\n"
"APIを使用する前にインタプリタを立ち上げるための関数を `main` で呼び、\n"
"そして完了後に後片付けをする関数を呼べばよいのです。"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:33
msgid "{% highlight c %} {% include embed/simple.c %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include embed/simple.c %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:38
msgid ""
"If the VM fails to start during `ruby_init()` it will print an error and "
"exit your program! If you would rather have a softer error, you can instead "
"call `ruby_setup()` which returns a nonzero value if a failure occurred "
"(unfortunately it is not clear how to get a message for the error[^err])."
msgstr ""
"`ruby_init()` の最中にVMが実行に失敗したら、\n"
"エラーを表示してプログラムが終了してしまいます！\n"
"もっと柔軟にエラーを出したいときは、\n"
"代わりに失敗したときにゼロではない値を返す\n"
"`ruby_setup()` を使いましょう（運が悪いことに、\n"
"この場合のエラーメッセージの出しかたはよくわかっていません[^err]）。"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:43
msgid ""
"If an error occurs during `rb_cleanup()`, it returns a nonzero value&mdash;"
"otherwise it returns the argument you passed it. This allows a little "
"shortcut for returning an error status if the cleanup fails (as demonstrated "
"in the previous example)."
msgstr ""
"`rb_cleanup()` のさなかにエラーが発生したときは、\n"
"ゼロではない値を返します。\n"
"もしエラーが発生しなければ、渡した引数が返ります。\n"
"この仕様により、後片付けに失敗したときのエラーステータスを返す部分が少し短く書けます（先の例のように）。"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:52
msgid ""
"_Technically_ you don't have to call `ruby_init`/`ruby_setup` in `main`, but "
"the Ruby VM assumes that all future Ruby code will be run from the same "
"stack frame or a lower one (for garbage collection purposes). The easiest "
"way to ensure this is to do set up at the top-level of your program, though "
"other approaches could work. But it would be a bad idea, for example, to "
"init Ruby in some deeply-nested function, pop a bunch of stack frames, and "
"then run a bunch of Ruby code.  {: .alert .alert-danger}"
msgstr ""
"_技術的には_ `main` で `ruby_init` や `ruby_setup` を呼ぶ必要はありません。\n"
"しかし、RubyのVMは以降全てのRubyのコードが同じかこれより低層のスタックフレームから\n"
"実行されることを仮定しています（ガベージコレクションのためです）。\n"
"他の方法でも動くにせよ、\n"
"このことを確証する最も簡単な方法がプログラムのトップレベルで立ち上げを行うことなのです。\n"
"例えば深く入れ子になった関数でRubyを初期化して、沢山のスタックフレームを立ち上げ、\n"
"そして沢山のRubyのコードを実行するようなことはよくありません。\n"
"{: .alert .alert-danger}"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:58
msgid ""
"During cleanup, the VM might evaluate more Ruby code (if you passed a block "
"to `at_exit`, for example) which could raise an exception. `ruby_cleanup()` "
"handles these by returning a nonzero value and printing an error message. If "
"you instead call `ruby_finalize()` they will be raised normally (see the "
"section on [Exceptions](../c#rescue) for how to handle them)."
msgstr ""
"後片付けをするときにも、VMはRubyのコードを評価するかもしれません（`at_exit` にブロックを渡したときなど）。\n"
"そしてそのときに例外が発生する可能性があります。\n"
"`ruby_cleanup()` はこのような例外が発生したときに、\n"
"ゼロではない値を返してエラーメッセージを表示することで制御します。\n"
"代わりに `ruby_finalize()` を呼ぶと、通常通り例外を発生させます。\n"
"（制御方法については[Exceptions](../c#rescue)節を参照）"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:60
msgid "Here's an alternative example:"
msgstr "別の例はこちらです。"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:64
msgid "{% highlight c %} {% include embed/advanced.c %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include embed/advanced.c %}\n"
"{% endhighlight %}"

#. type: Title ###
#: _posts/2012-01-01-embed.markdown:65
#, no-wrap
msgid "Limitations"
msgstr "制約"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:73
msgid ""
"Other than the stack frame warning above, there is another limitation: you "
"only get one Ruby VM per process. The startup/teardown might make it look "
"like you can keep on destroying and rebuilding the VM over and over again, "
"but `ruby_cleanup` only makes sure that your Ruby code is all cleaned up and "
"done.  It doesn't fully clean up the VM state such that it is ready to be re-"
"initialized: if you call `ruby_init` again, it will fail."
msgstr ""
"上記のスタックフレームの警告以外にも制約があります。\n"
"1つのプロセスに1つだけRubyのVMを動かせます。\n"
"起動と終了の方法を見ると、何度でもVMの破壊と創造を繰り返せるような気がしてくるかもしれませんが、\n"
"`ruby_cleanup` はRubyのコードが全ての後片付けが完了したことだけを確認します。\n"
"VMの状態を再度初期化できるような状態までは後片付けしません。\n"
"もう一度 `ruby_init` を呼び出すと、実行に失敗してしまうでしょう。"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:76
msgid ""
"If for some reason you need multiple Ruby VMs in your program, you will need "
"to spin them off in multiple processes to bypass this limitation."
msgstr ""
"何かかの理由があってプログラムで複数のRubyのVMが必要になったら、\n"
"この制約を回避するために複数のプロセスに小分けにしなければいけません。"

#. type: Title ##
#: _posts/2012-01-01-embed.markdown:77
#, no-wrap
msgid "Tweaking the VM"
msgstr "VMを設定する"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:82
msgid ""
"You now have a bare-bones Ruby VM running, but you may want to set up a "
"little more stuff before you start running Ruby code. To set the name of the "
"Ruby script (e.g. `$0`) for error messages and such, use"
msgstr ""
"これでRubyのVMの実行の骨子を会得しました。\n"
"でも、Rubyのコードの実行に先駆けてもう少し設定したいことがあるかもしれません。\n"
"エラーメッセージとかのためにRubyのスクリプトの名前（例：`$0`）を設定したいときは、\n"
"以下のようにします。"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:86
msgid "{% highlight c %} ruby_script(\"new name\")  {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"ruby_script(\"new name\")\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:88
msgid "To set up the load path so that gems can be loaded with `require`, use"
msgstr ""
"gemが `require` で呼び出せるようにするためにロードパスを設定するには、\n"
"次のようにします。"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:92
msgid "{% highlight c %} ruby_init_loadpath()  {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"ruby_init_loadpath()\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:96
msgid ""
"You can also pass options to the VM just like you would to `ruby` on the "
"command line. This is handy for stuff like setting the warning level or "
"verbose mode[^opt]."
msgstr ""
"VMにはコマンドラインで `ruby` するときと同じオプションを渡せます。\n"
"警告水準や冗長モード[^opt]の設定に手頃です。"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:100
msgid "{% highlight c %} {% include embed/options.c %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include embed/options.c %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:106
msgid ""
"The arguments to `ruby_options` are `argc` and `argv` just like a main "
"function.  And just like the main of the `ruby` program, the VM expects to "
"get some Ruby code when you call it. If you don't give it the filename of a "
"script to load or code to run with `-e`, it will try to read from `stdin`. "
"If you want to set options but _not_ run any Ruby code, you can pass it an "
"empty line: `\"-e \"`."
msgstr ""
"`ruby_options` への引数は main 関数と同じ `argc` と `argv` です。\n"
"そして、 `ruby` プログラムの main と同じように、\n"
"呼び出したときはVMは何らかのRubyのコードがあるものとしています。\n"
"ロードするスクリプトのファイル名を与えていなかったり、\n"
"`-e` で実行するコードがないときは、\n"
"`stdin` から読み込もうとします。\n"
"オプションを設定したいけれども、Rubyのコードを実行したく _ない_ ときには、\n"
"`\"-e \"` のように空行を渡せばよいです。"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:115
msgid ""
"`ruby_options()` returns a \"node\" that represents the compiled Ruby code. "
"In some cases (such as a syntax error) the node will be invalid and you "
"shouldn't run it. `ruby_executable_node()` checks for this. If the node is "
"valid, you can run it with `ruby_exec_node()`. The state returned by "
"`ruby_executable_node()` (through the pointer) and by `ruby_exec_node()` "
"will be nonzero if an exception was raised while compiling or running the "
"code. You can [read the exception yourself](../c#rescue), or just pass "
"`state` to `ruby_cleanup()` and it will print an appropriate error message."
msgstr ""
"`ruby_options()` はコンパイルされたRubyのコードを表現する \"node\" を返します。\n"
"場合によっては（文法エラーとか）nodeが不正で実行すべきでないときがあります。\n"
"`ruby_executable_node()` はこのnodeを検査します。\n"
"nodeが妥当であれば、 `ruby_exec_node()` で実行できます。\n"
"`ruby_executable_node()` で（ポインタを介して）返る状態は、\n"
"コンパイルの最中やコードの実行時に例外が発生したら、ゼロではない値になります。\n"
"[例外を自前で読む](../c#rescue)こともできますし、\n"
"`ruby_cleanup()` に `state` を渡して適切なエラーメッセージを表示させることもできます。"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:118
msgid ""
"Ruby currently doesn't support any other way of compiling and running code "
"separately[^load]."
msgstr "Rubyは現状ではコードの他のコンパイル・実行を別々にする方法を提供していません[^load]。"

#. type: Title ##
#: _posts/2012-01-01-embed.markdown:119 _posts/2013-01-01-extend.markdown:105
#, no-wrap
msgid "Success"
msgstr "やったね"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:122
msgid "Now you're ready to interact with Ruby! Go back to the [C API](../c)."
msgstr ""
"これでRubyとやりとりすることができました！\n"
"[C API](../c.ja)に戻りましょう。"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:127
#, no-wrap
msgid ""
"[^err]: `ruby_init()` uses `error_print()` to get an error message, but this\n"
"        function isn't exposed to the API. Is this a normal exception?\n"
msgstr ""
"[^err]: `ruby_init()` はエラーメッセージを取得するために\n"
"        `error_print()` を使います。\n"
"        しかし、この関数はAPIとして出されていません。\n"
"        これはよくあることなのでしょうか。\n"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:131
#, no-wrap
msgid ""
"[^opt]: In my tests I couldn't get flags like `-w` and `-v` to do anything. This\n"
"        could be related to `ruby_prog_init()`. And really it should be possible\n"
"        to do this without parsing command line options.\n"
msgstr ""
"[^opt]: 筆者の実験では、フラグ `-w` や `-v` で何もできませんでした。\n"
"        `ruby_prog_init()` がするのかもしれません。\n"
"        きっとそれでコマンドラインオプションをパースすることなしに実現できるはずです。\n"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:133
#, no-wrap
msgid ""
"[^load]: It looks like the function `rb_load_file()` should do this, but I\n"
"         haven't had any luck getting it to work.\n"
msgstr ""
"[^load]: `rb_load_file()` 関数でこれができそうですが、\n"
"         動かせた試しがありません。\n"

#. type: Title ##
#: _posts/2013-01-01-extend.markdown:1 _posts/2014-01-01-examples.markdown:35
#, no-wrap
msgid "Running C in Ruby"
msgstr "RubyでCを実行する"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:11
msgid ""
"Compiling C code to be loaded as a Ruby extension requires some fancy "
"compiler options. Ruby's [`mkmf` stdlib][mkmf] makes it easy to do this by "
"generating an appropriate makefile for you."
msgstr ""
"C言語のコードを、Rubyの拡張としてロードできるようにコンパイルするには、\n"
"ちょっとしたコンパイラのオプションが要ります。\n"
"Rubyの [`mkmf` 標準ライブラリ][mkmf]があれば、\n"
"適切なmakefileを生成してくれるので、\n"
"コンパイルが楽になります。"

#. type: Title ###
#: _posts/2013-01-01-extend.markdown:12
#, no-wrap
msgid "Preparation"
msgstr "準備"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:15
msgid ""
"First create the file `extconf.rb` in the same directory as your C code:"
msgstr "まず、C言語のコードがあるのと同じディレクトリに `extconf.rb` というファイルをつくります。"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:19
msgid ""
"{% highlight ruby %} {% include extend/ext/extconf.rb %} {% endhighlight %}"
msgstr ""
"{% highlight ruby %}\n"
"{% include extend/ext/extconf.rb %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:22
msgid ""
"The preparation section should perform actions similar to the standard UNIX "
"[`configure` script][conf] e.g."
msgstr ""
"準備する部分では、標準的なUNIXでの [`configure` スクリプト][conf]でするようなことをします。\n"
"例えば次のようなことです。"

#. type: Bullet: '* '
#: _posts/2013-01-01-extend.markdown:26
msgid "Check features of the current platform"
msgstr "現在のプラットフォームの特徴を確認する"

#. type: Bullet: '* '
#: _posts/2013-01-01-extend.markdown:26
msgid "Check for existence of required libraries and functions"
msgstr "必要なライブラリと関数があることを確認する"

#. type: Bullet: '* '
#: _posts/2013-01-01-extend.markdown:26
msgid "Check for programs needed for building"
msgstr "ビルドするのに必要なプログラムがあることを確認する"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:28
msgid "[conf]: http://en.wikipedia.org/wiki/Configure_script"
msgstr "[conf]: http://en.wikipedia.org/wiki/Configure_script"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:32
msgid ""
"The most common of these actions are provided by `mkmf` (but you have all of "
"Ruby at your disposal if you need it). For example, an extension which uses "
"SDL2 and needs to know how big `int`s are might call:"
msgstr ""
"あるあるな機能は `mkmf` で提供されます（でも、必要とあらばRubyをまったく使わなくてもいいです）。\n"
"例えば、SDL2を使っていて、それとは別に `int` の大きさを知らなければいけないような拡張であれば、\n"
"こんな感じで呼び出すことになります。"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:36
msgid ""
"{% highlight ruby %} {% include extend/ext/exex.rb %} {% endhighlight %}"
msgstr ""
"{% highlight ruby %}\n"
"{% include extend/ext/exex.rb %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:40
msgid ""
"`create_header` creates the file `extconf.h` containing preprocessor "
"definitions based on the results of the `mkmf` functions you called "
"previously. For this example, `extconf.h` might contain"
msgstr ""
"`create_header` は、それより前に呼んだ `mkmf` の関数の結果に基づいて、\n"
"前処理器の定義を含む `extconf.h` ファイルをつくります。\n"
"この例では `extconf.h` は次のような内容を含みます。"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:44
msgid "{% highlight c %} {% include extend/ext/exh.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include extend/ext/exh.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:52
msgid ""
"This header should be included in your C files so that you can adapt your "
"code to a variety of platforms. Note that you can and should abort the "
"`extconf.rb` script if a `mkmf` function returns a value that indicates that "
"the build will fail. For example, if SDL2 is a _requirement_ of your "
"extension you should exit with some meaningful error message if "
"`have_library('SDL2')` returns `false`.  This is preferred to generating the "
"Makefile anyway and leaving the user with an opaque compiler error."
msgstr ""
"このヘッダはC言語のファイルに取り込むとよいでしょう。\n"
"そうすれば様々なプラットフォームでコードが使えるようになります。\n"
"気に留めておいてほしいことは、\n"
"`mkmf` 関数がビルドの失敗を示す値を返したら、\n"
"`extconf.rb` スクリプトを頓挫させられますし、そうするべきだということです。\n"
"例えば、ある拡張にSDL2が _必須_ であれば、\n"
"`have_library('SDL2')` が `false` を返したときは、\n"
"何らかの有意味なエラーメッセージを吐いて終了するようなスクリプトにしましょう。\n"
"とりあえずMakefileを生成して、\n"
"よくわからないコンパイルエラーで利用者を置き去りにするよりはマシです。"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:57
msgid ""
"`create_makefile` obviously creates the Makefile, but its argument is "
"especially important: it defines the entry point of your C code, the name of "
"the compiled library, and thus the argument for `require` in Ruby! This "
"should be the name of your extension."
msgstr ""
"`create_makefile` はもちろんMakefileをつくりますが、\n"
"その引数が特に大切です：\n"
"C言語のコードの入口を決めるものであり、\n"
"コンパイルされたライブラリの名前であり、\n"
"Rubyで `require` するときの引数でもあるのです！\n"
"これは拡張の名前であるべきです。"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:63
msgid ""
"You can modify a few of the generated Makefile variables by modifying the "
"corresponding globals in Ruby: `$CFLAGS`, `$CPPFLAGS`, and `"
"$LDFLAGS`[^glob].  You can also use the `$objs` global to define a list of "
"object files for the Makefile if its method of automatically generating "
"targets doesn't work for your extension."
msgstr ""
"生成されるMakefileの変数のいくつかを変更するには、\n"
"Rubyでの対応する大域変数を変更します：\n"
"`$CFLAGS` や `$CPPFLAGS` や `$LDFLAGS` がそうです。\n"
"自動的な生成方法がうまくいかないときは、\n"
"Makefileでのオブジェクトファイルのリストを `$objs` 大域変数で指定することもできます。"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:68
msgid ""
"All of the `mkmf` functions and their options are well-documented [online]"
"[mkmf]. In addition to the functions for generating `extconf.h`, there are a "
"variety of functions for handling different source file layouts, different "
"file dependencies, etc."
msgstr ""
"全ての `mkmf` 関数とそれぞれのオプションは[オンライン][mkmf]で充分に文書化されています。\n"
"`extconf.h` を生成する関数に加えて、\n"
"また違ったソースファイルの配置や依存関係を制御する様々な関数があります。"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:70
msgid ""
"[mkmf]: http://www.ruby-doc.org/stdlib/libdoc/mkmf/rdoc/MakeMakefile.html"
msgstr "[mkmf]: http://www.ruby-doc.org/stdlib/libdoc/mkmf/rdoc/MakeMakefile.html"

#. type: Title ###
#: _posts/2013-01-01-extend.markdown:71
#, no-wrap
msgid "Execution"
msgstr "実行"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:74
msgid "The rest couldn't be simpler"
msgstr "あとはもう、これ以上簡単になりようがありません"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:79
msgid ""
"{% highlight shell_session %} $ ruby extconf.rb $ make {% endhighlight %}"
msgstr ""
"{% highlight shell_session %}\n"
"$ ruby extconf.rb\n"
"$ make\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:81
msgid ""
"[^argv]But of course that won't do anything without some C code to compile."
msgstr "[^argv] もちろん、C言語のコードがコンパイルできないことには話が進まないですけどね。"

#. type: Title ##
#: _posts/2013-01-01-extend.markdown:82
#, no-wrap
msgid "Init"
msgstr "初期化"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:89
msgid ""
"In your C code, you'll want to include `ruby.h` to access the API. Other "
"than that the only requirement is to define a function for the Ruby VM to "
"call when your library is `require`d. The name of the function is determined "
"by the argument you passed to `create_makefile` in `extconf.rb`. We used "
"\"foobar\" in our example, so we'll create `foobar.c` containing"
msgstr ""
"C言語のコードでは `ruby.h` を含めてAPIを使えるようにしたいのではないでしょうか。\n"
"その他には、 `require` したときにRubyの仮想機械がライブラリを呼べるように、\n"
"関数を定義するだけでよいです。\n"
"関数の名前は、 `extconf.rb` で `create_makefile` に渡した引数で決まります。\n"
"ここまでの例で `\"foobar\"` を使ってきたので、\n"
"次の内容の `foobar.c` ファイルをつくります。"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:93
msgid "{% highlight c %} {% include extend/ext/foobar.c %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include extend/ext/foobar.c %}\n"
"{% endhighlight %}"

#. type: Title ###
#: _posts/2013-01-01-extend.markdown:94
#, no-wrap
msgid "Filenames"
msgstr "ファイル名"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:101
msgid ""
"If your extension has only a single C file, you should name it after your "
"extension as we did above. If your extensions has multiple C files _do not_ "
"name any of them after your extension. This is because the Makefile may "
"generate a `.o` file named after your extension for the linking stage, which "
"would cause a conflict if you also have a `.c` file which compiles to that "
"filename."
msgstr ""
"拡張に1つのC言語のファイルだけしかないなら、\n"
"さっきやったように拡張の名前と同じファイル名にしましょう。\n"
"逆に複数のC言語のファイルからなる場合、\n"
"拡張に _同じ名前を使わない_ ようにしましょう。\n"
"リンクする段階でMakefileが拡張名と同じ `.o` ファイルを生成すると、\n"
"それと同じファイル名にコンパイルされる `.c` ファイルがある場合に衝突してしまうからです。"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:104
msgid ""
"Also avoid naming any files `conftest.c` as this file may be written to by "
"`mkmf`."
msgstr "また、 `conftest.c` というファイル名も、 `mkmf` によって書き込まれるかもしれないので避けます。"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:111
msgid ""
"Now make should compile a `.so` (or some other library) file which you can "
"`require` in Ruby. You can fill in your `Init` function with plain C code, "
"but you'll probably want to go back and learn about the [C API](../c) to do "
"more interesting stuff."
msgstr ""
"これにて make で `.so` （またはその他のライブラリ）にコンパイルして、\n"
"Rubyで `require` できるようになりました。\n"
"純粋なC言語のコードで `Init` 関数を実装していくこともできますが、\n"
"たぶんいったん戻って、\n"
"もっと面白いことをするために [C API](../c.ja) を学ばれるのではないでしょうか。"

#. type: Title ##
#: _posts/2013-01-01-extend.markdown:112
#, no-wrap
msgid "Gem"
msgstr "Gem"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:118
msgid ""
"After you've got your extension working nicely, you may want to bundle it up "
"as an easily distributable Ruby gem. rubygems.org has a [detailed guide]"
"[rbg] on creating gems, but as far as C extensions go you just need to tell "
"the spec about `extconf.rb`[^rbg]:"
msgstr ""
"いい感じに拡張が動くようになったら、\n"
"簡単に配布できるRubyのgemとしてまとめたいはずです。\n"
"rubygems.org にはgemをつくる上での[詳細なガイド][rbg]がありますが、\n"
"C拡張に関して言えば `extconf.rb` についてspecに記すだけでよいです[^rbg]。"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:122
msgid ""
"{% highlight ruby %} {% include extend/foobar.gemspec %} {% endhighlight %}"
msgstr ""
"{% highlight ruby %}\n"
"{% include extend/foobar.gemspec %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:125
msgid ""
"If your gem includes multiple independent extensions, you can organize them "
"in subdirectories of `ext/` and pass all of the `extconf.rb`s to the spec."
msgstr ""
"gemが複数の拡張に依存していたら、\n"
"`ext/` のサブディレクトリにそれぞれ固めて、\n"
"specに各々の `extconf.rb` を記します。"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:127
msgid "[rbg]: http://guides.rubygems.org/make-your-own-gem/"
msgstr "[rbg]: http://guides.rubygems.org/make-your-own-gem/"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:131
msgid "[^glob]: Check the [official documentation][globals]."
msgstr "[^glob]: [公式文書][globals]をご確認ください。"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:135
#, no-wrap
msgid ""
"[^argv]: The official documentation [hints][makefile] that `mkmf` parses certain\n"
"         command line flags e.g.  `--vendor`. But I can't find this documented\n"
"         anywhere.\n"
msgstr "[^argv]: 公式文書は、`--vendor` のようなコマンドライン引数を `mkmf` がパースできると[仄めかしている][makefile] ようです。でも、このことはどこにも文書化されていないように見えます。\n"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:137
msgid ""
"[^rbg]: [http://guides.rubygems.org/gems-with-extensions/](http://guides."
"rubygems.org/gems-with-extensions/)"
msgstr "[^rbg]: [http://guides.rubygems.org/gems-with-extensions/](http://guides.rubygems.org/gems-with-extensions/)"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:139
msgid ""
"[globals]: https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-"
"Prepare+extconf.rb [makefile]: https://github.com/ruby/ruby/blob/master/doc/"
"extension.rdoc#label-Generate+Makefile"
msgstr ""
"[globals]: https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-Prepare+extconf.rb\n"
"[makefile]: https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-Generate+Makefile"

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:14
msgid ""
"This example is a simple little game of tag. In the game there are two "
"squares: the blue square is controlled using the arrow keys on the keyboard "
"while the red square is controlled by a Ruby script. To make this work, "
"we'll use the C API to define a little Ruby API that the script can access, "
"and every couple of frames we'll call a method defined in the Ruby script "
"and pass objects encapsulating the data for the two squares."
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:16
msgid "The Ruby script can look something like this:"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:20
msgid "{% highlight ruby %} {% include examples/ai.rb %} {% endhighlight %}"
msgstr ""
"{% highlight ruby %}\n"
"{% include examples/ai.rb %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:24
msgid ""
"The C code uses SDL2 for graphics and input and uses `stat()` (which may not "
"be very portable) to hot-reload the AI script whenever the file is changed . "
"Here's `tag.c`:"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:28
msgid "{% highlight c %} {% include examples/tag.c %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include examples/tag.c %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:30
msgid "The Makefile is nothing special:"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:34
msgid "{% highlight make %} {% include examples/Makefile %} {% endhighlight %}"
msgstr ""
"{% highlight make %}\n"
"{% include examples/Makefile %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:42
msgid ""
"This example is a Ruby C extension that wraps the [GMP][gmp] C library for "
"arbitrary precision arithmetic. This is far from a complete example: it only "
"wraps the integer functions, implements only the basic functionality of the "
"library, and doesn't bother nicely integrating with Ruby's existing numeric "
"types. If you want a _really_ full example, check out the [GMP gem][gem]."
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:45
msgid "[gmp]: https://gmplib.org/ [gem]: https://github.com/srawlins/gmp"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:47
msgid "Everything is in `gmp.c` where we define our `GMP::Integer` class:"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:51
msgid "{% highlight c %} {% include examples/ext/gmp.c %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include examples/ext/gmp.c %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:53
msgid "The `extconf.rb` is really simple."
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:57
msgid ""
"{% highlight ruby %} {% include examples/ext/extconf.rb %} {% endhighlight %}"
msgstr ""
"{% highlight ruby %}\n"
"{% include examples/ext/extconf.rb %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:59
msgid "And now you can finally find out what your name means in base 62:"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:63
msgid ""
"{% highlight ruby %} {% include examples/gmp_ex.rb %} {% endhighlight %}"
msgstr ""
"{% highlight ruby %}\n"
"{% include examples/gmp_ex.rb %}\n"
"{% endhighlight %}"

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:70
msgid ""
"For this example I tried to do everything in C, but practically that isn't "
"necessary (or desirable). If one of your C methods just calls a bunch of API "
"functions (like `to_i` and `==` in the example), you're probably only saving "
"yourself a couple CPU cycles compared to implementing the method in Ruby. "
"And of course that comes at the cost of needing to spend more time writing C "
"and less time writing Ruby. ð"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:75
msgid ""
"A common convention when writing extensions is to only implement the \"meat"
"\" of the extension in C and to do everything else in a regular Ruby script "
"that pulls in the compiled library. For example, we could have written a "
"`gmp.rb` script to significantly simplify our extension:"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:78
msgid "{% highlight ruby %} {% include examples/gmp.rb %} {% endhighlight %}"
msgstr ""
"{% highlight ruby %}\n"
"{% include examples/gmp.rb %}\n"
"{% endhighlight %}"
