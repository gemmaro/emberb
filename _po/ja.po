# Japanese translations for emberb
# emberbに対する和訳
# Copyright (C) 2022 gemmaro.
# This file is distributed under the same license as the emberb.
#
msgid ""
msgstr ""
"POT-Creation-Date: 2022-02-19 20:33+0900\n"
"PO-Revision-Date: 2022-02-23 11:39+0900\n"
"Last-Translator: gemmaro <gemmaro.dev@gmail.com>\n"
"Language-Team: none\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: YAML Front Matter: layout
#: _posts/2010-01-01-c.markdown:1 _posts/2012-01-01-embed.markdown:1
#: _posts/2013-01-01-extend.markdown:1 _posts/2014-01-01-examples.markdown:1
#, no-wrap
msgid "chapter"
msgstr "chapter"

#. type: YAML Front Matter: title
#: _posts/2010-01-01-c.markdown:1
#, no-wrap
msgid "The Ruby C API"
msgstr "RubyのC API"

#. type: Title ##
#: _posts/2010-01-01-c.markdown:6
#, no-wrap
msgid "Before You Start"
msgstr "始める前に"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:10
#, no-wrap
msgid ""
"For the greatest chance of success with this guide, I recommend being fairly\n"
"comfortable with C and _very_ comfortable with Ruby.\n"
msgstr "このガイドを完全に理解するためには、C言語はそこそこ、Rubyは _かなり_ 慣れ親しんでいるとよいでしょう。\n"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:16
#, no-wrap
msgid ""
"Using Ruby's C API does not require any advanced C concepts, however the API is\n"
"**huge** and largely **undocumented**. After you start using it, you will likely\n"
"find yourself delving through the Ruby source code at some point to figure out\n"
"the behavior of some obscure function or macro. The Ruby source uses some fairly\n"
"sophisticated C, so you should at least feel comfortable reading it.\n"
msgstr ""
"RubyのC APIを使うのに発展的なC言語の概念は要りませんが、\n"
"APIは**膨大**で大半が**文書化されていません**。\n"
"APIを使い始めだすと、いつの日にか、\n"
"はっきりしない関数やマクロの振舞いを見つけるためにRubyのソースコードを探ることになるでしょう。\n"
"Rubyのソースはそこそこ洗練されたC言語で書かれているので、\n"
"すいすい読めはするでしょうけれども。\n"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:22
#, no-wrap
msgid ""
"You can think of the C API is being a big, clunky alternative to writing normal\n"
"Ruby code. However the simple, elegant patterns of Ruby can be pretty\n"
"unintuitive once translated into the language of the API. Having a strong\n"
"intuition for Ruby's internal logic and the ideas behind its design will go a\n"
"long way toward steering you toward the correct API functions.\n"
msgstr ""
"C APIは、普通のRubyのコードよりもデカくてゴチャっとした書き方だと見なせます。\n"
"とはいえ、簡素で明快なRubyの様式は、ひとたびAPIの言葉に翻訳されるとかなり非直感的になることがあります。\n"
"Rubyの内部論理と設計の背後にある思想に裏打ちされたしっかりとした直感があれば、\n"
"長い旅路のさなかでも正しいAPI関数へと進み続けられるでしょう。\n"

#. type: Title ##
#: _posts/2010-01-01-c.markdown:23
#, no-wrap
msgid "The Two Paths"
msgstr "分岐点"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:28
#, no-wrap
msgid ""
"The official Ruby interpreter is written in C. That means that everything you\n"
"can do in Ruby, you can also do using function calls to Ruby's C API. Why in the\n"
"world would you do this? There are two good reasons:\n"
msgstr ""
"公式のRubyインタプリタはC言語で書かれています。\n"
"Rubyでできるあらゆることは、RubyのC APIを呼び出す関数を使ってもできます。\n"
"いったいなぜそんなことをするのでしょうか？\n"
"もっともな理由が2つあります。\n"

#. type: Bullet: '1. '
#: _posts/2010-01-01-c.markdown:37
#, no-wrap
msgid ""
"You're writing some fancy application in C or C++ and you want some parts of\n"
"your code to leverage the dynamic flexibility of Ruby. You can run the\n"
"Ruby interpreter inside of your application and use the API to retrieve the\n"
"results of Ruby code.\n"
msgstr ""
"意匠を凝らしたC言語ないしC++のアプリケーションを書いている最中で、\n"
"Rubyの動的な柔軟性をコードのいくつかの箇所に使って、\n"
"効果を引き出そうとするとき。\n"
"アプリケーションの内部でRubyインタプリタを実行でき、\n"
"Rubyのコードの結果をAPIで受け取ることができます。\n"

#. type: Bullet: '2. '
#: _posts/2010-01-01-c.markdown:37
#, no-wrap
msgid ""
"You're writing some fancy application in Ruby and you want some parts of your\n"
"code to leverage the speed and power of C (or an existing C library). You can\n"
"expose C code to Ruby using the API and compile a special library that Ruby\n"
"can `require`.\n"
msgstr ""
"意匠を凝らしたRubyのアプリケーションを書いている最中で、\n"
"C言語（もしくは既にあるC言語のライブラリ）の速度と能力を\n"
"コードのいくつかの箇所に使って、\n"
"効果を引き出そうとするとき。\n"
"APIを使えば、RubyにC言語のコードをさらけ出すことができます。\n"
"そうしてできた特別なライブラリをコンパイルするとRubyから `require` できます。\n"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:42
#, no-wrap
msgid ""
"You'll need to structure your C code differently depending on your goal. If\n"
"you want to embed the Ruby interpreter in C, read [Running Ruby in C](../embed). If\n"
"you want to `require` a compiled C library, read [Running C in Ruby](../extend).\n"
"After you finish that, come back here to learn about the API.\n"
msgstr ""
"目標によってC言語のコードの組み立てかたは変わってきます。\n"
"C言語にRubyインタプリタを組込みたければ、\n"
"[C言語でRubyを実行する](../embed.ja)をお読みください。\n"
"コンパイルされたC言語のライブラリを `require` したければ、\n"
"[RubyでC言語を実行する](../extend.ja)をお読みください。\n"
"どちらかを読み終えたら、ここに戻ってきてAPIについて学びましょう。\n"

#. type: Title ##
#: _posts/2010-01-01-c.markdown:43
#, no-wrap
msgid "Eval"
msgstr "Eval"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:46
#, no-wrap
msgid "The quick 'n' dirty way to run some Ruby code from C is to `eval` it\n"
msgstr "ちゃちゃっと雑にCでRubyを動かすには、 `eval` します。\n"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:50
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/eval.h %}\n"
"{% endhighlight %}\n"
msgstr ""
"{% highlight c %}\n"
"{% include c/eval.h %}\n"
"{% endhighlight %}\n"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:55
#, no-wrap
msgid ""
"This is a good fallback if you can't find an API function for something that you\n"
"want to do[^wrap]. `rb_eval_string_protect()` returns the result of the Ruby\n"
"code and sets `state` to some nonzero value if any exception is raised. `VALUE`\n"
"is the C data type for all Ruby objects, as explained in the next section.\n"
msgstr ""
"これはやりたいことのためのAPI関数が見つからないときは選択肢に入ります[^wrap]。\n"
"`rb_eval_string_protect()` はRubyのコードの結果を返し、\n"
"何か例外が発生したときはゼロではない値を `state` に設定します。\n"
"`VALUE` はあらゆるRubyのオブジェクトのためのCのデータ型です。\n"
"次の節で後述します。\n"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:60
#, no-wrap
msgid ""
"If `state` is nonzero, `result` will be a `VALUE` representing `nil` and you\n"
"should handle the exception. Alternatively, you can use `rb_eval_string()` which\n"
"doesn't take a `state` argument and instead raises any exceptions normally. See\n"
"[Exceptions](#exceptions) for how to handle both of these cases.\n"
msgstr ""
"`state` がゼロではないとき、\n"
"`result` は `nil` を表す `VALUE` になっているでしょうから、\n"
"そのときは例外に対処しなければいけません。\n"
"代わりに `rb_eval_string()` を使うこともできます。\n"
"この関数は引数 `state` を取らず、通常の方法で例外を発生させます。\n"
"これら2つの場合での制御方法については[例外](#exceptions)節を参照してください。\n"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:64
#, no-wrap
msgid ""
"Unlike `eval` in Ruby, these functions evaluate the string in an isolated\n"
"binding&mdash;like when you `require` something. So local variables in the\n"
"string will not be accessible from elsewhere and vice versa.\n"
msgstr ""
"Rubyでの `eval` とは異なり、\n"
"これらの関数は独立の束縛状態で評価します。\n"
"ちょうど何かを `require` するときと同じです。\n"
"したがって文字列中のローカル変数は他の場所から参照できませんし、逆もまた然りです。\n"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:69
#, no-wrap
msgid ""
"However, like using `eval` in Ruby, using these functions is not a good\n"
"practice. It's inefficient since the parser is invoked and it somewhat defeats\n"
"the point of writing in C. If you just want to call some Ruby method, we'll go\n"
"over a better way to do that [later on](#send).\n"
msgstr ""
"しかし、Rubyで `eval` するときのように、\n"
"これらの関数を使うことはあまりよくありません。\n"
"パーサが起動されなければいけないのが非効率ですし、\n"
"Cで書くことの利点が失われています。\n"
"Rubyのメソッドを呼びたいだけであれば、\n"
"もっといい方法を[後述](#send)します。\n"

#. type: Title ##
#: _posts/2010-01-01-c.markdown:70
#, no-wrap
msgid "VALUE"
msgstr "VALUE"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:79
#, no-wrap
msgid ""
"Before we go any further, we need to understand `VALUE`s. Due to the danger of\n"
"monkeying around inside the VM, the API never lets you directly access Ruby's\n"
"objects[^intern]. Instead, your C code will store and pass around _pointers_ to\n"
"Ruby objects (like how variables in Ruby contain pointers to objects). These\n"
"pointers can be passed to various API functions and macros that will safely\n"
"access and manipulate the Ruby objects. `VALUE` is the API-defined C type for\n"
"these pointers.\n"
msgstr ""
"先に進む前に、\n"
"`VALUE` について理解しなければいけません。\n"
"VMの内部をめちゃくちゃにしてしまう危険があるので、\n"
"APIからは直接Rubyのオブジェクトを扱えません[^intern]。\n"
"その代わり、CのコードはRubyのオブジェクトへの _ポインタ_ を保持したり受け渡したりします（Rubyの変数がオブジェクトへのポインタを持つのと同じです）。\n"
"ポインタはさまざまなAPIの関数やマクロに渡すことができ、\n"
"そのためRubyのオブジェクトに安全にアクセスしたり操作したりできます。\n"
"`VALUE` はAPIで定義されたCの型で、このポインタを扱います。\n"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:84
#, no-wrap
msgid ""
"Probably the most frequent question you'll have is: \"is this `VALUE` the right\n"
"type?\". There are a couple macros for performing this test, and both take a\n"
"[`T_` constant][datatypes] corresponding to the Ruby class you're\n"
"testing for e.g. `T_STRING`, `T_ARRAY`, etc.\n"
msgstr ""
"おそらく最も頻繁に湧いてくる疑問は次のようなものでしょう。\n"
"「この `VALUE` は正しい型なのだろうか？」\n"
"この疑問に答えるマクロは2つあり、\n"
"そのどちらも[`T_` 定数](datatypes)を引数に取ります。\n"
"この定数は比較したい型に対応するRubyのクラスです。\n"
"例えば `T_STRING` や `T_ARRAY` などです。\n"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:86
#, no-wrap
msgid "[datatypes]: https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-Data+Types\n"
msgstr "[datatypes]: https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-Data+Types\n"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:90
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/checktype.h %}\n"
"{% endhighlight %}\n"
msgstr ""
"{% highlight c %}\n"
"{% include c/checktype.h %}\n"
"{% endhighlight %}\n"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:96
#, no-wrap
msgid ""
"These tests work for subclasses too: if you're testing for a subclass of `Array`\n"
"use `T_ARRAY`, if you're testing for a subclass of `Object` use\n"
"`T_OBJECT`[^tdata]. That being said, these tests _do not work like `is_a?`_;\n"
"even though everything in Ruby `is_a? Object`, testing against `T_OBJECT` will\n"
"only return true for objects for which there is no better fitting constant.\n"
msgstr ""
"この検査はサブクラスでも同様にはたらきます。\n"
"`Array` のサブクラスであることを確認したいときは `T_ARRAY` を使いますし、\n"
"`Object` のサブクラスであることを確認したいときには `T_OBJECT` を使います[^tdata]。\n"
"つまり、この検査は _`is_a?` と同じではない_ ということでもあります。\n"
"Rubyのありとあらゆるものについて `is_a? Object` であるにせよ、\n"
"`T_OBJECT` に対する検査は、\n"
"他にもっと適した定数がないときにのみ真となります。\n"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:99
#, no-wrap
msgid ""
"For certain classes, there are specialized macros that are a little more\n"
"efficient than the previous:\n"
msgstr "特定のクラスには、前述したものより少し効率的なマクロが使えます。\n"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:103
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/check_p.h %}\n"
"{% endhighlight %}\n"
msgstr ""
"{% highlight c %}\n"
"{% include c/check_p.h %}\n"
"{% endhighlight %}\n"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:107
#, no-wrap
msgid ""
"If you want to handle a `VALUE` that could be one of a variety of types, the\n"
"previous macros can be a little clumsy. In that case you can use the `TYPE()`\n"
"macro to get the `T_` constant and handle your logic in a `switch`:\n"
msgstr ""
"いくつかの型を取りうる `VALUE` を扱いたいときは、\n"
"前述のマクロはちょっと不恰好です。\n"
"そんな場合は `TYPE()` マクロを使って `T_` 定数を取得し、\n"
"`switch` 文で制御できます。\n"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:111
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/type.h %}\n"
"{% endhighlight %}\n"
msgstr ""
"{% highlight c %}\n"
"{% include c/type.h %}\n"
"{% endhighlight %}\n"

#. type: Title ###
#: _posts/2010-01-01-c.markdown:112
#, no-wrap
msgid "Constants"
msgstr "定数"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:121
#, no-wrap
msgid ""
"Most of the standard Ruby constants have global `VALUE`s defined for them in the\n"
"API so you don't need an API call to access them. Modules are prefixed with\n"
"`rb_m` e.g. `rb_mKernel`; classes are prefixed with `rb_c` e.g. `rb_cObject`;\n"
"subclasses of `Exception` are prefixed with `rb_e` e.g. `rb_eRuntimeError`; and\n"
"the standard IO streams are prefixed with `rb_` e.g. `rb_stderr`. `nil`,\n"
"`false`, and `true` are prefixed with `Q` e.g. `Qnil`.[^undef] As a convenience,\n"
"`Qfalse` is also false in C (`0`).\n"
msgstr ""
"ほとんどの標準的なRubyの定数はAPIで大域的な `VALUE` が定義されています。\n"
"したがってそれらの定数を使うのにAPIの呼び出しは要りません。\n"
"モジュールは `rb_m` で前置されます。\n"
"たとえば `rb_mKernel` です。\n"
"クラスは `rb_c` で前置されます。\n"
"たとえば `rb_cObject` です。\n"
"`Exception` のサブクラスは `rb_e` で前置されます。\n"
"たとえば `rb_eRubtimeError` です。\n"
"標準的なIOストリームは `rb_` で前置されます。\n"
"たとえば `rb_stderr` です。\n"
"`nil`, `false`, `true` は `Q` で前置されます。\n"
"例えば `Qnil` です。\n"
"[^undef] 便宜上、 `Qfalse` はCの偽値 (`0`) でもあります。\n"

#. type: Title ###
#: _posts/2010-01-01-c.markdown:122
#, no-wrap
msgid "Translation"
msgstr "変換"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:126
#, no-wrap
msgid ""
"A few Ruby classes are analogous to C types. These classes will be your primary\n"
"means of transferring data between C and Ruby.\n"
msgstr ""
"いくつかのRubyのクラスはCの型に対応します。\n"
"この対応する組み合わせは、CとRubyの間のデータのやりとりをするには一番です。\n"

#. type: Title ####
#: _posts/2010-01-01-c.markdown:127
#, no-wrap
msgid "Fixnum"
msgstr "Fixnum"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:133
#, no-wrap
msgid ""
"Ruby's `Fixnum` corresponds to C's `long`. The `FIX2LONG()` macro gives you the\n"
"`long` for a `Fixnum`. For smaller C types there's `FIX2UINT()`, `FIX2INT()`,\n"
"and `FIX2SHORT()`, but these will raise a `RangeError` if the number wouldn't\n"
"fit.\n"
msgstr ""
"Rubyの `Fixnum` はCの `long` に対応します。\n"
"`FIX2LONG()` マクロにより、 `long` を `Fixnum` に変換できます。\n"
"より小さいCの型については、\n"
"`FIX2UINT()`, `FIX2INT()`, `FIX2SHORT()` があります。\n"
"しかし、これらのマクロは変換時に数値が大きすぎて収まらない場合は `RangeError` を生じます。\n"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:136
#, no-wrap
msgid ""
"In the other direction, `LONG2FIX()` works for `long` **and** every smaller\n"
"integer C type[^chr].\n"
msgstr ""
"逆向きの変換もできて、\n"
"`LONG2FIX()` は `long` *に加えて* `long` より小さい全てのCの整数型からの変換に使えます。\n"

#. type: Title ####
#: _posts/2010-01-01-c.markdown:137
#, no-wrap
msgid "Bignum"
msgstr "Bignum"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:143
#, no-wrap
msgid ""
"Ruby's `Bignum` is for anything bigger than a `Fixnum`, so it works if you need\n"
"to work with `long long`, for example. `rb_big2ll()` and `rb_big2ull()` will get\n"
"you `long long` and `unsigned long long` from a `Bignum` (or raise a\n"
"`RangeError` if appropriate).\n"
msgstr ""
"Rubyの `Bignum` は `Fixnum` より大きいあらゆる整数に使えます。\n"
"例えば `long long` が必要なときとかです。\n"
"`rb_big2()` と `rb_big2u()` を使えば、 `Bignum` から\n"
"それぞれ `long long` や `unsigned long long` に直せます。\n"
"（もしくは `RangeError` が発生します。）\n"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:145 _posts/2010-01-01-c.markdown:152
#, no-wrap
msgid "See [Numeric](#numeric) for the reverse direction.\n"
msgstr "逆向きの変換については [数値](#numeric) を参照してください。\n"

#. type: Title ####
#: _posts/2010-01-01-c.markdown:146
#, no-wrap
msgid "Float"
msgstr "Float"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:150
#, no-wrap
msgid ""
"Ruby's `Float` corresponds to C's `double`. The `RFLOAT_VALUE()` macro gives you the\n"
"`double` for a `Float`.\n"
msgstr ""
"Rubyの `Float` はCの `double` に対応します。\n"
"`RFLOAT_VALUE()` マクロを使えば、 `Float` から `double` が得られます。\n"

#. type: Title ####
#: _posts/2010-01-01-c.markdown:153
#, no-wrap
msgid "Numeric"
msgstr "Numeric"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:158
#, no-wrap
msgid ""
"There are a host of \"NUM\" macros that try to be more duck-typish about things.\n"
"These will convert their C types to whatever Ruby `Numeric` subclass seems\n"
"appropriate:\n"
msgstr ""
"たくさんの \"NUM\" マクロがあり、\n"
"ダックタイピングっぽい使いかたをしています。\n"
"これらのマクロはCの型を適切と思われるRubyの `Numeric` のサブクラス（のインスタンス）に変換します。\n"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:166
#, no-wrap
msgid "`INT2NUM()` for `int`\n"
msgstr "`INT2NUM()` は `int` からの変換用\n"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:166
#, no-wrap
msgid "`UINT2NUM()` for `unsigned int`\n"
msgstr "`UINT2NUM()` は `unsigned int` からの変換用\n"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:166
#, no-wrap
msgid "`LONG2NUM()` for `long`\n"
msgstr "`LONG2NUM()` は `long` からの変換用\n"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:166
#, no-wrap
msgid "`ULONG2NUM()` for `unsigned long`\n"
msgstr "`ULONG2NUM()` は `unsigned long` からの変換用\n"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:166
#, no-wrap
msgid "`LL2NUM()` for `long long`\n"
msgstr "`LL2NUM()` は `long long` からの変換用\n"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:166
#, no-wrap
msgid "`ULL2NUM()` for `unsigned long long`\n"
msgstr "`ULL2NUM()` は `unsigned long long` からの変換用\n"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:166
#, no-wrap
msgid "`DBL2NUM()` for `double`\n"
msgstr "`DBL2NUM()` は `double` からの変換用\n"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:171
#, no-wrap
msgid ""
"And there are macros for the opposite direction, which will try to convert\n"
"whatever `Numeric` to the desired C type. These will raise a `RangeError` if\n"
"the value wouldn't fit or `TypeError` if there is no implicit numeric conversion\n"
"(so you can safely pass non-`Numeric` objects).\n"
msgstr ""
"そして、逆方向のマクロもあります。\n"
"これらのマクロは、あらゆる `Numeric` な数値から欲しいCの型の値への変換を試みるものです。\n"
"値が範囲に収まらなかったときは `RangeError` を発生させますし、\n"
"暗黙の数値の変換ができなかったときは `TypeError` が発生します。\n"
"（なので `Numeric` ではないオブジェクトを渡しても大丈夫です。）\n"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
#, no-wrap
msgid "`NUM2CHR()` for `char` (works for `unsigned char` too)\n"
msgstr "`NUM2CHR()` は `char` からの変換用（`unsigned char` からでも変換できます）\n"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
#, no-wrap
msgid "`NUM2SHORT()` for `short`\n"
msgstr "`NUM2SHORT()` は `short` からの変換用\n"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
#, no-wrap
msgid "`NUM2USHORT()` for `unsigned short`\n"
msgstr "`NUM2USHORT()` は `unsigned short` からの変換用\n"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
#, no-wrap
msgid "`NUM2INT()` for `int`\n"
msgstr "`NUM2INT()` は `int` からの変換用\n"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
#, no-wrap
msgid "`NUM2UINT()` for `unsigned int`\n"
msgstr "`NUM2UINT()` は `unsigned int` からの変換用\n"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
#, no-wrap
msgid "`NUM2LONG()` for `long`\n"
msgstr "`NUM2LONG()` は `long` からの変換用\n"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
#, no-wrap
msgid "`NUM2ULONG()` for `unsigned long`\n"
msgstr "`NUM2ULONG()` は `unsigned long` からの変換用\n"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
#, no-wrap
msgid "`NUM2LL()` for `long long`\n"
msgstr "`NUM2LL()` は `long long` からの変換用\n"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
#, no-wrap
msgid "`NUM2ULL()` for `unsigned long long`\n"
msgstr "`NUM2ULL()` は `unsigned long long` からの変換用\n"

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
#, no-wrap
msgid "`NUM2DBL()` for `double`\n"
msgstr "`NUM2DBL()` は `double` からの変換用\n"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:189
#, no-wrap
msgid ""
"A **major** gotcha with these is that _none_ of the macros for converting to\n"
"unsigned types raise an exception if you pass a negative value (surprisingly\n"
"this [isn't a bug][bug]). `NUM2CHR()` also has a couple quirks: it will only\n"
"raise a `RangeError` if the value is too big for an _int_ and when passed a\n"
"string it returns the numeric value of the first character rather than raising a\n"
"`TypeError`.\n"
msgstr ""
"これらのマクロについて **特に** 注意すべき点は、\n"
"符号なしの型に変換に変換する *どの* マクロも、負値を渡したときに例外が発生しないということです。\n"
"（驚くべきことに[バグではありません][bug]。）\n"
"`NUM2CHR()` にはもう2つ妙なところがあります。\n"
"変換前の値が _int_ には大きすぎるときに `RangeError` のみ生じることと、\n"
"文字列を渡したときに `TypeError` を発生させず最初の文字の数値を返すということです。\n"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:192
#, no-wrap
msgid ""
"If you know that the conversion is safe, you should prefer the macros from the\n"
"previous sections as they skip the range checks.\n"
msgstr ""
"変換が安全だとわかっていれば、\n"
"前の節のマクロのほうを使うべきです。\n"
"なぜなら範囲の確認を省けるためです。\n"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:194
#, no-wrap
msgid "[bug]: https://bugs.ruby-lang.org/issues/9089\n"
msgstr "[bug]: https://bugs.ruby-lang.org/issues/9089\n"

#. type: Title ####
#: _posts/2010-01-01-c.markdown:195
#, no-wrap
msgid "String"
msgstr "String"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:203
#, no-wrap
msgid ""
"Ruby's `String` kinda corresponds to C's `char*`. The simplest macro is\n"
"`StringValueCStr()` which returns a null-terminated `char*` for a `String`. The\n"
"problem here is that a Ruby `String` _might contain nulls_ - in which case\n"
"`StringValueCStr()` will raise an `ArgumentError`! Instead you can use the\n"
"macros `StringValuePtr()` and `RSTRING_LEN()` to get a (possibly unterminated)\n"
"`char*` and the string's length as a `long`.\n"
msgstr ""
"Rubyの `String` はだいたいCの `char*` に対応します。\n"
"もっとも簡素なマクロは `StringValueCStr()` です。\n"
"このマクロは `String` からnull終端付きの `char*` を返します。\n"
"ただしこれには問題があって、Rubyの `String` が *nullを含むかもしれません*。\n"
"そのような場合には `StringValueCStr()` は `ArgumentError` を発生させます！\n"
"その代わりに `StringValuePtr()` マクロと `RSTRING_LEN()` マクロを使えば、それぞれ\n"
"（終端が付いていない可能性がある） `char*` とその長さの `long` 値を取得できます。\n"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:211
#, no-wrap
msgid ""
"Conversely, if you have a null-terminated `char*`, you can use\n"
"`rb_str_new_cstr()` to create a Ruby `String`. And if you want your `String` to\n"
"contain nulls, use `rb_str_new()` which takes a `char*` and the string's length\n"
"(as a `long`). The encodings of these strings will be `ASCII-8BIT`, which is\n"
"often undesirable in Ruby. You can pass the string `VALUE` to\n"
"`rb_str_export_locale()` to get a new `VALUE` with your locale's\n"
"encoding[^wchar].\n"
msgstr ""
"逆に、null終端付きの `char*` からRubyの `String` への変換には、\n"
"`rb_str_new_cstr()` が使えます。\n"
"そして、もし `String` にnullを含めたいときは、\n"
"`rb_str_new()` を使います。\n"
"`rb_str_new()` は `char*` と文字列の長さ（型は `long`）を引数に取ります。\n"
"これらの文字列のエンコーディングは `ASCII-8BIT` なのですが、\n"
"Ruby側のコードで望んだものではないこともあります。\n"
"そんなときは文字列の `VALUE` を `rb_str_export_locale()` に渡して、\n"
"自分のロケールのエンコーディングでの `VALUE` を取得することができます。\n"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:218
#, no-wrap
msgid ""
"If you want to build more complex strings, you can do so using the `printf`-like\n"
"function `rb_sprintf()`. This accepts all of the usual conversion specifiers,\n"
"but also accepts an API-defined specifier `PRIsVALUE` which takes a\n"
"corresponding `VALUE` argument. This conversion specifier substitutes a string\n"
"by sending the object `to_s`. You can substitute the result of `inspect` instead\n"
"by adding the `+` flag.\n"
msgstr ""
"もっと複雑な文字列を構築したければ、\n"
"`printf` のような関数 `rb_sprintf()` でできます。\n"
"この関数では通常の変換での全ての指定子だけではなく、\n"
"APIで定義された指定子 `PRIsVALUE` も使えます。\n"
"`PRIsVALUE` は対応する `VALUE` を引数に取ります。\n"
"この変換指定子はオブジェクトに `to_s` メッセージを送って文字列にに置き換えます。\n"
"`+` フラグを加えることで `inspect` を使った結果の文字列に置き換えることもできます。\n"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:222
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/printf.h %}\n"
"{% endhighlight %}\n"
msgstr ""
"{% highlight c %}\n"
"{% include c/printf.h %}\n"
"{% endhighlight %}\n"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:227
#, no-wrap
msgid ""
"This custom specifier should work for any `printf`-like function in the API.\n"
"`PRIsVALUE` works by hijacking the `i` conversion specifier, so when printing\n"
"an `int` you should use `d` to ensure that Ruby doesn't think it's actually a\n"
"`VALUE`.\n"
msgstr ""
"この自前の指定子はAPIにあるあらゆる `printf` っぽい関数で使えるでしょう。\n"
"`PRIsVALUE` は `i` 変換指定子を乗っ取ることで実現されているので、\n"
"`int` を文字列にするときは `d` を使って、\n"
"Rubyに「それって実は `VALUE` なんじゃないか」と勘違いさせないようにするべきです。\n"

#. type: Title ####
#: _posts/2010-01-01-c.markdown:228
#, no-wrap
msgid "Symbol"
msgstr "Symbol"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:236
#, no-wrap
msgid ""
"The API defines a C type `ID` which corresponds to Ruby's `Symbol`. Just like\n"
"how Ruby passes around `Symbol`s as method or variable names, many API calls\n"
"that need a method or variable name use an `ID`. To convert between a `Symbol`\n"
"and an `ID` use the `SYM2ID()` and `ID2SYM()` macros. Instead of a `Symbol` you\n"
"may want to convert to/from a `char*` C string. To get an `ID` from a `char*`\n"
"use `rb_intern()` and for the reverse use `rb_id2name()`.\n"
msgstr ""
"APIではRubyの `Symbol` に対応するCの型 `ID` が定義されています。\n"
"Rubyが `Symbol` をメソッドや変数名として受け渡しするように、\n"
"多くのAPI呼び出しでメソッドや変数の名前を `ID` を使うようにしています。\n"
"`Symbol` と `ID` を変換するには、 `SYM2ID()` と `ID2SYM()` マクロを使います。\n"
"`Symbol` ではなくCの文字列 `char*` との双方向に変換したいときもあるでしょう。\n"
"`char*` から `ID` を取得するためには `rb_intern()` を、\n"
"その逆向きでは `rb_id2name()` を使います。\n"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:246
#, no-wrap
msgid ""
"Since many API functions require an `ID` and in many cases you will not have the\n"
"appropriate `ID` at hand, the API also defines a slew of functions that instead\n"
"take a `char*` and which do the `rb_intern()` call for you. Since these\n"
"functions are often more readable and the overhead of the `rb_intern()` call is\n"
"negligible, I have opted to use the `char*` versions of the API functions\n"
"wherever possible in this guide. If you find yourself frequently using a certain\n"
"C string in API calls, you may see some performance benefit by storing the `ID`\n"
"and using the `ID` versions of the functions (though you'll have to look these\n"
"up yourself in the Ruby headers).\n"
msgstr ""
"多くのAPI関数が `ID` を必要としていますが、\n"
"適切な `ID` が手元にないことも沢山あるでしょう。\n"
"そのため、代わりに `char*` を引数に取って自動で `rb_intern()` してくれる関数も沢山あります。\n"
"これらの関数はより読みやすく、 `rb_intern()` の呼び出しでのオーバーヘッドは無視できる程度なので、\n"
"この導入記事では可能な限り `char*` バージョンのAPI関数が使われる傾向にあります。\n"
"特定のCの文字列をAPIの呼出しで頻繁に使う場合は、\n"
"`ID` に変換して保管しておき、\n"
"`ID` バージョンの関数を使うことでいくらかのパフォーマンス向上を確かめられるかもしれません。\n"
"（Rubyのヘッダから自分で見つける必要がありますが。）\n"

#. type: Title ##
#: _posts/2010-01-01-c.markdown:247
#, no-wrap
msgid "Send"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:253
#, no-wrap
msgid ""
"This section contains API functions for directly calling Ruby methods. You\n"
"should prefer these functions to `rb_eval_string()` and the like whenever\n"
"possible. They are faster since they skip the parser and allow for some\n"
"compile-time checks.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:255
#, no-wrap
msgid "The easiest way to send an object a method looks like this:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:259
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/funcall.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:261
#, no-wrap
msgid "This is roughly equivalent to the Ruby code\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:265
#, no-wrap
msgid ""
"{% highlight ruby %}\n"
"{% include c/funcall.rb %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:270
#, no-wrap
msgid ""
"The first argument is the receiver. The next is the [`ID`](#symbol) for the\n"
"method name. The third argument is the number of method arguments, which is\n"
"needed since `rb_funcall()` is a varargs function. Then come the actual method\n"
"arguments.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:274
#, no-wrap
msgid ""
"Alternatively, you can use `rb_funcallv()` where the fourth argument is a\n"
"`VALUE*` pointing to a C array of arguments. This also has the variant\n"
"`rb_funcallv_public()` which is like `public_send` in Ruby.\n"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:275
#, no-wrap
msgid "Passing Blocks"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:279
#, no-wrap
msgid ""
"If you want to pass a `Proc` as the block to a method, that's easy. The function\n"
"is just like `rb_funcallv()` but with the proc on the end.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:283
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/proc.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:287
#, no-wrap
msgid ""
"If you don't have a proc for the block, you'll need to define a certain kind of\n"
"C function to represent the block. Then there's a different variant of\n"
"`rb_funcallv()` but with a couple extra arguments for the block:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:291
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/block.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:297
#, no-wrap
msgid ""
"The last argument to `rb_block_call()` is helpful for passing in values outside\n"
"the block function's scope, but in this example we don't need it (thus `nil`). I\n"
"also recommend against using the first argument to your block function unless\n"
"you're **sure** that only one value was yielded. You can always get all the\n"
"arguments from `argv`, so why not play it safe?[^break]\n"
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:298
#, no-wrap
msgid "Builtins"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:305
#, no-wrap
msgid ""
"Many of Ruby's built-in classes have API functions defined for their most useful\n"
"methods. Using them can save you from the verbosity of always using\n"
"`rb_funcall()` and can provide more compile-time checks. There are far too many\n"
"functions to list here, so I recommend checking them out in the header\n"
"`ruby/intern.h`.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:309
#, no-wrap
msgid ""
"Functions are generally named like `rb_(class)_(method)` and take at least one\n"
"`VALUE` argument (the receiver). E.g. `rb_ary_pop()` for `Array#pop`,\n"
"`rb_obj_dup()` for `Object#dup`, etc.\n"
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:310
#, no-wrap
msgid "Require"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:314
#, no-wrap
msgid ""
"The API can also load some Ruby code from a script. There's an equivalent to\n"
"`require`:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:318
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/require.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:321
#, no-wrap
msgid ""
"As with `require`, these could raise exceptions. Read the [next\n"
"section](#exceptions) for how to handle them.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:323
#, no-wrap
msgid "There are also functions for `load` if you want to load a script multiple times:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:327
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/load.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:331
#, no-wrap
msgid ""
"Just like [`load` in Ruby][rbload], these functions can wrap the loaded code in\n"
"an anonymous module to protect the global namespace. Just pass a nonzero value\n"
"for the second argument.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:333
#, no-wrap
msgid "[rbload]: http://www.ruby-doc.org/core/Kernel.html#method-i-load\n"
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:334
#, no-wrap
msgid "Exceptions"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:336
#, no-wrap
msgid "Raise"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:339
#, no-wrap
msgid "To raise an exception, use:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:343
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/raise.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:348
#, no-wrap
msgid ""
"The first and second arguments are the exception class and message&mdash;like\n"
"`raise` in Ruby. The big difference is that the message is a format string [just\n"
"like in `rb_sprintf()`](#string), letting you more easily build a useful\n"
"message.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:355
#, no-wrap
msgid ""
"You can also construct exception objects directly using `rb_exc_new_cstr`,\n"
"`rb_exc_new`, and `rb_exc_new_str`. All of these accept an exception class as\n"
"their first argument and then they work just like their [string](#string)\n"
"counterparts, constructing an exception using a null-terminated string,\n"
"non-null-terminated string, and a `String` object, resp. Then you can raise your\n"
"exception object with `rb_exc_raise`.\n"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:356
#, no-wrap
msgid "Rescue"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:361
#, no-wrap
msgid ""
"There are several ways to rescue exceptions using the API. All of them require\n"
"the code you're protecting to be in a function that takes and returns a single\n"
"`VALUE`.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:365
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/danger.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:369
#, no-wrap
msgid ""
"Unless you wanted to rescue a function of exactly this type, you will probably\n"
"need to make a wrapper function in this format that runs the desired code. The\n"
"way to access a rescued exception is also independent of the way it is rescued:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:373
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/handle.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:378
#, no-wrap
msgid ""
"`rb_errinfo()` essentially gives you the `VALUE` of Ruby's `$!` (which will be\n"
"`Qnil` if no exception occurred). Unlike in Ruby, you must manually clear the\n"
"exception after reading it[^clear]. Otherwise later API calls might read the old\n"
"value and think another exception has occurred.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:382
#, no-wrap
msgid ""
"Next we will go over several methods of rescuing; you can use whichever you\n"
"like, but I think that generally the right choice is determined by your\n"
"[use-case](#the-two-paths) of the API.\n"
msgstr ""

#. type: Title ####
#: _posts/2010-01-01-c.markdown:383
#, no-wrap
msgid "rb_rescue2"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:389
#, no-wrap
msgid ""
"If you're compiling a library to be loaded by Ruby, you have it easy. Any\n"
"exceptions raised in the API can be rescued as usual in your Ruby code. If you\n"
"want to rescue an exception in the API, you can use `rb_rescue2()` which is\n"
"similar to Ruby's `rescue`.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:393
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/rescue2.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:402
#, no-wrap
msgid ""
"The first two arguments are the function to protect and its argument, the next\n"
"two are the function to call if an exception is raised and its argument.\n"
"`rb_rescue2()` is a varargs function, so after that comes a list of the\n"
"exception classes you want to rescue. The last argument should always be `0` to\n"
"indicate the end of the class list. Like `rescue` in Ruby, any exceptions not in\n"
"this list will not be rescued. If you just want to rescue `StandardError` (like\n"
"a blank `rescue` in Ruby), you can use `rb_rescue()` which takes just the first\n"
"four arguments of `rb_rescue2()`.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:406
#, no-wrap
msgid ""
"The API does not provide an easy way to run different rescue code for different\n"
"exception classes as Ruby does. You'll need to rescue all the classes you want\n"
"at once and use some kind of switch to handle them separately.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:413
#, no-wrap
msgid ""
"The API also does not directly provide an equivalent to Ruby's `else` i.e. code\n"
"to run when _no_ exception was raised. One way to do this is using the return\n"
"value of `rb_rescue2()`. If no exception is raised, it returns the return value\n"
"of the first (dangerous) function, otherwise the return value of the second\n"
"(rescue) function. By having these return, say, `Qtrue` and `Qfalse` you can\n"
"detect which case you are in.\n"
msgstr ""

#. type: Title ####
#: _posts/2010-01-01-c.markdown:414
#, no-wrap
msgid "rb_protect"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:421
#, no-wrap
msgid ""
"If you're embedding the Ruby interpreter in C, you need to be _extremely\n"
"careful_ when calling API functions that could raise exceptions: **an uncaught\n"
"exception will segfault the VM and kill your program**. You could call\n"
"`rb_rescue2()` with `rb_eException`, but there's another approach for rescuing\n"
"all exceptions:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:425
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/protect.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:431
#, no-wrap
msgid ""
"Like `rb_rescue2()`, the first two arguments are for calling the function to\n"
"protect. However, like `rb_eval_string_protect()`, if an exception is raised\n"
"it returns `Qnil` and sets `state` to some nonzero value. If you want to\n"
"re-raise the exception, pass `state` to `rb_jump_tag()` (this also works for the\n"
"state from the other `*_protect()` functions).\n"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:432
#, no-wrap
msgid "Ensure"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:439
#, no-wrap
msgid ""
"`rb_ensure()` is similar to `rb_rescue()` except that it doesn't do anything\n"
"about exceptions and the second function is _always_ called after the first.\n"
"That may sound simple enough, but that means that if you want the usual `begin;\n"
"rescue; ensure; end` structure as in Ruby, you'll need another layer of\n"
"wrapping:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:443
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/ensure.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:448
#, no-wrap
msgid ""
"Like `ensure` in Ruby, the return value of `ensure_func()` is never used. If no\n"
"exception occurs, `rb_rescue()` will return the value of `begin_func()` which\n"
"returns the value of `dangerous_func()`. If an exception does occur,\n"
"`rb_rescue()` returns the value of `rescue_func()`.\n"
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:449
#, no-wrap
msgid "Definitions, Declarations"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:454
#, no-wrap
msgid ""
"So far we've been creating and modifying objects directly in the VM's memory,\n"
"but none of our API calls have had a visible effect _within the Ruby code_: a\n"
"`String` made with `rb_str_new_cstr()` can only be accessed from C by default.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:463
#, no-wrap
msgid ""
"There are a few ways to make things visible to Ruby but they all work the same\n"
"general way: by defining some name that Ruby can access e.g. a variable name, a\n"
"method name, etc. A general warning though: unlike Ruby, **the API lets you give\n"
"things invalid names**. Ruby will raise a `SyntaxError` or `NameError` if you\n"
"try to name a class `foo` (not constant) or an instance variable `bar` (no `@`),\n"
"but the API will happily create them. The API handles this by **not exposing\n"
"invalid names to Ruby**. Since that's probably not what you want, double check\n"
"the names you choose!\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:469
#, no-wrap
msgid ""
"Most of the API functions in this section correspond closely to metaprogramming\n"
"methods in Ruby. When you're trying to do something using the API, it can be\n"
"helpful to think about how you would do it in Ruby using only metaprogramming\n"
"method calls. For example, rather than `class Foo; def bar; end; end`, think\n"
"`Foo = Class.new; Foo.define_method(:bar) {}`.\n"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:470
#, no-wrap
msgid "Global Variables"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:473
#, no-wrap
msgid "The simplest way to deal with globals is:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:477
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/global.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:480
#, no-wrap
msgid ""
"If you're frequently accessing Ruby's globals, you can set up a `VALUE` which\n"
"will be automatically synchronized with one.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:484
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/global2.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:491
#, no-wrap
msgid ""
"The `VALUE` should be initialized before you create the global in Ruby and it\n"
"should be global in C as well&mdash;you don't want it to go out of scope while\n"
"Ruby is using it! For `rb_define_hooked_variable()`, you can pass `NULL` for the\n"
"getter/setter if you want to synchronize normally for that operation. Or you can\n"
"throw out `global` entirely with `rb_define_virtual_variable()` though of course\n"
"the getter and setter _must_ be defined in that case.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:495
#, no-wrap
msgid ""
"If you ever create a global `VALUE` in C which is _not_ exposed to Ruby, you\n"
"must tell the garbage collector about it to prevent it from being prematurely\n"
"cleaned up:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:499
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/gc.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:500
#, no-wrap
msgid "Class and Instance Variables"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:504
#, no-wrap
msgid ""
"Getting/setting instance variables is similar to the simple way of accessing\n"
"globals, but of course you need an object to get the variable from.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:508
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/ivar.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:511
#, no-wrap
msgid ""
"There isn't an automatic way to synchronize instance variables like you can with\n"
"globals.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:513
#, no-wrap
msgid "To iterate over all instance variables, use `rb_ivar_foreach`.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:516
#, no-wrap
msgid ""
"For class variables, the methods are `rb_cv_get()` and `rb_cv_set()` and of\n"
"course the first argument should be a class object.\n"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:517
#, no-wrap
msgid "Constants ####"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:520
#, no-wrap
msgid "Constants are defined similarly, but with the module to define them under:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:524
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/constant.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:528
#, no-wrap
msgid ""
"You undefine a constant by setting it to `Qundef`. Getting a constant's `VALUE`\n"
"is a little nuanced. The API function you call depends on what you want to\n"
"happen if the constant is _not_ defined in the module you specify:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:532
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/const_get.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:534
#, no-wrap
msgid "All of these API calls will get private constants too.\n"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:535
#, no-wrap
msgid "Modules and Classes"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:538
#, no-wrap
msgid "Defining modules is super easy.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:542
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/module.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:544
#, no-wrap
msgid "Classes work the same way but they also need a superclass.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:548
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/class.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:549
#, no-wrap
msgid "Methods"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:555
#, no-wrap
msgid ""
"Here's where it gets interesting. There are many kinds of API calls for defining\n"
"methods, but before you use any of them you'll need a C function that the method\n"
"calls. The function must return a `VALUE` and have one `VALUE` argument for the\n"
"receiver of the method. There are three ways you can define its other arguments:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:559
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/methodc.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:564
#, no-wrap
msgid ""
"So really the API only lets you define two types of methods: ones that take a\n"
"fixed number of arguments, and ones that slurp up all of their arguments. What\n"
"about all of Ruby's fancy argument features? Where are optional arguments,\n"
"options hashes, blocks, and all the mixtures of those?\n"
msgstr ""

#. type: Title ####
#: _posts/2010-01-01-c.markdown:565
#, no-wrap
msgid "Parsing Arguments"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:572
#, no-wrap
msgid ""
"Well, if you accept a variable number of arguments you could code all of that\n"
"logic yourself in the method, and make it _behave_ like it has a fancier method\n"
"definition in Ruby. Thankfully, the API has a shortcut for doing exactly that.\n"
"To use it, you should use the C array function definition, then you can pass\n"
"`argc` and `argv` along to:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:576
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/scan.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:581
#, no-wrap
msgid ""
"Here `fmt` is a format string describing how the method arguments would look in\n"
"Ruby. The string can have at most 6 characters, where each character describes a\n"
"different section of the arguments. The six sections and their corresponding\n"
"characters are (in order):\n"
msgstr ""

#. type: Bullet: '1. '
#: _posts/2010-01-01-c.markdown:588
#, no-wrap
msgid "The number of leading mandatory arguments: a digit\n"
msgstr ""

#. type: Bullet: '2. '
#: _posts/2010-01-01-c.markdown:588
#, no-wrap
msgid "The number of optional arguments: a digit\n"
msgstr ""

#. type: Bullet: '3. '
#: _posts/2010-01-01-c.markdown:588
#, no-wrap
msgid "A splatted argument: `*`\n"
msgstr ""

#. type: Bullet: '4. '
#: _posts/2010-01-01-c.markdown:588
#, no-wrap
msgid "The number of trailing mandatory arguments: a digit\n"
msgstr ""

#. type: Bullet: '5. '
#: _posts/2010-01-01-c.markdown:588
#, no-wrap
msgid "Keyword arguments: `:`\n"
msgstr ""

#. type: Bullet: '6. '
#: _posts/2010-01-01-c.markdown:588
#, no-wrap
msgid "A block argument: `&`\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:598
#, no-wrap
msgid ""
"Each section is optional, so you can leave out the characters for things you\n"
"don't need. Be aware that the parsing of the format string is greedy: `1*`\n"
"describes a method with one mandatory argument and a splat. If you want one\n"
"_optional_ argument and a splat you must specify `01*`. Following the format\n"
"string, you must pass a `VALUE*` for each _Ruby_ argument. The number of\n"
"pointers passed should equal the \"total\" of the six sections, though you can\n"
"pass `NULL` for an argument you don't care about. For example the format string\n"
"`21*&` should have 5 `VALUE*`s passed (2 mandatory, 1 optional, 1 splatted, 1\n"
"block).\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:601
#, no-wrap
msgid ""
"`rb_scan_args()` unpacks `argv` using the `VALUE*`s you pass it and will\n"
"raise a fitting exception if the wrong number of arguments were passed.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:605
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/methodex.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:609
#, no-wrap
msgid ""
"You can also use the return value of `rb_scan_args()` to determine how the\n"
"function was called. It returns the number of arguments that were passed in\n"
"Ruby.\n"
msgstr ""

#. type: Title ####
#: _posts/2010-01-01-c.markdown:610
#, no-wrap
msgid "Handling Blocks"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:613
#, no-wrap
msgid "There are two ways to check if your C method has been called with a block:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:617
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/checkblock.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:622
#, no-wrap
msgid ""
"There are two ways to capture the block as a proc. If you're using\n"
"`rb_scan_args()` for your method arguments, just include `&` in your format\n"
"string to get it. If you aren't using `rb_scan_args()`, there's an API call\n"
"equivalent to `Proc.new` which converts the method's block to a proc:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:625
#, no-wrap
msgid ""
"    VALUE block;\n"
"    block = rb_block_proc();\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:627
#, no-wrap
msgid "If you don't want to capture the block, there are a few ways to yield to it:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:631
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/yield.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:634
#, no-wrap
msgid ""
"There's also `rb_yield_values2()` which is like `rb_yield_values()` but instead\n"
"of varargs the second argument is a `VALUE*`[^yield].\n"
msgstr ""

#. type: Title ####
#: _posts/2010-01-01-c.markdown:635
#, no-wrap
msgid "Super"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:638
#, no-wrap
msgid "You might want to call `super` in your method.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:642
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/super.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:648
#, no-wrap
msgid ""
"Unlike in Ruby `rb_call_super()` will **not** implicitly pass along the method\n"
"arguments to the super if you give it no arguments. You must explicitly pass the\n"
"correct `argc` and `argv` (it _does_ automatically pass `self`). For that reason\n"
"I recommend using the C array style of method definition if you want to use\n"
"`rb_call_super()`.\n"
msgstr ""

#. type: Title ####
#: _posts/2010-01-01-c.markdown:649
#, no-wrap
msgid "Definition"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:655
#, no-wrap
msgid ""
"Setting up the C function is the hard part, now it's easy to define the method\n"
"in Ruby. Every API call to create a method takes at least the method name\n"
"(`char*`), a pointer to your C function, and an `argc` describing its arguments.\n"
"`argc` should be:\n"
msgstr ""

#. type: Bullet: '1. '
#: _posts/2010-01-01-c.markdown:660
#, no-wrap
msgid ""
"For a fixed number of arguments, the number of arguments (not counting the\n"
"receiver)\n"
msgstr ""

#. type: Bullet: '2. '
#: _posts/2010-01-01-c.markdown:660
#, no-wrap
msgid "For a variable number of arguments in a C array, `-1`\n"
msgstr ""

#. type: Bullet: '3. '
#: _posts/2010-01-01-c.markdown:660
#, no-wrap
msgid "For a variable number of arguments in a Ruby Array, `-2`\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:662
#, no-wrap
msgid "Everything is pretty self-explanatory from there:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:666
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/methodr.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:670
#, no-wrap
msgid ""
"There's also a shortcut for defining a method in a module _and_ its\n"
"singleton class. This is used a lot in `Math`, for example, letting you `include\n"
"Math` to avoid typing `Math.` before every method call.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:674
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/modulefunc.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:675
#, no-wrap
msgid "Other Stuff"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:678
#, no-wrap
msgid "Some simple API functions for class/method definitions:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:682
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/etc.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:683
#, no-wrap
msgid "Data"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:690
#, no-wrap
msgid ""
"By now you should be able to create and manipulate Ruby classes using the API,\n"
"but how can you create a Ruby class that encapsulates data from the C world? If\n"
"your data can be naturally translated into `VALUE`s it's easy: convert and\n"
"assign to instance variables as usual. But what if your data have no Ruby analog\n"
"(e.g. data structures defined by some C library)?\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:697
#, no-wrap
msgid ""
"The API lets you encapsulate C data by creating a `VALUE` of the desired class\n"
"and then storing a `void*` pointing to the C data inside the Ruby object. Then\n"
"whenever you need access to the C data, you can unpack the pointer and cast it\n"
"back to the correct type. But where does this encapsulation occur? Let's answer\n"
"that question with a question: what happens when you tell Ruby to create an\n"
"object using `new`? Basically this:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:701
#, no-wrap
msgid ""
"{% highlight ruby %}\n"
"{% include c/new.rb %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:707
#, no-wrap
msgid ""
"Before calling the _instance method_ `initialize` that we know so well, `new`\n"
"first calls the _class method_ `allocate` to actually create the object. That is\n"
"the method you'll need to define if you want your objects to wrap C data. The\n"
"following example creates a class `Foo` which wraps an `int` that can be set\n"
"by `initialize`:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:711
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/wrap.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:719
#, no-wrap
msgid ""
"In most cases you'll probably be wrapping something more complicated (like a\n"
"`struct`), but the principles will be the same. After allocating the C data, we\n"
"use the `TypedData_Wrap_Struct()`[^oldwrap] macro to wrap the pointer in a\n"
"`VALUE`. This wrapping takes three arguments: the class of the object (`self`\n"
"because we're in a class method), a pointer to a struct, and the data pointer to\n"
"be wrapped. The tricky part is the struct pointer; it provides additional\n"
"information for internal use by Ruby:\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:736
#, no-wrap
msgid ""
"`wrap_struct_name` is a string used by Ruby to identify your type. It doesn't\n"
"really matter what it is as long as it's sensible and unique\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:736
#, no-wrap
msgid ""
"`function` is a struct containing several function pointers for use by the\n"
"garbage collector\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:736
#, no-wrap
msgid ""
"`dmark` will be described later, but as long your C data doesn't point to any\n"
"Ruby objects you don't need it\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:736
#, no-wrap
msgid ""
"`dfree` will be called when your object is destroyed and should free all\n"
"memory allocated by the object\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:736
#, no-wrap
msgid ""
"`dsize` is called by Ruby to check how much memory your object is taking up.\n"
"It _can_ be omitted, but it's polite to include it\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:736
#, no-wrap
msgid ""
"`data` can point to arbitrary data. Think of it as wrapping C data at a class\n"
"level. Also not manadatory\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:736
#, no-wrap
msgid ""
"`flags` lets you enable additional optimizations when your objects are\n"
"garbage collected. As long as your `dfree` function doesn't unlock the\n"
"[GVL](#c-in-ruby-threads) (why would you do that???) you can safely set it to\n"
"`RUBY_TYPED_FREE_IMMEDIATELY` for a slight performance improvement\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:741
#, no-wrap
msgid ""
"If you don't set some of these members, you should zero them out so that Ruby\n"
"doesn't accidentally read garbage data. That's why I used C99's [designated\n"
"initializer][desinit] syntax in the example above: any members you omit will be\n"
"safely cleared by the compiler.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:743
#, no-wrap
msgid "[desinit]: https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:747
#, no-wrap
msgid ""
"`VALUE`s that wrap C data will have type `T_DATA` with respect to the [`TYPE()`\n"
"macro](#value). This helps ensure a clear separation between native Ruby objects\n"
"and those wrapping C data.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:752
#, no-wrap
msgid ""
"Once you've done all of that work to wrap up the C data, getting it back out is\n"
"easy: `TypedData_Get_Struct()` takes the object to unwrap, the C type of the\n"
"underlying data, the same struct pointer as before, and the pointer to assign\n"
"the data to.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:758
#, no-wrap
msgid ""
"This separation of allocation and initialization doesn't jive with [RAII][raii],\n"
"so if you're using C++ you will probably want to use [placement new][place] when\n"
"wrapping data. If you're having trouble splitting up allocation and\n"
"initialization, you can just wrap your data in a `struct` and do the _actual_\n"
"allocation in `initialize`.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:761
#, no-wrap
msgid ""
"[raii]: http://wikipedia.org/wiki/Resource_Acquisition_Is_Initialization\n"
"[place]: http://en.cppreference.com/w/cpp/language/new#Allocation\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:769
#, no-wrap
msgid ""
"In simple cases (like the previous example) you can make your code a little less\n"
"verbose. If the function to free your data just calls `free()` as in the\n"
"example, you can pass `RUBY_DEFAULT_FREE` for `dfree` and Ruby will\n"
"free it for you (**don't** use `NULL` unless you like memory leaks). Similarly,\n"
"if your allocation is just a `malloc()` as in the example, the macro\n"
"`TypedData_Make_Struct()` does the allocation for you _and_ wraps it. We could\n"
"shorten the previous example as such:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:773
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/makestruct.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:774
#, no-wrap
msgid "Marking"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:783
#, no-wrap
msgid ""
"That `dmark` pointer in the type structure above is the pointer to your object's\n"
"\"mark function\". This is so named because of the garbage collector's \"mark and\n"
"sweep\" algorithm. The basic idea behind mark and sweep is that when the garbage\n"
"collector needs to free up memory, it performs two passes: the first (mark) pass\n"
"iterates through every _referenced_ Ruby object and marks it as active, then the\n"
"second (sweep) pass iterates through every _allocated_ Ruby object and frees the\n"
"ones that haven't been marked active.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:793
#, no-wrap
msgid ""
"This is relevant to wrapping C data because it's possible that you might wrap a\n"
"C `struct` which contains a Ruby `VALUE`&mdash;which the garbage collector is\n"
"responsible for cleaning up. Since the garbage collector is only aware of\n"
"`VALUE`s referenced _by Ruby_ (not by C pointers), it won't be able to mark the\n"
"referenced `VALUE` as active. The result is that as soon as the garbage\n"
"collector needs to free up some memory, your C data is going to end up with a\n"
"reference to a nonexistent Ruby object. Note that this kind of wrapping of Ruby\n"
"data inside C data is a really bad idea, precisely because of this kind of\n"
"issue. But if you really must...\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:797
#, no-wrap
msgid ""
"In the following example, we'll wrap a C `struct` which contains a `VALUE`. The\n"
"mark function has the same signature as the free function and all it has to do\n"
"is mark any `VALUE`s in the `struct`:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:801
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/mark.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:806
#, no-wrap
msgid ""
"If your `struct` contains a pointer to a C array of `VALUE`s, you can instead\n"
"use `rb_gc_mark_locations()` which takes two arguments: the pointers to the\n"
"start and end of the array (the end being equal to the starting pointer plus the\n"
"array length).[^maybe]\n"
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:807
#, no-wrap
msgid "Threading"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:809
#, no-wrap
msgid "Ruby in C Threads"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:819
#, no-wrap
msgid ""
"If you're making a lot of API calls and running a lot of Ruby code from C, at\n"
"some point you might catch yourself thinking, \"I'm running all of these slow\n"
"Ruby methods using the API. Maybe I can thread things to keep my code fast!\"\n"
"That's a reasonable thought, but when you act on it keep in mind that **the Ruby\n"
"VM is not at all thread safe**. Ideally, all of your API code should run in a\n"
"single thread. If not, you'll probably need to wrap every API call with a locked\n"
"mutex to make sure that you never ever have multiple threads interacting with\n"
"the API at the same time.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:822
#, no-wrap
msgid ""
"If you just want to create normal Ruby `Thread`s using the API (and don't mind\n"
"the GVL, as described in the next section), there's an easy way to do that:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:826
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/thread.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:829
#, no-wrap
msgid ""
"Other `Thread` functions are in `ruby/intern.h` (but there's always\n"
"`rb_funcall()` for everything else).\n"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:830
#, no-wrap
msgid "C in Ruby Threads"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:838
#, no-wrap
msgid ""
"On the other hand, if you expose some heavy C code to Ruby with the API (if\n"
"you're writing an extension that wraps a C library, for example), you should\n"
"spend some time thinking about a nasty thing called the global VM lock (GVL).\n"
"Because most of the API is not `Thread` safe, the GVL locks down almost all Ruby\n"
"code so that only a single `Thread` can run at a time. This is the reason why\n"
"you'll often hear people say that `Thread` does not allow true parallelism.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:850
#, no-wrap
msgid ""
"The VM also applies the GVL to any C code you expose to Ruby. That's why you can\n"
"use the API without worrying about it exploding when someone calls your C code\n"
"from inside a `Thread`. The downside of this is that if your C code takes a\n"
"while to run, you won't see any performance benefit from calling it in a\n"
"`Thread` because **it will block all other threads** while it runs. But the GVL\n"
"is only needed to protect API calls. If you have some C code that doesn't use\n"
"the API, you can tell the VM to release the GVL before running your code in a\n"
"thread and to reacquire it when it completes, allowing for true parallelism.\n"
"Locking and unlocking the GVL does carry a performance hit, so only resort to\n"
"this if you notice that you're having significant problems due to blocked\n"
"threads.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:854
#, no-wrap
msgid ""
"The code to do this is considered so fancy by the Ruby developers that you\n"
"actually need to include another header to use it. First we'll look at the\n"
"slightly simpler way to release the GVL:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:858
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/gvl2.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:861
#, no-wrap
msgid ""
"Since the function that is run without the GVL gets and returns data using\n"
"`void*`, you may want to define a `struct` for passing data via pointers.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:866
#, no-wrap
msgid ""
"If you unlock the GVL as above you will find that while your code does run\n"
"in parallel, it can't be interrupted (by signals, `Thread.kill`, etc.)! To\n"
"allow for that you must pass an unblocking function using the last two\n"
"arguments:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:870
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/gvl.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:875
#, no-wrap
msgid ""
"The unblocking function is called in the event of an interrupt. To make it work,\n"
"you will probably need to pass a pointer to both functions that can be used to\n"
"communicate an interrupt from one to the other. The interrupted function should\n"
"perform any necessary cleanup before returning early.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:880
#, no-wrap
msgid ""
"Alternatively, if the interrupted function doesn't _need_ to perform any special\n"
"cleanup, you can use the built in unblocking function `RUBY_UBF_IO`[^ubf]\n"
"(which ignores the unblocking argument). That simply forwards the interrupt to\n"
"the running thread.[^int]\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:884
#, no-wrap
msgid ""
"If you go through all of that effort to release the GVL only to find that you\n"
"need to make an API call in your unlocked thread, there's a function to\n"
"temporarily reacquire the GVL:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:888
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/with_gvl.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:889
#, no-wrap
msgid "See Also"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:891
#, no-wrap
msgid "extension.rdoc"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:897
#, no-wrap
msgid ""
"Ruby does have [official API documentation][readme]. It's a bit spotty and has\n"
"some poor recommendations (in my opinion), but it is also a little more\n"
"exhaustive on certain topics. In many cases this is because I intentionally\n"
"skipped something that I either found not useful or better documented elsewhere.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:899
#, no-wrap
msgid "[readme]: https://github.com/ruby/ruby/blob/master/doc/extension.rdoc\n"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:900
#, no-wrap
msgid "Headers"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:910
#, no-wrap
msgid ""
"I think some of the handiest resources are the Ruby headers themselves. The full\n"
"API (i.e. everything you get by including `ruby.h`) easily consists of a\n"
"thousand functions, macros, constants, and globals&mdash;most of which have\n"
"never been documented. However _most_ things are reasonably named and you should\n"
"be able to figure out what they do from the header. Most everything you need\n"
"should be in the headers `ruby/ruby.h` and `ruby/intern.h`. The former has all\n"
"of the VM and metaprogramming functions, the latter has all of the functions for\n"
"interacting with Ruby's built in classes.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:914
#, no-wrap
msgid ""
"There are also some headers _not_ pulled in by `ruby.h` which you can include to\n"
"get additional API functionality. Maybe one day I'll write another section to\n"
"this guide going over them:\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:923
#, no-wrap
msgid "`ruby/debug.h` (experimental) functions for profiling and tracing code\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:923
#, no-wrap
msgid "`ruby/encoding.h` functions for working with string encodings\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:923
#, no-wrap
msgid "`ruby/io.h` additional functions for Ruby's IO class\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:923
#, no-wrap
msgid "`ruby/re.h` additional functions for Ruby's Regexp class\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:923
#, no-wrap
msgid "`ruby/thread.h` functions for working with the [GVL](#c-in-ruby-threads)\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:923
#, no-wrap
msgid ""
"`ruby/version.h` functions for version introspection. Do not use this as\n"
"feature-detection code!\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:923
#, no-wrap
msgid "`ruby/vm.h` (experimental) functions for VM control\n"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:924
#, no-wrap
msgid "Source"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:928
#, no-wrap
msgid ""
"If you find some function in the header that isn't documented anywhere, your\n"
"next stop should be the Ruby source code.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:932
#, no-wrap
msgid ""
"{% highlight shell_session %}\n"
"$ git clone https://github.com/ruby/ruby.git\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:937
#, no-wrap
msgid ""
"When reading through the source code, always keep the headers at hand: there are\n"
"lots of really useful functions in there that _look_ like they should be in the\n"
"API, but actually aren't. In most cases there should be an API function\n"
"elsewhere that wraps the call to the useful function.\n"
msgstr ""

#. type: YAML Front Matter: title
#: _posts/2010-01-01-c.markdown:938 _posts/2014-01-01-examples.markdown:1
#, no-wrap
msgid "Examples"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:942
#, no-wrap
msgid ""
"Head over to the [Examples](../examples) page for short, compilable examples of\n"
"the API in action.\n"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:943
#, no-wrap
msgid "Contribute"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:949
#, no-wrap
msgid ""
"Now that you've finished reading my guide, did you notice something significant\n"
"that I left out? Did I make some stupid mistake? Check out the [source][gh] for\n"
"this site on Github and you can report issues, submit pull requests, and\n"
"download all of the code examples.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:951
#, no-wrap
msgid "[gh]: https://github.com/silverhammermba/emberb\n"
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:952 _posts/2012-01-01-embed.markdown:123
#: _posts/2013-01-01-extend.markdown:128
#, no-wrap
msgid "Footnotes"
msgstr "脚註"

#. type: Plain text
#: _posts/2010-01-01-c.markdown:958
#, no-wrap
msgid ""
"[^intern]: That's a blatant lie. The API _definitely_ lets you mess around\n"
"           with the internal data structures of objects (look for things with\n"
"           names starting with capital R). But it's generally not a good idea\n"
"           and not necessary.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:963
#, no-wrap
msgid ""
"[^undef]: There's also `Qundef` representing an undefined value, but\n"
"          this has no Ruby equivalent and is [rarely](#handling-blocks)\n"
"          [used](#constants-1). In fact, outside of those rare occassions,\n"
"          `Qundef` can segfault the VM if Ruby was expecting a normal `VALUE`.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:966
#, no-wrap
msgid ""
"[^wrap]: There's also `rb_eval_string_wrap()` which _should_ be useful, but is\n"
"         actually the same as `rb_eval_string_protect()` due to a [bug][bug2].\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:969
#, no-wrap
msgid ""
"[^chr]: There is a `CHR2FIX()` macro, but in my tests this sometimes gave\n"
"        unexpected results. `LONG2FIX()` should work.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:973
#, no-wrap
msgid ""
"[^wchar]: I don't know what the best way is to handle `wchar_t`. In my tests I had\n"
"          some success just treating them as `char`s, but I think that may have\n"
"          been a happy accident, and could certainly fail on different platforms.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:978
#, no-wrap
msgid ""
"[^clear]: The documentation [states][control] that \"You have to clear the error\n"
"          info [when] ignoring the caught exception\" during `rb_protect`. But I\n"
"          can't find any documentation of when it would be cleared for\n"
"          you&mdash;it seems like you _always_ have to clear it.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:981
#, no-wrap
msgid ""
"[^yield]: And there's `rb_yield_block()` which takes two unused arguments and is\n"
"          never called by anything in Ruby. Odd.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:985
#, no-wrap
msgid ""
"[^break]: The documentation [mentions][control] `rb_iter_break()` and\n"
"          `rb_iter_break_value()` for breaking out of a block, but can't you\n"
"          just return early? I can't think of a use-case for these.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:991
#, no-wrap
msgid ""
"[^int]: There is also the function `rb_thread_call_without_gvl2()`. The\n"
"        documentation in `thread.c` says that if it \"detects interrupt, it\n"
"        returns immediately,\" but I'm not sure what this means. If the\n"
"        unblocking function doesn't kill the thread, it still waits for the\n"
"        thread to finish on its own before returning.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:994
#, no-wrap
msgid ""
"[^ubf]: You can also use `RUBY_UBF_PROCESS`, but this seems to be a leftover\n"
"        from deprecated code and has the exact same effect.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:999
#, no-wrap
msgid ""
"[^oldwrap]: The `TypedData*` macros are the preferred way to wrap data since\n"
"            Ruby 1.9.2. If you're using an older version of Ruby you can check\n"
"            out an older version of this guide on Github to see how it used to\n"
"            be done.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:1002
#, no-wrap
msgid ""
"[^maybe]: There's also the enigmatically named `rb_gc_mark_maybe()`, but I'm not\n"
"          sure when it is needed.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:1004
#, no-wrap
msgid "[^tdata]: Or use `T_DATA` if the object [wraps a C pointer](#data).\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:1006
#, no-wrap
msgid ""
"[control]: https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-Control+Structure\n"
"[bug2]: https://bugs.ruby-lang.org/issues/10466\n"
msgstr ""

#. type: Title ##
#: _posts/2012-01-01-embed.markdown:1 _posts/2014-01-01-examples.markdown:6
#, no-wrap
msgid "Running Ruby in C"
msgstr "CでRubyを実行する"

#. type: Title ##
#: _posts/2012-01-01-embed.markdown:6 _posts/2013-01-01-extend.markdown:6
#, no-wrap
msgid "Compiling"
msgstr "コンパイルする"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:12
#, no-wrap
msgid ""
"Embedding Ruby requires one header `ruby.h`, which includes a platform-specific\n"
"header `ruby/config.h`. You will probably need to tell your compiler about the\n"
"include paths for these headers. You will also need to link with the Ruby lib.\n"
"On my machine, my minimal compiler options are\n"
msgstr ""
"Rubyを組込むには `ruby.h` という1つのヘッダファイルが必要です。\n"
"このファイルはプラットフォーム固有のヘッダである `ruby/config.h` を含めます。\n"
"場合によってはコンパイラにヘッダファイルの含めるファイルパスを指定する必要があります。\n"
"Rubyライブラリと接続する必要もあります。\n"
"私の環境では、最小のコンパイラオプションは以下のようになります。\n"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:16
#, no-wrap
msgid ""
"{% highlight shell_session %}\n"
"$ gcc -I/usr/include/ruby-{{ site.rbversion }}.0 -I/usr/include/ruby-{{ site.rbversion }}.0/x86_64-linux -lruby\n"
"{% endhighlight %}\n"
msgstr ""
"{% highlight shell_session %}\n"
"$ gcc -I/usr/include/ruby-{{ site.rbversion }}.0 -I/usr/include/ruby-{{ site.rbversion }}.0/x86_64-linux -lruby\n"
"{% endhighlight %}\n"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:19
#, no-wrap
msgid ""
"Though, if available, you should really use `pkg-config` to get the appropriate\n"
"options for your distribution:\n"
msgstr ""
"しかしもし可能であれば、ぜひとも `pkg-config` を使って、\n"
"各々のディストリビューションに適したオプションが得られるようにするべきです。\n"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:23
#, no-wrap
msgid ""
"{% highlight shell_session %}\n"
"$ pkg-config --cflags --libs ruby-{{ site.rbversion }}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Title ##
#: _posts/2012-01-01-embed.markdown:24
#, no-wrap
msgid "Startup, Teardown"
msgstr "起動と終了"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:29
#, no-wrap
msgid ""
"Including the Ruby interpreter in your C/C++ program is pretty simple. Just\n"
"include the header, call a startup function in `main` before you use the API,\n"
"and a cleanup function after you're done:\n"
msgstr ""
"RubyインタプリタをCやC++のプログラムに含めることはとても簡単です。\n"
"ヘッダーを含めて、\n"
"APIを使用する前にインタプリタを立ち上げるための関数を `main` で呼び、\n"
"そして完了後に後片付けをする関数を呼べばよいのです。\n"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:33
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include embed/simple.c %}\n"
"{% endhighlight %}\n"
msgstr ""
"{% highlight c %}\n"
"{% include embed/simple.c %}\n"
"{% endhighlight %}\n"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:38
#, no-wrap
msgid ""
"If the VM fails to start during `ruby_init()` it will print an error and exit\n"
"your program! If you would rather have a softer error, you can instead call\n"
"`ruby_setup()` which returns a nonzero value if a failure occurred\n"
"(unfortunately it is not clear how to get a message for the error[^err]).\n"
msgstr ""
"`ruby_init()` の最中にVMが実行に失敗したら、\n"
"エラーを表示してプログラムが終了してしまいます！\n"
"もっと柔軟にエラーを出したいときは、\n"
"代わりに失敗したときにゼロではない値を返す\n"
"`ruby_setup()` を使いましょう（運が悪いことに、\n"
"この場合のエラーメッセージの出しかたはよくわかっていません[^err]）。\n"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:43
#, no-wrap
msgid ""
"If an error occurs during `rb_cleanup()`, it returns a nonzero\n"
"value&mdash;otherwise it returns the argument you passed it. This allows a\n"
"little shortcut for returning an error status if the cleanup fails (as\n"
"demonstrated in the previous example).\n"
msgstr ""
"`rb_cleanup()` のさなかにエラーが発生したときは、\n"
"ゼロではない値を返します。\n"
"もしエラーが発生しなければ、渡した引数が返ります。\n"
"この仕様により、後片付けに失敗したときのエラーステータスを返す部分が少し短く書けます（先の例のように）。\n"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:52
#, no-wrap
msgid ""
"_Technically_ you don't have to call `ruby_init`/`ruby_setup` in `main`, but the\n"
"Ruby VM assumes that all future Ruby code will be run from the same stack frame\n"
"or a lower one (for garbage collection purposes). The easiest way to ensure this\n"
"is to do set up at the top-level of your program, though other approaches could\n"
"work. But it would be a bad idea, for example, to init Ruby in some\n"
"deeply-nested function, pop a bunch of stack frames, and then run a bunch of\n"
"Ruby code.\n"
"{: .alert .alert-danger}\n"
msgstr ""
"_技術的には_ `main` で `ruby_init` や `ruby_setup` を呼ぶ必要はありません。\n"
"しかし、RubyのVMは以降全てのRubyのコードが同じかこれより低層のスタックフレームから\n"
"実行されることを仮定しています（ガベージコレクションのためです）。\n"
"他の方法でも動くにせよ、\n"
"このことを確証する最も簡単な方法がプログラムのトップレベルで立ち上げを行うことなのです。\n"
"例えば深く入れ子になった関数でRubyを初期化して、沢山のスタックフレームを立ち上げ、\n"
"そして沢山のRubyのコードを実行するようなことはよくありません。\n"
"{: .alert .alert-danger}\n"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:58
#, no-wrap
msgid ""
"During cleanup, the VM might evaluate more Ruby code (if you passed a block to\n"
"`at_exit`, for example) which could raise an exception. `ruby_cleanup()` handles\n"
"these by returning a nonzero value and printing an error message. If you instead\n"
"call `ruby_finalize()` they will be raised normally (see the section on\n"
"[Exceptions](../c#rescue) for how to handle them).\n"
msgstr ""
"後片付けをするときにも、VMはRubyのコードを評価するかもしれません（`at_exit` にブロックを渡したときなど）。\n"
"そしてそのときに例外が発生する可能性があります。\n"
"`ruby_cleanup()` はこのような例外が発生したときに、\n"
"ゼロではない値を返してエラーメッセージを表示することで制御します。\n"
"代わりに `ruby_finalize()` を呼ぶと、通常通り例外を発生させます。\n"
"（制御方法については[Exceptions](../c#rescue)節を参照）\n"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:60
#, no-wrap
msgid "Here's an alternative example:\n"
msgstr "別の例はこちらです。\n"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:64
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include embed/advanced.c %}\n"
"{% endhighlight %}\n"
msgstr ""
"{% highlight c %}\n"
"{% include embed/advanced.c %}\n"
"{% endhighlight %}\n"

#. type: Title ###
#: _posts/2012-01-01-embed.markdown:65
#, no-wrap
msgid "Limitations"
msgstr "制約"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:73
#, no-wrap
msgid ""
"Other than the stack frame warning above, there is another limitation: you only\n"
"get one Ruby VM per process. The startup/teardown might make it look like you\n"
"can keep on destroying and rebuilding the VM over and over again, but\n"
"`ruby_cleanup` only makes sure that your Ruby code is all cleaned up and done.\n"
"It doesn't fully clean up the VM state such that it is ready to be\n"
"re-initialized: if you call `ruby_init` again, it will fail.\n"
msgstr ""
"上記のスタックフレームの警告以外にも制約があります。\n"
"1つのプロセスに1つだけRubyのVMを動かせます。\n"
"起動と終了の方法を見ると、何度でもVMの破壊と創造を繰り返せるような気がしてくるかもしれませんが、\n"
"`ruby_cleanup` はRubyのコードが全ての後片付けが完了したことだけを確認します。\n"
"VMの状態を再度初期化できるような状態までは後片付けしません。\n"
"もう一度 `ruby_init` を呼び出すと、実行に失敗してしまうでしょう。\n"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:76
#, no-wrap
msgid ""
"If for some reason you need multiple Ruby VMs in your program, you will need to\n"
"spin them off in multiple processes to bypass this limitation.\n"
msgstr ""
"何かかの理由があってプログラムで複数のRubyのVMが必要になったら、\n"
"この制約を回避するために複数のプロセスに小分けにしなければいけません。\n"

#. type: Title ##
#: _posts/2012-01-01-embed.markdown:77
#, no-wrap
msgid "Tweaking the VM"
msgstr "VMを設定する"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:82
#, no-wrap
msgid ""
"You now have a bare-bones Ruby VM running, but you may want to set up a little\n"
"more stuff before you start running Ruby code. To set the name of the Ruby\n"
"script (e.g. `$0`) for error messages and such, use\n"
msgstr ""
"これでRubyのVMの実行の骨子を会得しました。\n"
"でも、Rubyのコードの実行に先駆けてもう少し設定したいことがあるかもしれません。\n"
"エラーメッセージとかのためにRubyのスクリプトの名前（例：`$0`）を設定したいときは、\n"
"以下のようにします。\n"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:86
#, no-wrap
msgid ""
"{% highlight c %}\n"
"ruby_script(\"new name\")\n"
"{% endhighlight %}\n"
msgstr ""
"{% highlight c %}\n"
"ruby_script(\"new name\")\n"
"{% endhighlight %}\n"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:88
#, no-wrap
msgid "To set up the load path so that gems can be loaded with `require`, use\n"
msgstr ""
"gemが `require` で呼び出せるようにするためにロードパスを設定するには、\n"
"次のようにします。\n"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:92
#, no-wrap
msgid ""
"{% highlight c %}\n"
"ruby_init_loadpath()\n"
"{% endhighlight %}\n"
msgstr ""
"{% highlight c %}\n"
"ruby_init_loadpath()\n"
"{% endhighlight %}\n"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:96
#, no-wrap
msgid ""
"You can also pass options to the VM just like you would to `ruby` on the command\n"
"line. This is handy for stuff like setting the warning level or verbose\n"
"mode[^opt].\n"
msgstr ""
"VMにはコマンドラインで `ruby` するときと同じオプションを渡せます。\n"
"警告水準や冗長モード[^opt]の設定に手頃です。\n"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:100
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include embed/options.c %}\n"
"{% endhighlight %}\n"
msgstr ""
"{% highlight c %}\n"
"{% include embed/options.c %}\n"
"{% endhighlight %}\n"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:106
#, no-wrap
msgid ""
"The arguments to `ruby_options` are `argc` and `argv` just like a main function.\n"
"And just like the main of the `ruby` program, the VM expects to get some Ruby\n"
"code when you call it. If you don't give it the filename of a script to load or\n"
"code to run with `-e`, it will try to read from `stdin`. If you want to set\n"
"options but _not_ run any Ruby code, you can pass it an empty line: `\"-e \"`.\n"
msgstr ""
"`ruby_options` への引数は main 関数と同じ `argc` と `argv` です。\n"
"そして、 `ruby` プログラムの main と同じように、\n"
"呼び出したときはVMは何らかのRubyのコードがあるものとしています。\n"
"ロードするスクリプトのファイル名を与えていなかったり、\n"
"`-e` で実行するコードがないときは、\n"
"`stdin` から読み込もうとします。\n"
"オプションを設定したいけれども、Rubyのコードを実行したく _ない_ ときには、\n"
"`\"-e \"` のように空行を渡せばよいです。\n"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:115
#, no-wrap
msgid ""
"`ruby_options()` returns a \"node\" that represents the compiled Ruby code. In some\n"
"cases (such as a syntax error) the node will be invalid and you shouldn't run\n"
"it. `ruby_executable_node()` checks for this. If the node is valid, you can run it\n"
"with `ruby_exec_node()`. The state returned by `ruby_executable_node()` (through\n"
"the pointer) and by `ruby_exec_node()` will be nonzero if an exception was\n"
"raised while compiling or running the code. You can [read the exception\n"
"yourself](../c#rescue), or just pass `state` to `ruby_cleanup()` and it will\n"
"print an appropriate error message.\n"
msgstr ""
"`ruby_options()` はコンパイルされたRubyのコードを表現する \"node\" を返します。\n"
"場合によっては（文法エラーとか）nodeが不正で実行すべきでないときがあります。\n"
"`ruby_executable_node()` はこのnodeを検査します。\n"
"nodeが妥当であれば、 `ruby_exec_node()` で実行できます。\n"
"`ruby_executable_node()` で（ポインタを介して）返る状態は、\n"
"コンパイルの最中やコードの実行時に例外が発生したら、ゼロではない値になります。\n"
"[例外を自前で読む](../c#rescue)こともできますし、\n"
"`ruby_cleanup()` に `state` を渡して適切なエラーメッセージを表示させることもできます。\n"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:118
#, no-wrap
msgid ""
"Ruby currently doesn't support any other way of compiling and running code\n"
"separately[^load].\n"
msgstr "Rubyは現状ではコードの他のコンパイル・実行方法を提供していません[^load]。\n"

#. type: Title ##
#: _posts/2012-01-01-embed.markdown:119 _posts/2013-01-01-extend.markdown:105
#, no-wrap
msgid "Success"
msgstr "やったね"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:122
#, no-wrap
msgid "Now you're ready to interact with Ruby! Go back to the [C API](../c).\n"
msgstr ""
"これでRubyとやりとりすることができました！\n"
"[C API](../c.ja)に戻りましょう。\n"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:127
#, no-wrap
msgid ""
"[^err]: `ruby_init()` uses `error_print()` to get an error message, but this\n"
"        function isn't exposed to the API. Is this a normal exception?\n"
msgstr ""
"[^err]: `ruby_init()` はエラーメッセージを取得するために\n"
"        `error_print()` を使います。\n"
"        しかし、この関数はAPIとして出されていません。\n"
"        これはよくあることなのでしょうか。\n"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:131
#, no-wrap
msgid ""
"[^opt]: In my tests I couldn't get flags like `-w` and `-v` to do anything. This\n"
"        could be related to `ruby_prog_init()`. And really it should be possible\n"
"        to do this without parsing command line options.\n"
msgstr ""
"[^opt]: 筆者の実験では、フラグ `-w` や `-v` で何もできませんでした。\n"
"        `ruby_prog_init()` がするのかもしれません。\n"
"        きっとそれでコマンドラインオプションをパースすることなしに実現できるはずです。\n"

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:133
#, no-wrap
msgid ""
"[^load]: It looks like the function `rb_load_file()` should do this, but I\n"
"         haven't had any luck getting it to work.\n"
msgstr ""
"[^load]: `rb_load_file()` 関数でこれができそうですが、\n"
"         動かせた試しがありません。\n"

#. type: Title ##
#: _posts/2013-01-01-extend.markdown:1 _posts/2014-01-01-examples.markdown:35
#, no-wrap
msgid "Running C in Ruby"
msgstr "RubyでCを実行する"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:11
#, no-wrap
msgid ""
"Compiling C code to be loaded as a Ruby extension requires some fancy compiler\n"
"options. Ruby's [`mkmf` stdlib][mkmf] makes it easy to do this by generating an\n"
"appropriate makefile for you.\n"
msgstr ""
"C言語のコードを、Rubyの拡張としてロードできるようにコンパイルするには、\n"
"ちょっとしたコンパイラのオプションが要ります。\n"
"Rubyの [`mkmf` 標準ライブラリ][mkmf]があれば、\n"
"適切なmakefileを生成してくれるので、\n"
"コンパイルが楽になります。\n"

#. type: Title ###
#: _posts/2013-01-01-extend.markdown:12
#, no-wrap
msgid "Preparation"
msgstr "準備"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:15
#, no-wrap
msgid "First create the file `extconf.rb` in the same directory as your C code:\n"
msgstr "まず、C言語のコードがあるのと同じディレクトリに `extconf.rb` というファイルをつくります。\n"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:19
#, no-wrap
msgid ""
"{% highlight ruby %}\n"
"{% include extend/ext/extconf.rb %}\n"
"{% endhighlight %}\n"
msgstr ""
"{% highlight ruby %}\n"
"{% include extend/ext/extconf.rb %}\n"
"{% endhighlight %}\n"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:22
#, no-wrap
msgid ""
"The preparation section should perform actions similar to the standard UNIX\n"
"[`configure` script][conf] e.g.\n"
msgstr ""
"準備する部分では、標準的なUNIXでの [`configure` スクリプト][conf]でするようなことをします。\n"
"例えば次のようなことです。\n"

#. type: Bullet: '* '
#: _posts/2013-01-01-extend.markdown:26
#, no-wrap
msgid "Check features of the current platform\n"
msgstr "現在のプラットフォームの特徴を確認する\n"

#. type: Bullet: '* '
#: _posts/2013-01-01-extend.markdown:26
#, no-wrap
msgid "Check for existence of required libraries and functions\n"
msgstr "必要なライブラリと関数があることを確認する\n"

#. type: Bullet: '* '
#: _posts/2013-01-01-extend.markdown:26
#, no-wrap
msgid "Check for programs needed for building\n"
msgstr "ビルドするのに必要なプログラムがあることを確認する\n"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:28
#, no-wrap
msgid "[conf]: http://en.wikipedia.org/wiki/Configure_script\n"
msgstr "[conf]: http://en.wikipedia.org/wiki/Configure_script\n"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:32
#, no-wrap
msgid ""
"The most common of these actions are provided by `mkmf` (but you have all of\n"
"Ruby at your disposal if you need it). For example, an extension which uses SDL2\n"
"and needs to know how big `int`s are might call:\n"
msgstr ""
"あるあるな機能は `mkmf` で提供されます（でも、必要とあらばRubyをまったく使わなくてもいいです）。\n"
"例えば、SDL2を使っていて、それとは別に `int` の大きさを知らなければいけないような拡張であれば、\n"
"こんな感じで呼び出すことになります。\n"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:36
#, no-wrap
msgid ""
"{% highlight ruby %}\n"
"{% include extend/ext/exex.rb %}\n"
"{% endhighlight %}\n"
msgstr ""
"{% highlight ruby %}\n"
"{% include extend/ext/exex.rb %}\n"
"{% endhighlight %}\n"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:40
#, no-wrap
msgid ""
"`create_header` creates the file `extconf.h` containing preprocessor definitions\n"
"based on the results of the `mkmf` functions you called previously. For this\n"
"example, `extconf.h` might contain\n"
msgstr ""
"`create_header` は、それより前に呼んだ `mkmf` の関数の結果に基づいて、\n"
"前処理器の定義を含む `extconf.h` ファイルをつくります。\n"
"この例では `extconf.h` は次のような内容を含みます。\n"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:44
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include extend/ext/exh.h %}\n"
"{% endhighlight %}\n"
msgstr ""
"{% highlight c %}\n"
"{% include extend/ext/exh.h %}\n"
"{% endhighlight %}\n"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:52
#, no-wrap
msgid ""
"This header should be included in your C files so that you can adapt your code\n"
"to a variety of platforms. Note that you can and should abort the `extconf.rb`\n"
"script if a `mkmf` function returns a value that indicates that the build will\n"
"fail. For example, if SDL2 is a _requirement_ of your extension you should exit\n"
"with some meaningful error message if `have_library('SDL2')` returns `false`.\n"
"This is preferred to generating the Makefile anyway and leaving the user with an\n"
"opaque compiler error.\n"
msgstr ""
"このヘッダはC言語のファイルに取り込むとよいでしょう。\n"
"そうすれば様々なプラットフォームでコードが使えるようになります。\n"
"気に留めておいてほしいことは、\n"
"`mkmf` 関数がビルドの失敗を示す値を返したら、\n"
"`extconf.rb` スクリプトを頓挫させられますし、そうするべきだということです。\n"
"例えば、ある拡張にSDL2が _必須_ であれば、\n"
"`have_library('SDL2')` が `false` を返したときは、\n"
"何らかの有意味なエラーメッセージを吐いて終了するようなスクリプトにしましょう。\n"
"とりあえずMakefileを生成して、\n"
"よくわからないコンパイルエラーで利用者を置き去りにするよりはマシです。\n"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:57
#, no-wrap
msgid ""
"`create_makefile` obviously creates the Makefile, but its argument is especially\n"
"important: it defines the entry point of your C code, the name of the compiled\n"
"library, and thus the argument for `require` in Ruby! This should be the name of\n"
"your extension.\n"
msgstr ""
"`create_makefile` はもちろんMakefileをつくりますが、\n"
"その引数が特に大切です：\n"
"C言語のコードの入口を決めるものであり、\n"
"コンパイルされたライブラリの名前であり、\n"
"Rubyで `require` するときの引数でもあるのです！\n"
"これは拡張の名前であるべきです。\n"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:63
#, no-wrap
msgid ""
"You can modify a few of the generated Makefile variables by modifying the\n"
"corresponding globals in Ruby: `$CFLAGS`, `$CPPFLAGS`, and `$LDFLAGS`[^glob].\n"
"You can also use the `$objs` global to define a list of object files for the\n"
"Makefile if its method of automatically generating targets doesn't work for\n"
"your extension.\n"
msgstr ""
"生成されるMakefileの変数のいくつかを変更するには、\n"
"Rubyでの対応する大域変数を変更します：\n"
"`$CFLAGS` や `$CPPFLAGS` や `$LDFLAGS` がそうです。\n"
"自動的な生成方法がうまくいかないときは、\n"
"Makefileでのオブジェクトファイルのリストを `$objs` 大域変数で指定することもできます。\n"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:68
#, no-wrap
msgid ""
"All of the `mkmf` functions and their options are well-documented\n"
"[online][mkmf]. In addition to the functions for generating `extconf.h`, there\n"
"are a variety of functions for handling different source file layouts, different\n"
"file dependencies, etc.\n"
msgstr ""
"全ての `mkmf` 関数とそれぞれのオプションは[オンライン][mkmf]で充分に文書化されています。\n"
"`extconf.h` を生成する関数に加えて、\n"
"また違ったソースファイルの配置や依存関係を制御する様々な関数があります。\n"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:70
#, no-wrap
msgid "[mkmf]: http://www.ruby-doc.org/stdlib/libdoc/mkmf/rdoc/MakeMakefile.html\n"
msgstr "[mkmf]: http://www.ruby-doc.org/stdlib/libdoc/mkmf/rdoc/MakeMakefile.html\n"

#. type: Title ###
#: _posts/2013-01-01-extend.markdown:71
#, no-wrap
msgid "Execution"
msgstr "実行"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:74
#, no-wrap
msgid "The rest couldn't be simpler\n"
msgstr "あとはもう、これ以上簡単になりようがありません\n"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:79
#, no-wrap
msgid ""
"{% highlight shell_session %}\n"
"$ ruby extconf.rb\n"
"$ make\n"
"{% endhighlight %}\n"
msgstr ""
"{% highlight shell_session %}\n"
"$ ruby extconf.rb\n"
"$ make\n"
"{% endhighlight %}\n"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:81
#, no-wrap
msgid "[^argv]But of course that won't do anything without some C code to compile.\n"
msgstr "[^argv] もちろん、C言語のコードがコンパイルできないことには話が進まないですけどね。\n"

#. type: Title ##
#: _posts/2013-01-01-extend.markdown:82
#, no-wrap
msgid "Init"
msgstr "初期化"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:89
#, no-wrap
msgid ""
"In your C code, you'll want to include `ruby.h` to access the API. Other than\n"
"that the only requirement is to define a function for the Ruby VM to call when\n"
"your library is `require`d. The name of the function is determined by the\n"
"argument you passed to `create_makefile` in `extconf.rb`. We used \"foobar\" in\n"
"our example, so we'll create `foobar.c` containing\n"
msgstr ""
"C言語のコードでは `ruby.h` を含めてAPIを使えるようにしたいのではないでしょうか。\n"
"その他には、 `require` したときにRubyの仮想機械がライブラリを呼べるように、\n"
"関数を定義するだけでよいです。\n"
"関数の名前は、 `extconf.rb` で `create_makefile` に渡した引数で決まります。\n"
"ここまでの例で `\"foobar\"` を使ってきたので、\n"
"次の内容の `foobar.c` ファイルをつくります。\n"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:93
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include extend/ext/foobar.c %}\n"
"{% endhighlight %}\n"
msgstr ""
"{% highlight c %}\n"
"{% include extend/ext/foobar.c %}\n"
"{% endhighlight %}\n"

#. type: Title ###
#: _posts/2013-01-01-extend.markdown:94
#, no-wrap
msgid "Filenames"
msgstr "ファイル名"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:101
#, no-wrap
msgid ""
"If your extension has only a single C file, you should name it after your\n"
"extension as we did above. If your extensions has multiple C files _do not_ name\n"
"any of them after your extension. This is because the Makefile may generate a\n"
"`.o` file named after your extension for the linking stage, which would cause a\n"
"conflict if you also have a `.c` file which compiles to that filename.\n"
msgstr ""
"拡張に1つのC言語のファイルだけしかないなら、\n"
"さっきやったように拡張の名前と同じファイル名にしましょう。\n"
"逆に複数のC言語のファイルからなる場合、\n"
"拡張に _同じ名前を使わない_ ようにしましょう。\n"
"リンクする段階でMakefileが拡張名と同じ `.o` ファイルを生成すると、\n"
"それと同じファイル名にコンパイルされる `.c` ファイルがある場合に衝突してしまうからです。\n"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:104
#, no-wrap
msgid ""
"Also avoid naming any files `conftest.c` as this file may be written to by\n"
"`mkmf`.\n"
msgstr "また、 `conftest.c` というファイル名も、 `mkmf` によって書き込まれるかもしれないので避けます。\n"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:111
#, no-wrap
msgid ""
"Now make should compile a `.so` (or some other library) file which you can\n"
"`require` in Ruby. You can fill in your `Init` function with plain C code, but\n"
"you'll probably want to go back and learn about the [C API](../c) to do more\n"
"interesting stuff.\n"
msgstr ""
"これにて make で `.so` （またはその他のライブラリ）にコンパイルして、\n"
"Rubyで `require` できるようになりました。\n"
"純粋なC言語のコードで `Init` 関数を実装していくこともできますが、\n"
"たぶんいったん戻って、\n"
"もっと面白いことをするために [C API](../c.ja) を学ばれるのではないでしょうか。\n"

#. type: Title ##
#: _posts/2013-01-01-extend.markdown:112
#, no-wrap
msgid "Gem"
msgstr "Gem"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:118
#, no-wrap
msgid ""
"After you've got your extension working nicely, you may want to bundle it up as\n"
"an easily distributable Ruby gem. rubygems.org has a [detailed guide][rbg] on\n"
"creating gems, but as far as C extensions go you just need to tell the spec\n"
"about `extconf.rb`[^rbg]:\n"
msgstr ""
"いい感じに拡張が動くようになったら、\n"
"簡単に配布できるRubyのgemとしてまとめたいはずです。\n"
"rubygems.org にはgemをつくる上での[詳細なガイド][rbg]がありますが、\n"
"C拡張に関して言えば `extconf.rb` についてspecに記すだけでよいです[^rbg]。\n"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:122
#, no-wrap
msgid ""
"{% highlight ruby %}\n"
"{% include extend/foobar.gemspec %}\n"
"{% endhighlight %}\n"
msgstr ""
"{% highlight ruby %}\n"
"{% include extend/foobar.gemspec %}\n"
"{% endhighlight %}\n"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:125
#, no-wrap
msgid ""
"If your gem includes multiple independent extensions, you can organize them in\n"
"subdirectories of `ext/` and pass all of the `extconf.rb`s to the spec.\n"
msgstr ""
"gemが複数の拡張に依存していたら、\n"
"`ext/` のサブディレクトリにそれぞれ固めて、\n"
"specに各々の `extconf.rb` を記します。\n"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:127
#, no-wrap
msgid "[rbg]: http://guides.rubygems.org/make-your-own-gem/\n"
msgstr "[rbg]: http://guides.rubygems.org/make-your-own-gem/\n"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:131
#, no-wrap
msgid "[^glob]: Check the [official documentation][globals].\n"
msgstr "[^glob]: [公式文書][globals]をご確認ください。\n"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:135
#, no-wrap
msgid ""
"[^argv]: The official documentation [hints][makefile] that `mkmf` parses certain\n"
"         command line flags e.g.  `--vendor`. But I can't find this documented\n"
"         anywhere.\n"
msgstr "[^argv]: 公式文書は、`--vendor` のようなコマンドライン引数を `mkmf` がパースできると[仄めかしている][makefile] ようです。でも、このことはどこにも文書化されていないように見えます。\n"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:137
#, no-wrap
msgid "[^rbg]: [http://guides.rubygems.org/gems-with-extensions/](http://guides.rubygems.org/gems-with-extensions/)\n"
msgstr "[^rbg]: [http://guides.rubygems.org/gems-with-extensions/](http://guides.rubygems.org/gems-with-extensions/)\n"

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:139
#, no-wrap
msgid ""
"[globals]: https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-Prepare+extconf.rb\n"
"[makefile]: https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-Generate+Makefile\n"
msgstr ""
"[globals]: https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-Prepare+extconf.rb\n"
"[makefile]: https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-Generate+Makefile\n"

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:14
#, no-wrap
msgid ""
"This example is a simple little game of tag. In the game there are two squares:\n"
"the blue square is controlled using the arrow keys on the keyboard while the red\n"
"square is controlled by a Ruby script. To make this work, we'll use the C API to\n"
"define a little Ruby API that the script can access, and every couple of frames\n"
"we'll call a method defined in the Ruby script and pass objects encapsulating\n"
"the data for the two squares.\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:16
#, no-wrap
msgid "The Ruby script can look something like this:\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:20
#, no-wrap
msgid ""
"{% highlight ruby %}\n"
"{% include examples/ai.rb %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:24
#, no-wrap
msgid ""
"The C code uses SDL2 for graphics and input and uses `stat()` (which may not be\n"
"very portable) to hot-reload the AI script whenever the file is changed . Here's\n"
"`tag.c`:\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:28
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include examples/tag.c %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:30
#, no-wrap
msgid "The Makefile is nothing special:\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:34
#, no-wrap
msgid ""
"{% highlight make %}\n"
"{% include examples/Makefile %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:42
#, no-wrap
msgid ""
"This example is a Ruby C extension that wraps the [GMP][gmp] C library for\n"
"arbitrary precision arithmetic. This is far from a complete example: it only\n"
"wraps the integer functions, implements only the basic functionality of the\n"
"library, and doesn't bother nicely integrating with Ruby's existing numeric\n"
"types. If you want a _really_ full example, check out the [GMP gem][gem].\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:45
#, no-wrap
msgid ""
"[gmp]: https://gmplib.org/\n"
"[gem]: https://github.com/srawlins/gmp\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:47
#, no-wrap
msgid "Everything is in `gmp.c` where we define our `GMP::Integer` class:\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:51
#, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include examples/ext/gmp.c %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:53
#, no-wrap
msgid "The `extconf.rb` is really simple.\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:57
#, no-wrap
msgid ""
"{% highlight ruby %}\n"
"{% include examples/ext/extconf.rb %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:59
#, no-wrap
msgid "And now you can finally find out what your name means in base 62:\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:63
#, no-wrap
msgid ""
"{% highlight ruby %}\n"
"{% include examples/gmp_ex.rb %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:70
#, no-wrap
msgid ""
"For this example I tried to do everything in C, but practically that isn't\n"
"necessary (or desirable). If one of your C methods just calls a bunch of API\n"
"functions (like `to_i` and `==` in the example), you're probably only saving\n"
"yourself a couple CPU cycles compared to implementing the method in Ruby. And of\n"
"course that comes at the cost of needing to spend more time writing C and less\n"
"time writing Ruby. ð\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:75
#, no-wrap
msgid ""
"A common convention when writing extensions is to only implement the \"meat\" of\n"
"the extension in C and to do everything else in a regular Ruby script that pulls\n"
"in the compiled library. For example, we could have written a `gmp.rb` script to\n"
"significantly simplify our extension:\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:78
#, no-wrap
msgid ""
"{% highlight ruby %}\n"
"{% include examples/gmp.rb %}\n"
"{% endhighlight %}\n"
msgstr ""

#, fuzzy, no-wrap
#~| msgid "The Ruby C API"
#~ msgid "Rubyã®C API"
#~ msgstr "RubyのC API"
