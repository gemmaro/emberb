# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-02-19 12:57+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: layout
#: _posts/2010-01-01-c.markdown:1 _posts/2012-01-01-embed.markdown:1
#: _posts/2013-01-01-extend.markdown:1 _posts/2014-01-01-examples.markdown:1
#, no-wrap
msgid "chapter"
msgstr ""

#. type: YAML Front Matter: title
#: _posts/2010-01-01-c.markdown:1
#, no-wrap
msgid "The Ruby C API"
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:6
#, markdown-text, no-wrap
msgid "Before You Start"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:10
#, markdown-text, no-wrap
msgid ""
"For the greatest chance of success with this guide, I recommend being "
"fairly\n"
"comfortable with C and _very_ comfortable with Ruby.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:16
#, markdown-text, no-wrap
msgid ""
"Using Ruby's C API does not require any advanced C concepts, however the API "
"is\n"
"**huge** and largely **undocumented**. After you start using it, you will "
"likely\n"
"find yourself delving through the Ruby source code at some point to figure "
"out\n"
"the behavior of some obscure function or macro. The Ruby source uses some "
"fairly\n"
"sophisticated C, so you should at least feel comfortable reading it.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:22
#, markdown-text, no-wrap
msgid ""
"You can think of the C API is being a big, clunky alternative to writing "
"normal\n"
"Ruby code. However the simple, elegant patterns of Ruby can be pretty\n"
"unintuitive once translated into the language of the API. Having a strong\n"
"intuition for Ruby's internal logic and the ideas behind its design will go "
"a\n"
"long way toward steering you toward the correct API functions.\n"
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:23
#, markdown-text, no-wrap
msgid "The Two Paths"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:28
#, markdown-text, no-wrap
msgid ""
"The official Ruby interpreter is written in C. That means that everything "
"you\n"
"can do in Ruby, you can also do using function calls to Ruby's C API. Why in "
"the\n"
"world would you do this? There are two good reasons:\n"
msgstr ""

#. type: Bullet: '1. '
#: _posts/2010-01-01-c.markdown:37
#, markdown-text, no-wrap
msgid ""
"You're writing some fancy application in C or C++ and you want some parts "
"of\n"
"your code to leverage the dynamic flexibility of Ruby. You can run the\n"
"Ruby interpreter inside of your application and use the API to retrieve "
"the\n"
"results of Ruby code.\n"
msgstr ""

#. type: Bullet: '2. '
#: _posts/2010-01-01-c.markdown:37
#, markdown-text, no-wrap
msgid ""
"You're writing some fancy application in Ruby and you want some parts of "
"your\n"
"code to leverage the speed and power of C (or an existing C library). You "
"can\n"
"expose C code to Ruby using the API and compile a special library that "
"Ruby\n"
"can `require`.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:42
#, markdown-text, no-wrap
msgid ""
"You'll need to structure your C code differently depending on your "
"goal. If\n"
"you want to embed the Ruby interpreter in C, read [Running Ruby in "
"C](../embed). If\n"
"you want to `require` a compiled C library, read [Running C in "
"Ruby](../extend).\n"
"After you finish that, come back here to learn about the API.\n"
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:43
#, markdown-text, no-wrap
msgid "Eval"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:46
#, markdown-text, no-wrap
msgid "The quick 'n' dirty way to run some Ruby code from C is to `eval` it\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:50
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/eval.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:55
#, markdown-text, no-wrap
msgid ""
"This is a good fallback if you can't find an API function for something that "
"you\n"
"want to do[^wrap]. `rb_eval_string_protect()` returns the result of the "
"Ruby\n"
"code and sets `state` to some nonzero value if any exception is "
"raised. `VALUE`\n"
"is the C data type for all Ruby objects, as explained in the next section.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:60
#, markdown-text, no-wrap
msgid ""
"If `state` is nonzero, `result` will be a `VALUE` representing `nil` and "
"you\n"
"should handle the exception. Alternatively, you can use `rb_eval_string()` "
"which\n"
"doesn't take a `state` argument and instead raises any exceptions "
"normally. See\n"
"[Exceptions](#exceptions) for how to handle both of these cases.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:64
#, markdown-text, no-wrap
msgid ""
"Unlike `eval` in Ruby, these functions evaluate the string in an isolated\n"
"binding&mdash;like when you `require` something. So local variables in the\n"
"string will not be accessible from elsewhere and vice versa.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:69
#, markdown-text, no-wrap
msgid ""
"However, like using `eval` in Ruby, using these functions is not a good\n"
"practice. It's inefficient since the parser is invoked and it somewhat "
"defeats\n"
"the point of writing in C. If you just want to call some Ruby method, we'll "
"go\n"
"over a better way to do that [later on](#send).\n"
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:70
#, markdown-text, no-wrap
msgid "VALUE"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:79
#, markdown-text, no-wrap
msgid ""
"Before we go any further, we need to understand `VALUE`s. Due to the danger "
"of\n"
"monkeying around inside the VM, the API never lets you directly access "
"Ruby's\n"
"objects[^intern]. Instead, your C code will store and pass around _pointers_ "
"to\n"
"Ruby objects (like how variables in Ruby contain pointers to "
"objects). These\n"
"pointers can be passed to various API functions and macros that will "
"safely\n"
"access and manipulate the Ruby objects. `VALUE` is the API-defined C type "
"for\n"
"these pointers.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:84
#, markdown-text, no-wrap
msgid ""
"Probably the most frequent question you'll have is: \"is this `VALUE` the "
"right\n"
"type?\". There are a couple macros for performing this test, and both take "
"a\n"
"[`T_` constant][datatypes] corresponding to the Ruby class you're\n"
"testing for e.g. `T_STRING`, `T_ARRAY`, etc.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:86
#, markdown-text, no-wrap
msgid ""
"[datatypes]: "
"https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-Data+Types\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:90
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/checktype.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:96
#, markdown-text, no-wrap
msgid ""
"These tests work for subclasses too: if you're testing for a subclass of "
"`Array`\n"
"use `T_ARRAY`, if you're testing for a subclass of `Object` use\n"
"`T_OBJECT`[^tdata]. That being said, these tests _do not work like "
"`is_a?`_;\n"
"even though everything in Ruby `is_a? Object`, testing against `T_OBJECT` "
"will\n"
"only return true for objects for which there is no better fitting "
"constant.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:99
#, markdown-text, no-wrap
msgid ""
"For certain classes, there are specialized macros that are a little more\n"
"efficient than the previous:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:103
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/check_p.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:107
#, markdown-text, no-wrap
msgid ""
"If you want to handle a `VALUE` that could be one of a variety of types, "
"the\n"
"previous macros can be a little clumsy. In that case you can use the "
"`TYPE()`\n"
"macro to get the `T_` constant and handle your logic in a `switch`:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:111
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/type.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:112
#, markdown-text, no-wrap
msgid "Constants"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:121
#, markdown-text, no-wrap
msgid ""
"Most of the standard Ruby constants have global `VALUE`s defined for them in "
"the\n"
"API so you don't need an API call to access them. Modules are prefixed "
"with\n"
"`rb_m` e.g. `rb_mKernel`; classes are prefixed with `rb_c` "
"e.g. `rb_cObject`;\n"
"subclasses of `Exception` are prefixed with `rb_e` e.g. `rb_eRuntimeError`; "
"and\n"
"the standard IO streams are prefixed with `rb_` e.g. `rb_stderr`. `nil`,\n"
"`false`, and `true` are prefixed with `Q` e.g. `Qnil`.[^undef] As a "
"convenience,\n"
"`Qfalse` is also false in C (`0`).\n"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:122
#, markdown-text, no-wrap
msgid "Translation"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:126
#, markdown-text, no-wrap
msgid ""
"A few Ruby classes are analogous to C types. These classes will be your "
"primary\n"
"means of transferring data between C and Ruby.\n"
msgstr ""

#. type: Title ####
#: _posts/2010-01-01-c.markdown:127
#, markdown-text, no-wrap
msgid "Fixnum"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:133
#, markdown-text, no-wrap
msgid ""
"Ruby's `Fixnum` corresponds to C's `long`. The `FIX2LONG()` macro gives you "
"the\n"
"`long` for a `Fixnum`. For smaller C types there's `FIX2UINT()`, "
"`FIX2INT()`,\n"
"and `FIX2SHORT()`, but these will raise a `RangeError` if the number "
"wouldn't\n"
"fit.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:136
#, markdown-text, no-wrap
msgid ""
"In the other direction, `LONG2FIX()` works for `long` **and** every "
"smaller\n"
"integer C type[^chr].\n"
msgstr ""

#. type: Title ####
#: _posts/2010-01-01-c.markdown:137
#, markdown-text, no-wrap
msgid "Bignum"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:143
#, markdown-text, no-wrap
msgid ""
"Ruby's `Bignum` is for anything bigger than a `Fixnum`, so it works if you "
"need\n"
"to work with `long long`, for example. `rb_big2ll()` and `rb_big2ull()` will "
"get\n"
"you `long long` and `unsigned long long` from a `Bignum` (or raise a\n"
"`RangeError` if appropriate).\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:145 _posts/2010-01-01-c.markdown:152
#, markdown-text, no-wrap
msgid "See [Numeric](#numeric) for the reverse direction.\n"
msgstr ""

#. type: Title ####
#: _posts/2010-01-01-c.markdown:146
#, markdown-text, no-wrap
msgid "Float"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:150
#, markdown-text, no-wrap
msgid ""
"Ruby's `Float` corresponds to C's `double`. The `RFLOAT_VALUE()` macro gives "
"you the\n"
"`double` for a `Float`.\n"
msgstr ""

#. type: Title ####
#: _posts/2010-01-01-c.markdown:153
#, markdown-text, no-wrap
msgid "Numeric"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:158
#, markdown-text, no-wrap
msgid ""
"There are a host of \"NUM\" macros that try to be more duck-typish about "
"things.\n"
"These will convert their C types to whatever Ruby `Numeric` subclass seems\n"
"appropriate:\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:166
#, markdown-text, no-wrap
msgid "`INT2NUM()` for `int`\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:166
#, markdown-text, no-wrap
msgid "`UINT2NUM()` for `unsigned int`\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:166
#, markdown-text, no-wrap
msgid "`LONG2NUM()` for `long`\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:166
#, markdown-text, no-wrap
msgid "`ULONG2NUM()` for `unsigned long`\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:166
#, markdown-text, no-wrap
msgid "`LL2NUM()` for `long long`\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:166
#, markdown-text, no-wrap
msgid "`ULL2NUM()` for `unsigned long long`\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:166
#, markdown-text, no-wrap
msgid "`DBL2NUM()` for `double`\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:171
#, markdown-text, no-wrap
msgid ""
"And there are macros for the opposite direction, which will try to convert\n"
"whatever `Numeric` to the desired C type. These will raise a `RangeError` "
"if\n"
"the value wouldn't fit or `TypeError` if there is no implicit numeric "
"conversion\n"
"(so you can safely pass non-`Numeric` objects).\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
#, markdown-text, no-wrap
msgid "`NUM2CHR()` for `char` (works for `unsigned char` too)\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
#, markdown-text, no-wrap
msgid "`NUM2SHORT()` for `short`\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
#, markdown-text, no-wrap
msgid "`NUM2USHORT()` for `unsigned short`\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
#, markdown-text, no-wrap
msgid "`NUM2INT()` for `int`\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
#, markdown-text, no-wrap
msgid "`NUM2UINT()` for `unsigned int`\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
#, markdown-text, no-wrap
msgid "`NUM2LONG()` for `long`\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
#, markdown-text, no-wrap
msgid "`NUM2ULONG()` for `unsigned long`\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
#, markdown-text, no-wrap
msgid "`NUM2LL()` for `long long`\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
#, markdown-text, no-wrap
msgid "`NUM2ULL()` for `unsigned long long`\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:182
#, markdown-text, no-wrap
msgid "`NUM2DBL()` for `double`\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:189
#, markdown-text, no-wrap
msgid ""
"A **major** gotcha with these is that _none_ of the macros for converting "
"to\n"
"unsigned types raise an exception if you pass a negative value "
"(surprisingly\n"
"this [isn't a bug][bug]). `NUM2CHR()` also has a couple quirks: it will "
"only\n"
"raise a `RangeError` if the value is too big for an _int_ and when passed "
"a\n"
"string it returns the numeric value of the first character rather than "
"raising a\n"
"`TypeError`.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:192
#, markdown-text, no-wrap
msgid ""
"If you know that the conversion is safe, you should prefer the macros from "
"the\n"
"previous sections as they skip the range checks.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:194
#, markdown-text, no-wrap
msgid "[bug]: https://bugs.ruby-lang.org/issues/9089\n"
msgstr ""

#. type: Title ####
#: _posts/2010-01-01-c.markdown:195
#, markdown-text, no-wrap
msgid "String"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:203
#, markdown-text, no-wrap
msgid ""
"Ruby's `String` kinda corresponds to C's `char*`. The simplest macro is\n"
"`StringValueCStr()` which returns a null-terminated `char*` for a "
"`String`. The\n"
"problem here is that a Ruby `String` _might contain nulls_ - in which case\n"
"`StringValueCStr()` will raise an `ArgumentError`! Instead you can use the\n"
"macros `StringValuePtr()` and `RSTRING_LEN()` to get a (possibly "
"unterminated)\n"
"`char*` and the string's length as a `long`.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:211
#, markdown-text, no-wrap
msgid ""
"Conversely, if you have a null-terminated `char*`, you can use\n"
"`rb_str_new_cstr()` to create a Ruby `String`. And if you want your `String` "
"to\n"
"contain nulls, use `rb_str_new()` which takes a `char*` and the string's "
"length\n"
"(as a `long`). The encodings of these strings will be `ASCII-8BIT`, which "
"is\n"
"often undesirable in Ruby. You can pass the string `VALUE` to\n"
"`rb_str_export_locale()` to get a new `VALUE` with your locale's\n"
"encoding[^wchar].\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:218
#, markdown-text, no-wrap
msgid ""
"If you want to build more complex strings, you can do so using the "
"`printf`-like\n"
"function `rb_sprintf()`. This accepts all of the usual conversion "
"specifiers,\n"
"but also accepts an API-defined specifier `PRIsVALUE` which takes a\n"
"corresponding `VALUE` argument. This conversion specifier substitutes a "
"string\n"
"by sending the object `to_s`. You can substitute the result of `inspect` "
"instead\n"
"by adding the `+` flag.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:222
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/printf.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:227
#, markdown-text, no-wrap
msgid ""
"This custom specifier should work for any `printf`-like function in the "
"API.\n"
"`PRIsVALUE` works by hijacking the `i` conversion specifier, so when "
"printing\n"
"an `int` you should use `d` to ensure that Ruby doesn't think it's actually "
"a\n"
"`VALUE`.\n"
msgstr ""

#. type: Title ####
#: _posts/2010-01-01-c.markdown:228
#, markdown-text, no-wrap
msgid "Symbol"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:236
#, markdown-text, no-wrap
msgid ""
"The API defines a C type `ID` which corresponds to Ruby's `Symbol`. Just "
"like\n"
"how Ruby passes around `Symbol`s as method or variable names, many API "
"calls\n"
"that need a method or variable name use an `ID`. To convert between a "
"`Symbol`\n"
"and an `ID` use the `SYM2ID()` and `ID2SYM()` macros. Instead of a `Symbol` "
"you\n"
"may want to convert to/from a `char*` C string. To get an `ID` from a "
"`char*`\n"
"use `rb_intern()` and for the reverse use `rb_id2name()`.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:246
#, markdown-text, no-wrap
msgid ""
"Since many API functions require an `ID` and in many cases you will not have "
"the\n"
"appropriate `ID` at hand, the API also defines a slew of functions that "
"instead\n"
"take a `char*` and which do the `rb_intern()` call for you. Since these\n"
"functions are often more readable and the overhead of the `rb_intern()` call "
"is\n"
"negligible, I have opted to use the `char*` versions of the API functions\n"
"wherever possible in this guide. If you find yourself frequently using a "
"certain\n"
"C string in API calls, you may see some performance benefit by storing the "
"`ID`\n"
"and using the `ID` versions of the functions (though you'll have to look "
"these\n"
"up yourself in the Ruby headers).\n"
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:247
#, markdown-text, no-wrap
msgid "Send"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:253
#, markdown-text, no-wrap
msgid ""
"This section contains API functions for directly calling Ruby methods. You\n"
"should prefer these functions to `rb_eval_string()` and the like whenever\n"
"possible. They are faster since they skip the parser and allow for some\n"
"compile-time checks.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:255
#, markdown-text, no-wrap
msgid "The easiest way to send an object a method looks like this:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:259
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/funcall.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:261
#, markdown-text, no-wrap
msgid "This is roughly equivalent to the Ruby code\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:265
#, markdown-text, no-wrap
msgid ""
"{% highlight ruby %}\n"
"{% include c/funcall.rb %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:270
#, markdown-text, no-wrap
msgid ""
"The first argument is the receiver. The next is the [`ID`](#symbol) for "
"the\n"
"method name. The third argument is the number of method arguments, which "
"is\n"
"needed since `rb_funcall()` is a varargs function. Then come the actual "
"method\n"
"arguments.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:274
#, markdown-text, no-wrap
msgid ""
"Alternatively, you can use `rb_funcallv()` where the fourth argument is a\n"
"`VALUE*` pointing to a C array of arguments. This also has the variant\n"
"`rb_funcallv_public()` which is like `public_send` in Ruby.\n"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:275
#, markdown-text, no-wrap
msgid "Passing Blocks"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:279
#, markdown-text, no-wrap
msgid ""
"If you want to pass a `Proc` as the block to a method, that's easy. The "
"function\n"
"is just like `rb_funcallv()` but with the proc on the end.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:283
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/proc.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:287
#, markdown-text, no-wrap
msgid ""
"If you don't have a proc for the block, you'll need to define a certain kind "
"of\n"
"C function to represent the block. Then there's a different variant of\n"
"`rb_funcallv()` but with a couple extra arguments for the block:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:291
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/block.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:297
#, markdown-text, no-wrap
msgid ""
"The last argument to `rb_block_call()` is helpful for passing in values "
"outside\n"
"the block function's scope, but in this example we don't need it (thus "
"`nil`). I\n"
"also recommend against using the first argument to your block function "
"unless\n"
"you're **sure** that only one value was yielded. You can always get all "
"the\n"
"arguments from `argv`, so why not play it safe?[^break]\n"
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:298
#, markdown-text, no-wrap
msgid "Builtins"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:305
#, markdown-text, no-wrap
msgid ""
"Many of Ruby's built-in classes have API functions defined for their most "
"useful\n"
"methods. Using them can save you from the verbosity of always using\n"
"`rb_funcall()` and can provide more compile-time checks. There are far too "
"many\n"
"functions to list here, so I recommend checking them out in the header\n"
"`ruby/intern.h`.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:309
#, markdown-text, no-wrap
msgid ""
"Functions are generally named like `rb_(class)_(method)` and take at least "
"one\n"
"`VALUE` argument (the receiver). E.g. `rb_ary_pop()` for `Array#pop`,\n"
"`rb_obj_dup()` for `Object#dup`, etc.\n"
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:310
#, markdown-text, no-wrap
msgid "Require"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:314
#, markdown-text, no-wrap
msgid ""
"The API can also load some Ruby code from a script. There's an equivalent "
"to\n"
"`require`:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:318
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/require.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:321
#, markdown-text, no-wrap
msgid ""
"As with `require`, these could raise exceptions. Read the [next\n"
"section](#exceptions) for how to handle them.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:323
#, markdown-text, no-wrap
msgid ""
"There are also functions for `load` if you want to load a script multiple "
"times:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:327
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/load.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:331
#, markdown-text, no-wrap
msgid ""
"Just like [`load` in Ruby][rbload], these functions can wrap the loaded code "
"in\n"
"an anonymous module to protect the global namespace. Just pass a nonzero "
"value\n"
"for the second argument.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:333
#, markdown-text, no-wrap
msgid "[rbload]: http://www.ruby-doc.org/core/Kernel.html#method-i-load\n"
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:334
#, markdown-text, no-wrap
msgid "Exceptions"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:336
#, markdown-text, no-wrap
msgid "Raise"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:339
#, markdown-text, no-wrap
msgid "To raise an exception, use:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:343
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/raise.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:348
#, markdown-text, no-wrap
msgid ""
"The first and second arguments are the exception class and "
"message&mdash;like\n"
"`raise` in Ruby. The big difference is that the message is a format string "
"[just\n"
"like in `rb_sprintf()`](#string), letting you more easily build a useful\n"
"message.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:355
#, markdown-text, no-wrap
msgid ""
"You can also construct exception objects directly using `rb_exc_new_cstr`,\n"
"`rb_exc_new`, and `rb_exc_new_str`. All of these accept an exception class "
"as\n"
"their first argument and then they work just like their [string](#string)\n"
"counterparts, constructing an exception using a null-terminated string,\n"
"non-null-terminated string, and a `String` object, resp. Then you can raise "
"your\n"
"exception object with `rb_exc_raise`.\n"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:356
#, markdown-text, no-wrap
msgid "Rescue"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:361
#, markdown-text, no-wrap
msgid ""
"There are several ways to rescue exceptions using the API. All of them "
"require\n"
"the code you're protecting to be in a function that takes and returns a "
"single\n"
"`VALUE`.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:365
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/danger.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:369
#, markdown-text, no-wrap
msgid ""
"Unless you wanted to rescue a function of exactly this type, you will "
"probably\n"
"need to make a wrapper function in this format that runs the desired "
"code. The\n"
"way to access a rescued exception is also independent of the way it is "
"rescued:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:373
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/handle.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:378
#, markdown-text, no-wrap
msgid ""
"`rb_errinfo()` essentially gives you the `VALUE` of Ruby's `$!` (which will "
"be\n"
"`Qnil` if no exception occurred). Unlike in Ruby, you must manually clear "
"the\n"
"exception after reading it[^clear]. Otherwise later API calls might read the "
"old\n"
"value and think another exception has occurred.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:382
#, markdown-text, no-wrap
msgid ""
"Next we will go over several methods of rescuing; you can use whichever "
"you\n"
"like, but I think that generally the right choice is determined by your\n"
"[use-case](#the-two-paths) of the API.\n"
msgstr ""

#. type: Title ####
#: _posts/2010-01-01-c.markdown:383
#, markdown-text, no-wrap
msgid "rb_rescue2"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:389
#, markdown-text, no-wrap
msgid ""
"If you're compiling a library to be loaded by Ruby, you have it easy. Any\n"
"exceptions raised in the API can be rescued as usual in your Ruby code. If "
"you\n"
"want to rescue an exception in the API, you can use `rb_rescue2()` which "
"is\n"
"similar to Ruby's `rescue`.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:393
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/rescue2.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:402
#, markdown-text, no-wrap
msgid ""
"The first two arguments are the function to protect and its argument, the "
"next\n"
"two are the function to call if an exception is raised and its argument.\n"
"`rb_rescue2()` is a varargs function, so after that comes a list of the\n"
"exception classes you want to rescue. The last argument should always be `0` "
"to\n"
"indicate the end of the class list. Like `rescue` in Ruby, any exceptions "
"not in\n"
"this list will not be rescued. If you just want to rescue `StandardError` "
"(like\n"
"a blank `rescue` in Ruby), you can use `rb_rescue()` which takes just the "
"first\n"
"four arguments of `rb_rescue2()`.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:406
#, markdown-text, no-wrap
msgid ""
"The API does not provide an easy way to run different rescue code for "
"different\n"
"exception classes as Ruby does. You'll need to rescue all the classes you "
"want\n"
"at once and use some kind of switch to handle them separately.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:413
#, markdown-text, no-wrap
msgid ""
"The API also does not directly provide an equivalent to Ruby's `else` "
"i.e. code\n"
"to run when _no_ exception was raised. One way to do this is using the "
"return\n"
"value of `rb_rescue2()`. If no exception is raised, it returns the return "
"value\n"
"of the first (dangerous) function, otherwise the return value of the "
"second\n"
"(rescue) function. By having these return, say, `Qtrue` and `Qfalse` you "
"can\n"
"detect which case you are in.\n"
msgstr ""

#. type: Title ####
#: _posts/2010-01-01-c.markdown:414
#, markdown-text, no-wrap
msgid "rb_protect"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:421
#, markdown-text, no-wrap
msgid ""
"If you're embedding the Ruby interpreter in C, you need to be _extremely\n"
"careful_ when calling API functions that could raise exceptions: **an "
"uncaught\n"
"exception will segfault the VM and kill your program**. You could call\n"
"`rb_rescue2()` with `rb_eException`, but there's another approach for "
"rescuing\n"
"all exceptions:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:425
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/protect.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:431
#, markdown-text, no-wrap
msgid ""
"Like `rb_rescue2()`, the first two arguments are for calling the function "
"to\n"
"protect. However, like `rb_eval_string_protect()`, if an exception is "
"raised\n"
"it returns `Qnil` and sets `state` to some nonzero value. If you want to\n"
"re-raise the exception, pass `state` to `rb_jump_tag()` (this also works for "
"the\n"
"state from the other `*_protect()` functions).\n"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:432
#, markdown-text, no-wrap
msgid "Ensure"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:439
#, markdown-text, no-wrap
msgid ""
"`rb_ensure()` is similar to `rb_rescue()` except that it doesn't do "
"anything\n"
"about exceptions and the second function is _always_ called after the "
"first.\n"
"That may sound simple enough, but that means that if you want the usual "
"`begin;\n"
"rescue; ensure; end` structure as in Ruby, you'll need another layer of\n"
"wrapping:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:443
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/ensure.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:448
#, markdown-text, no-wrap
msgid ""
"Like `ensure` in Ruby, the return value of `ensure_func()` is never used. If "
"no\n"
"exception occurs, `rb_rescue()` will return the value of `begin_func()` "
"which\n"
"returns the value of `dangerous_func()`. If an exception does occur,\n"
"`rb_rescue()` returns the value of `rescue_func()`.\n"
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:449
#, markdown-text, no-wrap
msgid "Definitions, Declarations"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:454
#, markdown-text, no-wrap
msgid ""
"So far we've been creating and modifying objects directly in the VM's "
"memory,\n"
"but none of our API calls have had a visible effect _within the Ruby code_: "
"a\n"
"`String` made with `rb_str_new_cstr()` can only be accessed from C by "
"default.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:463
#, markdown-text, no-wrap
msgid ""
"There are a few ways to make things visible to Ruby but they all work the "
"same\n"
"general way: by defining some name that Ruby can access e.g. a variable "
"name, a\n"
"method name, etc. A general warning though: unlike Ruby, **the API lets you "
"give\n"
"things invalid names**. Ruby will raise a `SyntaxError` or `NameError` if "
"you\n"
"try to name a class `foo` (not constant) or an instance variable `bar` (no "
"`@`),\n"
"but the API will happily create them. The API handles this by **not "
"exposing\n"
"invalid names to Ruby**. Since that's probably not what you want, double "
"check\n"
"the names you choose!\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:469
#, markdown-text, no-wrap
msgid ""
"Most of the API functions in this section correspond closely to "
"metaprogramming\n"
"methods in Ruby. When you're trying to do something using the API, it can "
"be\n"
"helpful to think about how you would do it in Ruby using only "
"metaprogramming\n"
"method calls. For example, rather than `class Foo; def bar; end; end`, "
"think\n"
"`Foo = Class.new; Foo.define_method(:bar) {}`.\n"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:470
#, markdown-text, no-wrap
msgid "Global Variables"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:473
#, markdown-text, no-wrap
msgid "The simplest way to deal with globals is:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:477
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/global.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:480
#, markdown-text, no-wrap
msgid ""
"If you're frequently accessing Ruby's globals, you can set up a `VALUE` "
"which\n"
"will be automatically synchronized with one.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:484
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/global2.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:491
#, markdown-text, no-wrap
msgid ""
"The `VALUE` should be initialized before you create the global in Ruby and "
"it\n"
"should be global in C as well&mdash;you don't want it to go out of scope "
"while\n"
"Ruby is using it! For `rb_define_hooked_variable()`, you can pass `NULL` for "
"the\n"
"getter/setter if you want to synchronize normally for that operation. Or you "
"can\n"
"throw out `global` entirely with `rb_define_virtual_variable()` though of "
"course\n"
"the getter and setter _must_ be defined in that case.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:495
#, markdown-text, no-wrap
msgid ""
"If you ever create a global `VALUE` in C which is _not_ exposed to Ruby, "
"you\n"
"must tell the garbage collector about it to prevent it from being "
"prematurely\n"
"cleaned up:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:499
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/gc.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:500
#, markdown-text, no-wrap
msgid "Class and Instance Variables"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:504
#, markdown-text, no-wrap
msgid ""
"Getting/setting instance variables is similar to the simple way of "
"accessing\n"
"globals, but of course you need an object to get the variable from.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:508
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/ivar.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:511
#, markdown-text, no-wrap
msgid ""
"There isn't an automatic way to synchronize instance variables like you can "
"with\n"
"globals.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:513
#, markdown-text, no-wrap
msgid "To iterate over all instance variables, use `rb_ivar_foreach`.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:516
#, markdown-text, no-wrap
msgid ""
"For class variables, the methods are `rb_cv_get()` and `rb_cv_set()` and "
"of\n"
"course the first argument should be a class object.\n"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:517
#, markdown-text, no-wrap
msgid "Constants ####"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:520
#, markdown-text, no-wrap
msgid "Constants are defined similarly, but with the module to define them under:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:524
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/constant.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:528
#, markdown-text, no-wrap
msgid ""
"You undefine a constant by setting it to `Qundef`. Getting a constant's "
"`VALUE`\n"
"is a little nuanced. The API function you call depends on what you want to\n"
"happen if the constant is _not_ defined in the module you specify:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:532
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/const_get.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:534
#, markdown-text, no-wrap
msgid "All of these API calls will get private constants too.\n"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:535
#, markdown-text, no-wrap
msgid "Modules and Classes"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:538
#, markdown-text, no-wrap
msgid "Defining modules is super easy.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:542
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/module.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:544
#, markdown-text, no-wrap
msgid "Classes work the same way but they also need a superclass.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:548
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/class.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:549
#, markdown-text, no-wrap
msgid "Methods"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:555
#, markdown-text, no-wrap
msgid ""
"Here's where it gets interesting. There are many kinds of API calls for "
"defining\n"
"methods, but before you use any of them you'll need a C function that the "
"method\n"
"calls. The function must return a `VALUE` and have one `VALUE` argument for "
"the\n"
"receiver of the method. There are three ways you can define its other "
"arguments:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:559
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/methodc.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:564
#, markdown-text, no-wrap
msgid ""
"So really the API only lets you define two types of methods: ones that take "
"a\n"
"fixed number of arguments, and ones that slurp up all of their "
"arguments. What\n"
"about all of Ruby's fancy argument features? Where are optional arguments,\n"
"options hashes, blocks, and all the mixtures of those?\n"
msgstr ""

#. type: Title ####
#: _posts/2010-01-01-c.markdown:565
#, markdown-text, no-wrap
msgid "Parsing Arguments"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:572
#, markdown-text, no-wrap
msgid ""
"Well, if you accept a variable number of arguments you could code all of "
"that\n"
"logic yourself in the method, and make it _behave_ like it has a fancier "
"method\n"
"definition in Ruby. Thankfully, the API has a shortcut for doing exactly "
"that.\n"
"To use it, you should use the C array function definition, then you can "
"pass\n"
"`argc` and `argv` along to:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:576
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/scan.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:581
#, markdown-text, no-wrap
msgid ""
"Here `fmt` is a format string describing how the method arguments would look "
"in\n"
"Ruby. The string can have at most 6 characters, where each character "
"describes a\n"
"different section of the arguments. The six sections and their "
"corresponding\n"
"characters are (in order):\n"
msgstr ""

#. type: Bullet: '1. '
#: _posts/2010-01-01-c.markdown:588
#, markdown-text, no-wrap
msgid "The number of leading mandatory arguments: a digit\n"
msgstr ""

#. type: Bullet: '2. '
#: _posts/2010-01-01-c.markdown:588
#, markdown-text, no-wrap
msgid "The number of optional arguments: a digit\n"
msgstr ""

#. type: Bullet: '3. '
#: _posts/2010-01-01-c.markdown:588
#, markdown-text, no-wrap
msgid "A splatted argument: `*`\n"
msgstr ""

#. type: Bullet: '4. '
#: _posts/2010-01-01-c.markdown:588
#, markdown-text, no-wrap
msgid "The number of trailing mandatory arguments: a digit\n"
msgstr ""

#. type: Bullet: '5. '
#: _posts/2010-01-01-c.markdown:588
#, markdown-text, no-wrap
msgid "Keyword arguments: `:`\n"
msgstr ""

#. type: Bullet: '6. '
#: _posts/2010-01-01-c.markdown:588
#, markdown-text, no-wrap
msgid "A block argument: `&`\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:598
#, markdown-text, no-wrap
msgid ""
"Each section is optional, so you can leave out the characters for things "
"you\n"
"don't need. Be aware that the parsing of the format string is greedy: `1*`\n"
"describes a method with one mandatory argument and a splat. If you want "
"one\n"
"_optional_ argument and a splat you must specify `01*`. Following the "
"format\n"
"string, you must pass a `VALUE*` for each _Ruby_ argument. The number of\n"
"pointers passed should equal the \"total\" of the six sections, though you "
"can\n"
"pass `NULL` for an argument you don't care about. For example the format "
"string\n"
"`21*&` should have 5 `VALUE*`s passed (2 mandatory, 1 optional, 1 splatted, "
"1\n"
"block).\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:601
#, markdown-text, no-wrap
msgid ""
"`rb_scan_args()` unpacks `argv` using the `VALUE*`s you pass it and will\n"
"raise a fitting exception if the wrong number of arguments were passed.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:605
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/methodex.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:609
#, markdown-text, no-wrap
msgid ""
"You can also use the return value of `rb_scan_args()` to determine how the\n"
"function was called. It returns the number of arguments that were passed "
"in\n"
"Ruby.\n"
msgstr ""

#. type: Title ####
#: _posts/2010-01-01-c.markdown:610
#, markdown-text, no-wrap
msgid "Handling Blocks"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:613
#, markdown-text, no-wrap
msgid "There are two ways to check if your C method has been called with a block:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:617
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/checkblock.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:622
#, markdown-text, no-wrap
msgid ""
"There are two ways to capture the block as a proc. If you're using\n"
"`rb_scan_args()` for your method arguments, just include `&` in your "
"format\n"
"string to get it. If you aren't using `rb_scan_args()`, there's an API "
"call\n"
"equivalent to `Proc.new` which converts the method's block to a proc:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:625
#, markdown-text, no-wrap
msgid ""
"    VALUE block;\n"
"    block = rb_block_proc();\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:627
#, markdown-text, no-wrap
msgid ""
"If you don't want to capture the block, there are a few ways to yield to "
"it:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:631
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/yield.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:634
#, markdown-text, no-wrap
msgid ""
"There's also `rb_yield_values2()` which is like `rb_yield_values()` but "
"instead\n"
"of varargs the second argument is a `VALUE*`[^yield].\n"
msgstr ""

#. type: Title ####
#: _posts/2010-01-01-c.markdown:635
#, markdown-text, no-wrap
msgid "Super"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:638
#, markdown-text, no-wrap
msgid "You might want to call `super` in your method.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:642
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/super.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:648
#, markdown-text, no-wrap
msgid ""
"Unlike in Ruby `rb_call_super()` will **not** implicitly pass along the "
"method\n"
"arguments to the super if you give it no arguments. You must explicitly pass "
"the\n"
"correct `argc` and `argv` (it _does_ automatically pass `self`). For that "
"reason\n"
"I recommend using the C array style of method definition if you want to "
"use\n"
"`rb_call_super()`.\n"
msgstr ""

#. type: Title ####
#: _posts/2010-01-01-c.markdown:649
#, markdown-text, no-wrap
msgid "Definition"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:655
#, markdown-text, no-wrap
msgid ""
"Setting up the C function is the hard part, now it's easy to define the "
"method\n"
"in Ruby. Every API call to create a method takes at least the method name\n"
"(`char*`), a pointer to your C function, and an `argc` describing its "
"arguments.\n"
"`argc` should be:\n"
msgstr ""

#. type: Bullet: '1. '
#: _posts/2010-01-01-c.markdown:660
#, markdown-text, no-wrap
msgid ""
"For a fixed number of arguments, the number of arguments (not counting the\n"
"receiver)\n"
msgstr ""

#. type: Bullet: '2. '
#: _posts/2010-01-01-c.markdown:660
#, markdown-text, no-wrap
msgid "For a variable number of arguments in a C array, `-1`\n"
msgstr ""

#. type: Bullet: '3. '
#: _posts/2010-01-01-c.markdown:660
#, markdown-text, no-wrap
msgid "For a variable number of arguments in a Ruby Array, `-2`\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:662
#, markdown-text, no-wrap
msgid "Everything is pretty self-explanatory from there:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:666
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/methodr.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:670
#, markdown-text, no-wrap
msgid ""
"There's also a shortcut for defining a method in a module _and_ its\n"
"singleton class. This is used a lot in `Math`, for example, letting you "
"`include\n"
"Math` to avoid typing `Math.` before every method call.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:674
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/modulefunc.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:675
#, markdown-text, no-wrap
msgid "Other Stuff"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:678
#, markdown-text, no-wrap
msgid "Some simple API functions for class/method definitions:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:682
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/etc.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:683
#, markdown-text, no-wrap
msgid "Data"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:690
#, markdown-text, no-wrap
msgid ""
"By now you should be able to create and manipulate Ruby classes using the "
"API,\n"
"but how can you create a Ruby class that encapsulates data from the C world? "
"If\n"
"your data can be naturally translated into `VALUE`s it's easy: convert and\n"
"assign to instance variables as usual. But what if your data have no Ruby "
"analog\n"
"(e.g. data structures defined by some C library)?\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:697
#, markdown-text, no-wrap
msgid ""
"The API lets you encapsulate C data by creating a `VALUE` of the desired "
"class\n"
"and then storing a `void*` pointing to the C data inside the Ruby "
"object. Then\n"
"whenever you need access to the C data, you can unpack the pointer and cast "
"it\n"
"back to the correct type. But where does this encapsulation occur? Let's "
"answer\n"
"that question with a question: what happens when you tell Ruby to create "
"an\n"
"object using `new`? Basically this:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:701
#, markdown-text, no-wrap
msgid ""
"{% highlight ruby %}\n"
"{% include c/new.rb %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:707
#, markdown-text, no-wrap
msgid ""
"Before calling the _instance method_ `initialize` that we know so well, "
"`new`\n"
"first calls the _class method_ `allocate` to actually create the "
"object. That is\n"
"the method you'll need to define if you want your objects to wrap C "
"data. The\n"
"following example creates a class `Foo` which wraps an `int` that can be "
"set\n"
"by `initialize`:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:711
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/wrap.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:719
#, markdown-text, no-wrap
msgid ""
"In most cases you'll probably be wrapping something more complicated (like "
"a\n"
"`struct`), but the principles will be the same. After allocating the C data, "
"we\n"
"use the `TypedData_Wrap_Struct()`[^oldwrap] macro to wrap the pointer in a\n"
"`VALUE`. This wrapping takes three arguments: the class of the object "
"(`self`\n"
"because we're in a class method), a pointer to a struct, and the data "
"pointer to\n"
"be wrapped. The tricky part is the struct pointer; it provides additional\n"
"information for internal use by Ruby:\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:736
#, markdown-text, no-wrap
msgid ""
"`wrap_struct_name` is a string used by Ruby to identify your type. It "
"doesn't\n"
"really matter what it is as long as it's sensible and unique\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:736
#, markdown-text, no-wrap
msgid ""
"`function` is a struct containing several function pointers for use by the\n"
"garbage collector\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:736
#, markdown-text, no-wrap
msgid ""
"`dmark` will be described later, but as long your C data doesn't point to "
"any\n"
"Ruby objects you don't need it\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:736
#, markdown-text, no-wrap
msgid ""
"`dfree` will be called when your object is destroyed and should free all\n"
"memory allocated by the object\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:736
#, markdown-text, no-wrap
msgid ""
"`dsize` is called by Ruby to check how much memory your object is taking "
"up.\n"
"It _can_ be omitted, but it's polite to include it\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:736
#, markdown-text, no-wrap
msgid ""
"`data` can point to arbitrary data. Think of it as wrapping C data at a "
"class\n"
"level. Also not manadatory\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:736
#, markdown-text, no-wrap
msgid ""
"`flags` lets you enable additional optimizations when your objects are\n"
"garbage collected. As long as your `dfree` function doesn't unlock the\n"
"[GVL](#c-in-ruby-threads) (why would you do that???) you can safely set it "
"to\n"
"`RUBY_TYPED_FREE_IMMEDIATELY` for a slight performance improvement\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:741
#, markdown-text, no-wrap
msgid ""
"If you don't set some of these members, you should zero them out so that "
"Ruby\n"
"doesn't accidentally read garbage data. That's why I used C99's "
"[designated\n"
"initializer][desinit] syntax in the example above: any members you omit will "
"be\n"
"safely cleared by the compiler.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:743
#, markdown-text, no-wrap
msgid "[desinit]: https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:747
#, markdown-text, no-wrap
msgid ""
"`VALUE`s that wrap C data will have type `T_DATA` with respect to the "
"[`TYPE()`\n"
"macro](#value). This helps ensure a clear separation between native Ruby "
"objects\n"
"and those wrapping C data.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:752
#, markdown-text, no-wrap
msgid ""
"Once you've done all of that work to wrap up the C data, getting it back out "
"is\n"
"easy: `TypedData_Get_Struct()` takes the object to unwrap, the C type of "
"the\n"
"underlying data, the same struct pointer as before, and the pointer to "
"assign\n"
"the data to.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:758
#, markdown-text, no-wrap
msgid ""
"This separation of allocation and initialization doesn't jive with "
"[RAII][raii],\n"
"so if you're using C++ you will probably want to use [placement new][place] "
"when\n"
"wrapping data. If you're having trouble splitting up allocation and\n"
"initialization, you can just wrap your data in a `struct` and do the "
"_actual_\n"
"allocation in `initialize`.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:761
#, markdown-text, no-wrap
msgid ""
"[raii]: http://wikipedia.org/wiki/Resource_Acquisition_Is_Initialization\n"
"[place]: http://en.cppreference.com/w/cpp/language/new#Allocation\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:769
#, markdown-text, no-wrap
msgid ""
"In simple cases (like the previous example) you can make your code a little "
"less\n"
"verbose. If the function to free your data just calls `free()` as in the\n"
"example, you can pass `RUBY_DEFAULT_FREE` for `dfree` and Ruby will\n"
"free it for you (**don't** use `NULL` unless you like memory "
"leaks). Similarly,\n"
"if your allocation is just a `malloc()` as in the example, the macro\n"
"`TypedData_Make_Struct()` does the allocation for you _and_ wraps it. We "
"could\n"
"shorten the previous example as such:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:773
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/makestruct.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:774
#, markdown-text, no-wrap
msgid "Marking"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:783
#, markdown-text, no-wrap
msgid ""
"That `dmark` pointer in the type structure above is the pointer to your "
"object's\n"
"\"mark function\". This is so named because of the garbage collector's "
"\"mark and\n"
"sweep\" algorithm. The basic idea behind mark and sweep is that when the "
"garbage\n"
"collector needs to free up memory, it performs two passes: the first (mark) "
"pass\n"
"iterates through every _referenced_ Ruby object and marks it as active, then "
"the\n"
"second (sweep) pass iterates through every _allocated_ Ruby object and frees "
"the\n"
"ones that haven't been marked active.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:793
#, markdown-text, no-wrap
msgid ""
"This is relevant to wrapping C data because it's possible that you might "
"wrap a\n"
"C `struct` which contains a Ruby `VALUE`&mdash;which the garbage collector "
"is\n"
"responsible for cleaning up. Since the garbage collector is only aware of\n"
"`VALUE`s referenced _by Ruby_ (not by C pointers), it won't be able to mark "
"the\n"
"referenced `VALUE` as active. The result is that as soon as the garbage\n"
"collector needs to free up some memory, your C data is going to end up with "
"a\n"
"reference to a nonexistent Ruby object. Note that this kind of wrapping of "
"Ruby\n"
"data inside C data is a really bad idea, precisely because of this kind of\n"
"issue. But if you really must...\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:797
#, markdown-text, no-wrap
msgid ""
"In the following example, we'll wrap a C `struct` which contains a "
"`VALUE`. The\n"
"mark function has the same signature as the free function and all it has to "
"do\n"
"is mark any `VALUE`s in the `struct`:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:801
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/mark.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:806
#, markdown-text, no-wrap
msgid ""
"If your `struct` contains a pointer to a C array of `VALUE`s, you can "
"instead\n"
"use `rb_gc_mark_locations()` which takes two arguments: the pointers to "
"the\n"
"start and end of the array (the end being equal to the starting pointer plus "
"the\n"
"array length).[^maybe]\n"
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:807
#, markdown-text, no-wrap
msgid "Threading"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:809
#, markdown-text, no-wrap
msgid "Ruby in C Threads"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:819
#, markdown-text, no-wrap
msgid ""
"If you're making a lot of API calls and running a lot of Ruby code from C, "
"at\n"
"some point you might catch yourself thinking, \"I'm running all of these "
"slow\n"
"Ruby methods using the API. Maybe I can thread things to keep my code "
"fast!\"\n"
"That's a reasonable thought, but when you act on it keep in mind that **the "
"Ruby\n"
"VM is not at all thread safe**. Ideally, all of your API code should run in "
"a\n"
"single thread. If not, you'll probably need to wrap every API call with a "
"locked\n"
"mutex to make sure that you never ever have multiple threads interacting "
"with\n"
"the API at the same time.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:822
#, markdown-text, no-wrap
msgid ""
"If you just want to create normal Ruby `Thread`s using the API (and don't "
"mind\n"
"the GVL, as described in the next section), there's an easy way to do "
"that:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:826
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/thread.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:829
#, markdown-text, no-wrap
msgid ""
"Other `Thread` functions are in `ruby/intern.h` (but there's always\n"
"`rb_funcall()` for everything else).\n"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:830
#, markdown-text, no-wrap
msgid "C in Ruby Threads"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:838
#, markdown-text, no-wrap
msgid ""
"On the other hand, if you expose some heavy C code to Ruby with the API "
"(if\n"
"you're writing an extension that wraps a C library, for example), you "
"should\n"
"spend some time thinking about a nasty thing called the global VM lock "
"(GVL).\n"
"Because most of the API is not `Thread` safe, the GVL locks down almost all "
"Ruby\n"
"code so that only a single `Thread` can run at a time. This is the reason "
"why\n"
"you'll often hear people say that `Thread` does not allow true "
"parallelism.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:850
#, markdown-text, no-wrap
msgid ""
"The VM also applies the GVL to any C code you expose to Ruby. That's why you "
"can\n"
"use the API without worrying about it exploding when someone calls your C "
"code\n"
"from inside a `Thread`. The downside of this is that if your C code takes "
"a\n"
"while to run, you won't see any performance benefit from calling it in a\n"
"`Thread` because **it will block all other threads** while it runs. But the "
"GVL\n"
"is only needed to protect API calls. If you have some C code that doesn't "
"use\n"
"the API, you can tell the VM to release the GVL before running your code in "
"a\n"
"thread and to reacquire it when it completes, allowing for true "
"parallelism.\n"
"Locking and unlocking the GVL does carry a performance hit, so only resort "
"to\n"
"this if you notice that you're having significant problems due to blocked\n"
"threads.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:854
#, markdown-text, no-wrap
msgid ""
"The code to do this is considered so fancy by the Ruby developers that you\n"
"actually need to include another header to use it. First we'll look at the\n"
"slightly simpler way to release the GVL:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:858
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/gvl2.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:861
#, markdown-text, no-wrap
msgid ""
"Since the function that is run without the GVL gets and returns data using\n"
"`void*`, you may want to define a `struct` for passing data via pointers.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:866
#, markdown-text, no-wrap
msgid ""
"If you unlock the GVL as above you will find that while your code does run\n"
"in parallel, it can't be interrupted (by signals, `Thread.kill`, etc.)! To\n"
"allow for that you must pass an unblocking function using the last two\n"
"arguments:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:870
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/gvl.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:875
#, markdown-text, no-wrap
msgid ""
"The unblocking function is called in the event of an interrupt. To make it "
"work,\n"
"you will probably need to pass a pointer to both functions that can be used "
"to\n"
"communicate an interrupt from one to the other. The interrupted function "
"should\n"
"perform any necessary cleanup before returning early.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:880
#, markdown-text, no-wrap
msgid ""
"Alternatively, if the interrupted function doesn't _need_ to perform any "
"special\n"
"cleanup, you can use the built in unblocking function `RUBY_UBF_IO`[^ubf]\n"
"(which ignores the unblocking argument). That simply forwards the interrupt "
"to\n"
"the running thread.[^int]\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:884
#, markdown-text, no-wrap
msgid ""
"If you go through all of that effort to release the GVL only to find that "
"you\n"
"need to make an API call in your unlocked thread, there's a function to\n"
"temporarily reacquire the GVL:\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:888
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include c/with_gvl.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:889
#, markdown-text, no-wrap
msgid "See Also"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:891
#, markdown-text, no-wrap
msgid "extension.rdoc"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:897
#, markdown-text, no-wrap
msgid ""
"Ruby does have [official API documentation][readme]. It's a bit spotty and "
"has\n"
"some poor recommendations (in my opinion), but it is also a little more\n"
"exhaustive on certain topics. In many cases this is because I "
"intentionally\n"
"skipped something that I either found not useful or better documented "
"elsewhere.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:899
#, markdown-text, no-wrap
msgid "[readme]: https://github.com/ruby/ruby/blob/master/doc/extension.rdoc\n"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:900
#, markdown-text, no-wrap
msgid "Headers"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:910
#, markdown-text, no-wrap
msgid ""
"I think some of the handiest resources are the Ruby headers themselves. The "
"full\n"
"API (i.e. everything you get by including `ruby.h`) easily consists of a\n"
"thousand functions, macros, constants, and globals&mdash;most of which "
"have\n"
"never been documented. However _most_ things are reasonably named and you "
"should\n"
"be able to figure out what they do from the header. Most everything you "
"need\n"
"should be in the headers `ruby/ruby.h` and `ruby/intern.h`. The former has "
"all\n"
"of the VM and metaprogramming functions, the latter has all of the functions "
"for\n"
"interacting with Ruby's built in classes.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:914
#, markdown-text, no-wrap
msgid ""
"There are also some headers _not_ pulled in by `ruby.h` which you can "
"include to\n"
"get additional API functionality. Maybe one day I'll write another section "
"to\n"
"this guide going over them:\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:923
#, markdown-text, no-wrap
msgid "`ruby/debug.h` (experimental) functions for profiling and tracing code\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:923
#, markdown-text, no-wrap
msgid "`ruby/encoding.h` functions for working with string encodings\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:923
#, markdown-text, no-wrap
msgid "`ruby/io.h` additional functions for Ruby's IO class\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:923
#, markdown-text, no-wrap
msgid "`ruby/re.h` additional functions for Ruby's Regexp class\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:923
#, markdown-text, no-wrap
msgid "`ruby/thread.h` functions for working with the [GVL](#c-in-ruby-threads)\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:923
#, markdown-text, no-wrap
msgid ""
"`ruby/version.h` functions for version introspection. Do not use this as\n"
"feature-detection code!\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2010-01-01-c.markdown:923
#, markdown-text, no-wrap
msgid "`ruby/vm.h` (experimental) functions for VM control\n"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:924
#, markdown-text, no-wrap
msgid "Source"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:928
#, markdown-text, no-wrap
msgid ""
"If you find some function in the header that isn't documented anywhere, "
"your\n"
"next stop should be the Ruby source code.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:932
#, markdown-text, no-wrap
msgid ""
"{% highlight shell_session %}\n"
"$ git clone https://github.com/ruby/ruby.git\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:937
#, markdown-text, no-wrap
msgid ""
"When reading through the source code, always keep the headers at hand: there "
"are\n"
"lots of really useful functions in there that _look_ like they should be in "
"the\n"
"API, but actually aren't. In most cases there should be an API function\n"
"elsewhere that wraps the call to the useful function.\n"
msgstr ""

#. type: YAML Front Matter: title
#: _posts/2010-01-01-c.markdown:938 _posts/2014-01-01-examples.markdown:1
#, markdown-text, no-wrap
msgid "Examples"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:942
#, markdown-text, no-wrap
msgid ""
"Head over to the [Examples](../examples) page for short, compilable examples "
"of\n"
"the API in action.\n"
msgstr ""

#. type: Title ###
#: _posts/2010-01-01-c.markdown:943
#, markdown-text, no-wrap
msgid "Contribute"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:949
#, markdown-text, no-wrap
msgid ""
"Now that you've finished reading my guide, did you notice something "
"significant\n"
"that I left out? Did I make some stupid mistake? Check out the [source][gh] "
"for\n"
"this site on Github and you can report issues, submit pull requests, and\n"
"download all of the code examples.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:951
#, markdown-text, no-wrap
msgid "[gh]: https://github.com/silverhammermba/emberb\n"
msgstr ""

#. type: Title ##
#: _posts/2010-01-01-c.markdown:952 _posts/2012-01-01-embed.markdown:123
#: _posts/2013-01-01-extend.markdown:128
#, markdown-text, no-wrap
msgid "Footnotes"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:958
#, markdown-text, no-wrap
msgid ""
"[^intern]: That's a blatant lie. The API _definitely_ lets you mess around\n"
"           with the internal data structures of objects (look for things "
"with\n"
"           names starting with capital R). But it's generally not a good "
"idea\n"
"           and not necessary.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:963
#, markdown-text, no-wrap
msgid ""
"[^undef]: There's also `Qundef` representing an undefined value, but\n"
"          this has no Ruby equivalent and is [rarely](#handling-blocks)\n"
"          [used](#constants-1). In fact, outside of those rare occassions,\n"
"          `Qundef` can segfault the VM if Ruby was expecting a normal "
"`VALUE`.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:966
#, markdown-text, no-wrap
msgid ""
"[^wrap]: There's also `rb_eval_string_wrap()` which _should_ be useful, but "
"is\n"
"         actually the same as `rb_eval_string_protect()` due to a "
"[bug][bug2].\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:969
#, markdown-text, no-wrap
msgid ""
"[^chr]: There is a `CHR2FIX()` macro, but in my tests this sometimes gave\n"
"        unexpected results. `LONG2FIX()` should work.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:973
#, markdown-text, no-wrap
msgid ""
"[^wchar]: I don't know what the best way is to handle `wchar_t`. In my tests "
"I had\n"
"          some success just treating them as `char`s, but I think that may "
"have\n"
"          been a happy accident, and could certainly fail on different "
"platforms.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:978
#, markdown-text, no-wrap
msgid ""
"[^clear]: The documentation [states][control] that \"You have to clear the "
"error\n"
"          info [when] ignoring the caught exception\" during "
"`rb_protect`. But I\n"
"          can't find any documentation of when it would be cleared for\n"
"          you&mdash;it seems like you _always_ have to clear it.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:981
#, markdown-text, no-wrap
msgid ""
"[^yield]: And there's `rb_yield_block()` which takes two unused arguments "
"and is\n"
"          never called by anything in Ruby. Odd.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:985
#, markdown-text, no-wrap
msgid ""
"[^break]: The documentation [mentions][control] `rb_iter_break()` and\n"
"          `rb_iter_break_value()` for breaking out of a block, but can't "
"you\n"
"          just return early? I can't think of a use-case for these.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:991
#, markdown-text, no-wrap
msgid ""
"[^int]: There is also the function `rb_thread_call_without_gvl2()`. The\n"
"        documentation in `thread.c` says that if it \"detects interrupt, "
"it\n"
"        returns immediately,\" but I'm not sure what this means. If the\n"
"        unblocking function doesn't kill the thread, it still waits for "
"the\n"
"        thread to finish on its own before returning.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:994
#, markdown-text, no-wrap
msgid ""
"[^ubf]: You can also use `RUBY_UBF_PROCESS`, but this seems to be a "
"leftover\n"
"        from deprecated code and has the exact same effect.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:999
#, markdown-text, no-wrap
msgid ""
"[^oldwrap]: The `TypedData*` macros are the preferred way to wrap data "
"since\n"
"            Ruby 1.9.2. If you're using an older version of Ruby you can "
"check\n"
"            out an older version of this guide on Github to see how it used "
"to\n"
"            be done.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:1002
#, markdown-text, no-wrap
msgid ""
"[^maybe]: There's also the enigmatically named `rb_gc_mark_maybe()`, but I'm "
"not\n"
"          sure when it is needed.\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:1004
#, markdown-text, no-wrap
msgid "[^tdata]: Or use `T_DATA` if the object [wraps a C pointer](#data).\n"
msgstr ""

#. type: Plain text
#: _posts/2010-01-01-c.markdown:1006
#, markdown-text, no-wrap
msgid ""
"[control]: "
"https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-Control+Structure\n"
"[bug2]: https://bugs.ruby-lang.org/issues/10466\n"
msgstr ""

#. type: Title ##
#: _posts/2012-01-01-embed.markdown:1 _posts/2014-01-01-examples.markdown:6
#, markdown-text, no-wrap
msgid "Running Ruby in C"
msgstr ""

#. type: Title ##
#: _posts/2012-01-01-embed.markdown:6 _posts/2013-01-01-extend.markdown:6
#, markdown-text, no-wrap
msgid "Compiling"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:12
#, markdown-text, no-wrap
msgid ""
"Embedding Ruby requires one header `ruby.h`, which includes a "
"platform-specific\n"
"header `ruby/config.h`. You will probably need to tell your compiler about "
"the\n"
"include paths for these headers. You will also need to link with the Ruby "
"lib.\n"
"On my machine, my minimal compiler options are\n"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:16
#, markdown-text, no-wrap
msgid ""
"{% highlight shell_session %}\n"
"$ gcc -I/usr/include/ruby-{{ site.rbversion }}.0 -I/usr/include/ruby-{{ "
"site.rbversion }}.0/x86_64-linux -lruby\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:19
#, markdown-text, no-wrap
msgid ""
"Though, if available, you should really use `pkg-config` to get the "
"appropriate\n"
"options for your distribution:\n"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:23
#, markdown-text, no-wrap
msgid ""
"{% highlight shell_session %}\n"
"$ pkg-config --cflags --libs ruby-{{ site.rbversion }}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Title ##
#: _posts/2012-01-01-embed.markdown:24
#, markdown-text, no-wrap
msgid "Startup, Teardown"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:29
#, markdown-text, no-wrap
msgid ""
"Including the Ruby interpreter in your C/C++ program is pretty "
"simple. Just\n"
"include the header, call a startup function in `main` before you use the "
"API,\n"
"and a cleanup function after you're done:\n"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:33
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include embed/simple.c %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:38
#, markdown-text, no-wrap
msgid ""
"If the VM fails to start during `ruby_init()` it will print an error and "
"exit\n"
"your program! If you would rather have a softer error, you can instead "
"call\n"
"`ruby_setup()` which returns a nonzero value if a failure occurred\n"
"(unfortunately it is not clear how to get a message for the error[^err]).\n"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:43
#, markdown-text, no-wrap
msgid ""
"If an error occurs during `rb_cleanup()`, it returns a nonzero\n"
"value&mdash;otherwise it returns the argument you passed it. This allows a\n"
"little shortcut for returning an error status if the cleanup fails (as\n"
"demonstrated in the previous example).\n"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:52
#, markdown-text, no-wrap
msgid ""
"_Technically_ you don't have to call `ruby_init`/`ruby_setup` in `main`, but "
"the\n"
"Ruby VM assumes that all future Ruby code will be run from the same stack "
"frame\n"
"or a lower one (for garbage collection purposes). The easiest way to ensure "
"this\n"
"is to do set up at the top-level of your program, though other approaches "
"could\n"
"work. But it would be a bad idea, for example, to init Ruby in some\n"
"deeply-nested function, pop a bunch of stack frames, and then run a bunch "
"of\n"
"Ruby code.\n"
"{: .alert .alert-danger}\n"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:58
#, markdown-text, no-wrap
msgid ""
"During cleanup, the VM might evaluate more Ruby code (if you passed a block "
"to\n"
"`at_exit`, for example) which could raise an exception. `ruby_cleanup()` "
"handles\n"
"these by returning a nonzero value and printing an error message. If you "
"instead\n"
"call `ruby_finalize()` they will be raised normally (see the section on\n"
"[Exceptions](../c#rescue) for how to handle them).\n"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:60
#, markdown-text, no-wrap
msgid "Here's an alternative example:\n"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:64
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include embed/advanced.c %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Title ###
#: _posts/2012-01-01-embed.markdown:65
#, markdown-text, no-wrap
msgid "Limitations"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:73
#, markdown-text, no-wrap
msgid ""
"Other than the stack frame warning above, there is another limitation: you "
"only\n"
"get one Ruby VM per process. The startup/teardown might make it look like "
"you\n"
"can keep on destroying and rebuilding the VM over and over again, but\n"
"`ruby_cleanup` only makes sure that your Ruby code is all cleaned up and "
"done.\n"
"It doesn't fully clean up the VM state such that it is ready to be\n"
"re-initialized: if you call `ruby_init` again, it will fail.\n"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:76
#, markdown-text, no-wrap
msgid ""
"If for some reason you need multiple Ruby VMs in your program, you will need "
"to\n"
"spin them off in multiple processes to bypass this limitation.\n"
msgstr ""

#. type: Title ##
#: _posts/2012-01-01-embed.markdown:77
#, markdown-text, no-wrap
msgid "Tweaking the VM"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:82
#, markdown-text, no-wrap
msgid ""
"You now have a bare-bones Ruby VM running, but you may want to set up a "
"little\n"
"more stuff before you start running Ruby code. To set the name of the Ruby\n"
"script (e.g. `$0`) for error messages and such, use\n"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:86
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"ruby_script(\"new name\")\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:88
#, markdown-text, no-wrap
msgid "To set up the load path so that gems can be loaded with `require`, use\n"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:92
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"ruby_init_loadpath()\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:96
#, markdown-text, no-wrap
msgid ""
"You can also pass options to the VM just like you would to `ruby` on the "
"command\n"
"line. This is handy for stuff like setting the warning level or verbose\n"
"mode[^opt].\n"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:100
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include embed/options.c %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:106
#, markdown-text, no-wrap
msgid ""
"The arguments to `ruby_options` are `argc` and `argv` just like a main "
"function.\n"
"And just like the main of the `ruby` program, the VM expects to get some "
"Ruby\n"
"code when you call it. If you don't give it the filename of a script to load "
"or\n"
"code to run with `-e`, it will try to read from `stdin`. If you want to "
"set\n"
"options but _not_ run any Ruby code, you can pass it an empty line: `\"-e "
"\"`.\n"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:115
#, markdown-text, no-wrap
msgid ""
"`ruby_options()` returns a \"node\" that represents the compiled Ruby "
"code. In some\n"
"cases (such as a syntax error) the node will be invalid and you shouldn't "
"run\n"
"it. `ruby_executable_node()` checks for this. If the node is valid, you can "
"run it\n"
"with `ruby_exec_node()`. The state returned by `ruby_executable_node()` "
"(through\n"
"the pointer) and by `ruby_exec_node()` will be nonzero if an exception was\n"
"raised while compiling or running the code. You can [read the exception\n"
"yourself](../c#rescue), or just pass `state` to `ruby_cleanup()` and it "
"will\n"
"print an appropriate error message.\n"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:118
#, markdown-text, no-wrap
msgid ""
"Ruby currently doesn't support any other way of compiling and running code\n"
"separately[^load].\n"
msgstr ""

#. type: Title ##
#: _posts/2012-01-01-embed.markdown:119 _posts/2013-01-01-extend.markdown:105
#, markdown-text, no-wrap
msgid "Success"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:122
#, markdown-text, no-wrap
msgid "Now you're ready to interact with Ruby! Go back to the [C API](../c).\n"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:127
#, markdown-text, no-wrap
msgid ""
"[^err]: `ruby_init()` uses `error_print()` to get an error message, but "
"this\n"
"        function isn't exposed to the API. Is this a normal exception?\n"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:131
#, markdown-text, no-wrap
msgid ""
"[^opt]: In my tests I couldn't get flags like `-w` and `-v` to do "
"anything. This\n"
"        could be related to `ruby_prog_init()`. And really it should be "
"possible\n"
"        to do this without parsing command line options.\n"
msgstr ""

#. type: Plain text
#: _posts/2012-01-01-embed.markdown:133
#, markdown-text, no-wrap
msgid ""
"[^load]: It looks like the function `rb_load_file()` should do this, but I\n"
"         haven't had any luck getting it to work.\n"
msgstr ""

#. type: Title ##
#: _posts/2013-01-01-extend.markdown:1 _posts/2014-01-01-examples.markdown:35
#, markdown-text, no-wrap
msgid "Running C in Ruby"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:11
#, markdown-text, no-wrap
msgid ""
"Compiling C code to be loaded as a Ruby extension requires some fancy "
"compiler\n"
"options. Ruby's [`mkmf` stdlib][mkmf] makes it easy to do this by generating "
"an\n"
"appropriate makefile for you.\n"
msgstr ""

#. type: Title ###
#: _posts/2013-01-01-extend.markdown:12
#, markdown-text, no-wrap
msgid "Preparation"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:15
#, markdown-text, no-wrap
msgid "First create the file `extconf.rb` in the same directory as your C code:\n"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:19
#, markdown-text, no-wrap
msgid ""
"{% highlight ruby %}\n"
"{% include extend/ext/extconf.rb %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:22
#, markdown-text, no-wrap
msgid ""
"The preparation section should perform actions similar to the standard "
"UNIX\n"
"[`configure` script][conf] e.g.\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2013-01-01-extend.markdown:26
#, markdown-text, no-wrap
msgid "Check features of the current platform\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2013-01-01-extend.markdown:26
#, markdown-text, no-wrap
msgid "Check for existence of required libraries and functions\n"
msgstr ""

#. type: Bullet: '* '
#: _posts/2013-01-01-extend.markdown:26
#, markdown-text, no-wrap
msgid "Check for programs needed for building\n"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:28
#, markdown-text, no-wrap
msgid "[conf]: http://en.wikipedia.org/wiki/Configure_script\n"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:32
#, markdown-text, no-wrap
msgid ""
"The most common of these actions are provided by `mkmf` (but you have all "
"of\n"
"Ruby at your disposal if you need it). For example, an extension which uses "
"SDL2\n"
"and needs to know how big `int`s are might call:\n"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:36
#, markdown-text, no-wrap
msgid ""
"{% highlight ruby %}\n"
"{% include extend/ext/exex.rb %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:40
#, markdown-text, no-wrap
msgid ""
"`create_header` creates the file `extconf.h` containing preprocessor "
"definitions\n"
"based on the results of the `mkmf` functions you called previously. For "
"this\n"
"example, `extconf.h` might contain\n"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:44
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include extend/ext/exh.h %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:52
#, markdown-text, no-wrap
msgid ""
"This header should be included in your C files so that you can adapt your "
"code\n"
"to a variety of platforms. Note that you can and should abort the "
"`extconf.rb`\n"
"script if a `mkmf` function returns a value that indicates that the build "
"will\n"
"fail. For example, if SDL2 is a _requirement_ of your extension you should "
"exit\n"
"with some meaningful error message if `have_library('SDL2')` returns "
"`false`.\n"
"This is preferred to generating the Makefile anyway and leaving the user "
"with an\n"
"opaque compiler error.\n"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:57
#, markdown-text, no-wrap
msgid ""
"`create_makefile` obviously creates the Makefile, but its argument is "
"especially\n"
"important: it defines the entry point of your C code, the name of the "
"compiled\n"
"library, and thus the argument for `require` in Ruby! This should be the "
"name of\n"
"your extension.\n"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:63
#, markdown-text, no-wrap
msgid ""
"You can modify a few of the generated Makefile variables by modifying the\n"
"corresponding globals in Ruby: `$CFLAGS`, `$CPPFLAGS`, and "
"`$LDFLAGS`[^glob].\n"
"You can also use the `$objs` global to define a list of object files for "
"the\n"
"Makefile if its method of automatically generating targets doesn't work "
"for\n"
"your extension.\n"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:68
#, markdown-text, no-wrap
msgid ""
"All of the `mkmf` functions and their options are well-documented\n"
"[online][mkmf]. In addition to the functions for generating `extconf.h`, "
"there\n"
"are a variety of functions for handling different source file layouts, "
"different\n"
"file dependencies, etc.\n"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:70
#, markdown-text, no-wrap
msgid "[mkmf]: http://www.ruby-doc.org/stdlib/libdoc/mkmf/rdoc/MakeMakefile.html\n"
msgstr ""

#. type: Title ###
#: _posts/2013-01-01-extend.markdown:71
#, markdown-text, no-wrap
msgid "Execution"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:74
#, markdown-text, no-wrap
msgid "The rest couldn't be simpler\n"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:79
#, markdown-text, no-wrap
msgid ""
"{% highlight shell_session %}\n"
"$ ruby extconf.rb\n"
"$ make\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:81
#, markdown-text, no-wrap
msgid ""
"[^argv]But of course that won't do anything without some C code to "
"compile.\n"
msgstr ""

#. type: Title ##
#: _posts/2013-01-01-extend.markdown:82
#, markdown-text, no-wrap
msgid "Init"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:89
#, markdown-text, no-wrap
msgid ""
"In your C code, you'll want to include `ruby.h` to access the API. Other "
"than\n"
"that the only requirement is to define a function for the Ruby VM to call "
"when\n"
"your library is `require`d. The name of the function is determined by the\n"
"argument you passed to `create_makefile` in `extconf.rb`. We used \"foobar\" "
"in\n"
"our example, so we'll create `foobar.c` containing\n"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:93
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include extend/ext/foobar.c %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Title ###
#: _posts/2013-01-01-extend.markdown:94
#, markdown-text, no-wrap
msgid "Filenames"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:101
#, markdown-text, no-wrap
msgid ""
"If your extension has only a single C file, you should name it after your\n"
"extension as we did above. If your extensions has multiple C files _do not_ "
"name\n"
"any of them after your extension. This is because the Makefile may generate "
"a\n"
"`.o` file named after your extension for the linking stage, which would "
"cause a\n"
"conflict if you also have a `.c` file which compiles to that filename.\n"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:104
#, markdown-text, no-wrap
msgid ""
"Also avoid naming any files `conftest.c` as this file may be written to by\n"
"`mkmf`.\n"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:111
#, markdown-text, no-wrap
msgid ""
"Now make should compile a `.so` (or some other library) file which you can\n"
"`require` in Ruby. You can fill in your `Init` function with plain C code, "
"but\n"
"you'll probably want to go back and learn about the [C API](../c) to do "
"more\n"
"interesting stuff.\n"
msgstr ""

#. type: Title ##
#: _posts/2013-01-01-extend.markdown:112
#, markdown-text, no-wrap
msgid "Gem"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:118
#, markdown-text, no-wrap
msgid ""
"After you've got your extension working nicely, you may want to bundle it up "
"as\n"
"an easily distributable Ruby gem. rubygems.org has a [detailed guide][rbg] "
"on\n"
"creating gems, but as far as C extensions go you just need to tell the "
"spec\n"
"about `extconf.rb`[^rbg]:\n"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:122
#, markdown-text, no-wrap
msgid ""
"{% highlight ruby %}\n"
"{% include extend/foobar.gemspec %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:125
#, markdown-text, no-wrap
msgid ""
"If your gem includes multiple independent extensions, you can organize them "
"in\n"
"subdirectories of `ext/` and pass all of the `extconf.rb`s to the spec.\n"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:127
#, markdown-text, no-wrap
msgid "[rbg]: http://guides.rubygems.org/make-your-own-gem/\n"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:131
#, markdown-text, no-wrap
msgid "[^glob]: Check the [official documentation][globals].\n"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:135
#, markdown-text, no-wrap
msgid ""
"[^argv]: The official documentation [hints][makefile] that `mkmf` parses "
"certain\n"
"         command line flags e.g.  `--vendor`. But I can't find this "
"documented\n"
"         anywhere.\n"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:137
#, markdown-text, no-wrap
msgid ""
"[^rbg]: "
"[http://guides.rubygems.org/gems-with-extensions/](http://guides.rubygems.org/gems-with-extensions/)\n"
msgstr ""

#. type: Plain text
#: _posts/2013-01-01-extend.markdown:139
#, markdown-text, no-wrap
msgid ""
"[globals]: "
"https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-Prepare+extconf.rb\n"
"[makefile]: "
"https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-Generate+Makefile\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:14
#, markdown-text, no-wrap
msgid ""
"This example is a simple little game of tag. In the game there are two "
"squares:\n"
"the blue square is controlled using the arrow keys on the keyboard while the "
"red\n"
"square is controlled by a Ruby script. To make this work, we'll use the C "
"API to\n"
"define a little Ruby API that the script can access, and every couple of "
"frames\n"
"we'll call a method defined in the Ruby script and pass objects "
"encapsulating\n"
"the data for the two squares.\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:16
#, markdown-text, no-wrap
msgid "The Ruby script can look something like this:\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:20
#, markdown-text, no-wrap
msgid ""
"{% highlight ruby %}\n"
"{% include examples/ai.rb %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:24
#, markdown-text, no-wrap
msgid ""
"The C code uses SDL2 for graphics and input and uses `stat()` (which may not "
"be\n"
"very portable) to hot-reload the AI script whenever the file is changed "
". Here's\n"
"`tag.c`:\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:28
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include examples/tag.c %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:30
#, markdown-text, no-wrap
msgid "The Makefile is nothing special:\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:34
#, markdown-text, no-wrap
msgid ""
"{% highlight make %}\n"
"{% include examples/Makefile %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:42
#, markdown-text, no-wrap
msgid ""
"This example is a Ruby C extension that wraps the [GMP][gmp] C library for\n"
"arbitrary precision arithmetic. This is far from a complete example: it "
"only\n"
"wraps the integer functions, implements only the basic functionality of "
"the\n"
"library, and doesn't bother nicely integrating with Ruby's existing "
"numeric\n"
"types. If you want a _really_ full example, check out the [GMP gem][gem].\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:45
#, markdown-text, no-wrap
msgid ""
"[gmp]: https://gmplib.org/\n"
"[gem]: https://github.com/srawlins/gmp\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:47
#, markdown-text, no-wrap
msgid "Everything is in `gmp.c` where we define our `GMP::Integer` class:\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:51
#, markdown-text, no-wrap
msgid ""
"{% highlight c %}\n"
"{% include examples/ext/gmp.c %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:53
#, markdown-text, no-wrap
msgid "The `extconf.rb` is really simple.\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:57
#, markdown-text, no-wrap
msgid ""
"{% highlight ruby %}\n"
"{% include examples/ext/extconf.rb %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:59
#, markdown-text, no-wrap
msgid "And now you can finally find out what your name means in base 62:\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:63
#, markdown-text, no-wrap
msgid ""
"{% highlight ruby %}\n"
"{% include examples/gmp_ex.rb %}\n"
"{% endhighlight %}\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:70
#, markdown-text, no-wrap
msgid ""
"For this example I tried to do everything in C, but practically that isn't\n"
"necessary (or desirable). If one of your C methods just calls a bunch of "
"API\n"
"functions (like `to_i` and `==` in the example), you're probably only "
"saving\n"
"yourself a couple CPU cycles compared to implementing the method in "
"Ruby. And of\n"
"course that comes at the cost of needing to spend more time writing C and "
"less\n"
"time writing Ruby. ð\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:75
#, markdown-text, no-wrap
msgid ""
"A common convention when writing extensions is to only implement the "
"\"meat\" of\n"
"the extension in C and to do everything else in a regular Ruby script that "
"pulls\n"
"in the compiled library. For example, we could have written a `gmp.rb` "
"script to\n"
"significantly simplify our extension:\n"
msgstr ""

#. type: Plain text
#: _posts/2014-01-01-examples.markdown:78
#, markdown-text, no-wrap
msgid ""
"{% highlight ruby %}\n"
"{% include examples/gmp.rb %}\n"
"{% endhighlight %}\n"
msgstr ""
