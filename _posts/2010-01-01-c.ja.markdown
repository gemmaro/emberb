---
layout: chapter
title: 'RubyのC API'
---

## 始める前に ##

このガイドを完全に理解するためには、C言語はそこそこ、Rubyは _かなり_ 慣れ親しんでいるとよいでしょう。

RubyのC APIを使うのに発展的なC言語の概念は要りませんが、
APIは**膨大**で大半が**文書化されていません**。
APIを使い始めだすと、いつの日にか、
はっきりしない関数やマクロの振舞いを見つけるためにRubyのソースコードを探ることになるでしょう。
Rubyのソースはそこそこ洗練されたC言語で書かれているので、
すいすい読めはするでしょうけれども。

C APIは、普通のRubyのコードよりもデカくてゴチャっとした書き方だと見なせます。
とはいえ、簡素で明快なRubyの様式は、ひとたびAPIの言葉に翻訳されるとかなり非直感的になることがあります。
Rubyの内部論理と設計の背後にある思想に裏打ちされたしっかりとした直感があれば、
長い旅路のさなかでも正しいAPI関数へと進み続けられるでしょう。

## 分岐点 ##

公式のRubyインタプリタはC言語で書かれています。
Rubyでできるあらゆることは、RubyのC APIを呼び出す関数を使ってもできます。
いったいなぜそんなことをするのでしょうか？
もっともな理由が2つあります。

1. 意匠を凝らしたC言語ないしC++のアプリケーションを書いている最中で、
   Rubyの動的な柔軟性をコードのいくつかの箇所に使って、
   効果を引き出そうとするとき。
   アプリケーションの内部でRubyインタプリタを実行でき、
   Rubyのコードの結果をAPIで受け取ることができます。
2. 意匠を凝らしたRubyのアプリケーションを書いている最中で、
   C言語（もしくは既にあるC言語のライブラリ）の速度と能力を
   コードのいくつかの箇所に使って、
   効果を引き出そうとするとき。
   APIを使えば、RubyにC言語のコードをさらけ出すことができます。
   そうしてできた特別なライブラリをコンパイルするとRubyから `require` できます。

目標によってC言語のコードの組み立てかたは変わってきます。
C言語にRubyインタプリタを組込みたければ、
[C言語でRubyを実行する](../embed.ja)をお読みください。
コンパイルされたC言語のライブラリを `require` したければ、
[RubyでC言語を実行する](../extend.ja)をお読みください。
どちらかを読み終えたら、ここに戻ってきてAPIについて学びましょう。

## Eval ##

ちゃちゃっと雑にCでRubyを動かすには、 `eval` します。

{% highlight c %}
{% include c/eval.h %}
{% endhighlight %}

これはやりたいことのためのAPI関数が見つからないときは選択肢に入ります[^wrap]。
`rb_eval_string_protect()` はRubyのコードの結果を返し、
何か例外が発生したときはゼロではない値を `state` に設定します。
`VALUE` はあらゆるRubyのオブジェクトのためのCのデータ型です。
次の節で後述します。

`state` がゼロではないとき、
`result` は `nil` を表す `VALUE` になっているでしょうから、
そのときは例外に対処しなければいけません。
代わりに `rb_eval_string()` を使うこともできます。
この関数は引数 `state` を取らず、通常の方法で例外を発生させます。
これら2つの場合での制御方法については[例外](#exceptions)節を参照してください。

Rubyでの `eval` とは異なり、
これらの関数は独立の束縛状態で評価します。
ちょうど何かを `require` するときと同じです。
したがって文字列中のローカル変数は他の場所から参照できませんし、逆もまた然りです。

しかし、Rubyで `eval` するときのように、
これらの関数を使うことはあまりよくありません。
パーサが起動されなければいけないのが非効率ですし、
Cで書くことの利点が失われています。
Rubyのメソッドを呼びたいだけであれば、
もっといい方法を[後述](#send)します。

## VALUE ##

先に進む前に、
`VALUE` について理解しなければいけません。
VMの内部をめちゃくちゃにしてしまう危険があるので、
APIからは直接Rubyのオブジェクトを扱えません[^intern]。
その代わり、CのコードはRubyのオブジェクトへの _ポインタ_
を保持したり受け渡したりします（Rubyの変数がオブジェクトへのポインタを持つのと同じです）。
ポインタはさまざまなAPIの関数やマクロに渡すことができ、
そのためRubyのオブジェクトに安全にアクセスしたり操作したりできます。
`VALUE` はAPIで定義されたCの型で、このポインタを扱います。

おそらく最も頻繁に湧いてくる疑問は次のようなものでしょう。
「この `VALUE` は正しい型なのだろうか？」
この疑問に答えるマクロは2つあり、
そのどちらも[`T_` 定数](datatypes)を引数に取ります。
この定数は比較したい型に対応するRubyのクラスです。
例えば `T_STRING` や `T_ARRAY` などです。

[datatypes]:
https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-Data+Types

{% highlight c %}
{% include c/checktype.h %}
{% endhighlight %}

この検査はサブクラスでも同様にはたらきます。
`Array` のサブクラスであることを確認したいときは `T_ARRAY` を使いますし、
`Object` のサブクラスであることを確認したいときには `T_OBJECT` を使います[^tdata]。
つまり、この検査は _`is_a?` と同じではない_ ということでもあります。
Rubyのありとあらゆるものについて `is_a? Object` であるにせよ、
`T_OBJECT` に対する検査は、
他にもっと適した定数がないときにのみ真となります。

特定のクラスには、前述したものより少し効率的なマクロが使えます。

{% highlight c %}
{% include c/check_p.h %}
{% endhighlight %}

いくつかの型を取りうる `VALUE` を扱いたいときは、
前述のマクロはちょっと不恰好です。
そんな場合は `TYPE()` マクロを使って `T_` 定数を取得し、
`switch` 文で制御できます。

{% highlight c %}
{% include c/type.h %}
{% endhighlight %}

### 定数 ###

ほとんどの標準的なRubyの定数はAPIで大域的な `VALUE` が定義されています。
したがってそれらの定数を使うのにAPIの呼び出しは要りません。
モジュールは `rb_m` で前置されます。
たとえば `rb_mKernel` です。
クラスは `rb_c` で前置されます。
たとえば `rb_cObject` です。
`Exception` のサブクラスは `rb_e` で前置されます。
たとえば `rb_eRubtimeError` です。
標準的なIOストリームは `rb_` で前置されます。
たとえば `rb_stderr` です。
`nil`, `false`, `true` は `Q` で前置されます。
例えば `Qnil` です。
[^undef] 便宜上、 `Qfalse` はCの偽値 (`0`) でもあります。

### 変換 ###

いくつかのRubyのクラスはCの型に対応します。
この対応する組み合わせは、CとRubyの間のデータのやりとりをするには一番です。

#### Fixnum ####

Rubyの `Fixnum` はCの `long` に対応します。
`FIX2LONG()` マクロにより、 `long` を `Fixnum` に変換できます。
より小さいCの型については、
`FIX2UINT()`, `FIX2INT()`, `FIX2SHORT()` があります。
しかし、これらのマクロは変換時に数値が大きすぎて収まらない場合は `RangeError` を生じます。

逆向きの変換もできて、
`LONG2FIX()` は `long` *に加えて* `long` より小さい全てのCの整数型からの変換に使えます。

#### Bignum ####

Rubyの `Bignum` は `Fixnum` より大きいあらゆる整数に使えます。
例えば `long long` が必要なときとかです。
`rb_big2()` と `rb_big2u()` を使えば、 `Bignum` から
それぞれ `long long` や `unsigned long long` に直せます。
（もしくは `RangeError` が発生します。）

逆向きの変換については [数値](#numeric) を参照してください。

#### Float ####

Rubyの `Float` はCの `double` に対応します。
`RFLOAT_VALUE()` マクロを使えば、 `Float` から `double` が得られます。

逆向きの変換については [数値](#numeric) を参照してください。

#### Numeric ####

たくさんの "NUM" マクロがあり、
ダックタイピングっぽい使いかたをしています。
これらのマクロはCの型を適切と思われるRubyの `Numeric` のサブクラス（のインスタンス）に変換します。

* `INT2NUM()` は `int` からの変換用
* `UINT2NUM()` は `unsigned int` からの変換用
* `LONG2NUM()` は `long` からの変換用
* `ULONG2NUM()` は `unsigned long` からの変換用
* `LL2NUM()` は `long long` からの変換用
* `ULL2NUM()` は `unsigned long long` からの変換用
* `DBL2NUM()` は `double` からの変換用

そして、逆方向のマクロもあります。
これらのマクロは、あらゆる `Numeric` な数値から欲しいCの型の値への変換を試みるものです。
値が範囲に収まらなかったときは `RangeError` を発生させますし、
暗黙の数値の変換ができなかったときは `TypeError` が発生します。
（なので `Numeric` ではないオブジェクトを渡しても大丈夫です。）

* `NUM2CHR()` は `char` からの変換用（`unsigned char` からでも変換できます）
* `NUM2SHORT()` は `short` からの変換用
* `NUM2USHORT()` は `unsigned short` からの変換用
* `NUM2INT()` は `int` からの変換用
* `NUM2UINT()` は `unsigned int` からの変換用
* `NUM2LONG()` は `long` からの変換用
* `NUM2ULONG()` は `unsigned long` からの変換用
* `NUM2LL()` は `long long` からの変換用
* `NUM2ULL()` は `unsigned long long` からの変換用
* `NUM2DBL()` は `double` からの変換用

これらのマクロについて **特に** 注意すべき点は、
符号なしの型に変換に変換する *どの* マクロも、負値を渡したときに例外が発生しないということです。
（驚くべきことに[バグではありません][bug]。）
`NUM2CHR()` にはもう2つ妙なところがあります。
変換前の値が _int_ には大きすぎるときに `RangeError` のみ生じることと、
文字列を渡したときに `TypeError` を発生させず最初の文字の数値を返すということです。

変換が安全だとわかっていれば、
前の節のマクロのほうを使うべきです。
なぜなら範囲の確認を省けるためです。

[bug]: https://bugs.ruby-lang.org/issues/9089

#### String ####

Rubyの `String` はだいたいCの `char*` に対応します。
もっとも簡素なマクロは `StringValueCStr()` です。
このマクロは `String` からnull終端付きの `char*` を返します。
ただしこれには問題があって、Rubyの `String` が *nullを含むかもしれません*。
そのような場合には `StringValueCStr()` は `ArgumentError` を発生させます！
その代わりに `StringValuePtr()` マクロと `RSTRING_LEN()` マクロを使えば、それぞれ
（終端が付いていない可能性がある） `char*` とその長さの `long` 値を取得できます。

逆に、null終端付きの `char*` からRubyの `String` への変換には、
`rb_str_new_cstr()` が使えます。
そして、もし `String` にnullを含めたいときは、
`rb_str_new()` を使います。
`rb_str_new()` は `char*` と文字列の長さ（型は `long`）を引数に取ります。
これらの文字列のエンコーディングは `ASCII-8BIT` なのですが、
Ruby側のコードで望んだものではないこともあります。
そんなときは文字列の `VALUE` を `rb_str_export_locale()` に渡して、
自分のロケールのエンコーディングでの `VALUE` を取得することができます。

もっと複雑な文字列を構築したければ、
`printf` のような関数 `rb_sprintf()` でできます。
この関数では通常の変換での全ての指定子だけではなく、
APIで定義された指定子 `PRIsVALUE` も使えます。
`PRIsVALUE` は対応する `VALUE` を引数に取ります。
この変換指定子はオブジェクトに `to_s` メッセージを送って文字列にに置き換えます。
`+` フラグを加えることで `inspect` を使った結果の文字列に置き換えることもできます。

{% highlight c %}
{% include c/printf.h %}
{% endhighlight %}

この自前の指定子はAPIにあるあらゆる `printf` っぽい関数で使えるでしょう。
`PRIsVALUE` は `i` 変換指定子を乗っ取ることで実現されているので、
`int` を文字列にするときは `d` を使って、
Rubyに「それって実は `VALUE` なんじゃないか」と勘違いさせないようにするべきです。

#### Symbol ####

APIではRubyの `Symbol` に対応するCの型 `ID` が定義されています。
Rubyが `Symbol` をメソッドや変数名として受け渡しするように、
多くのAPI呼び出しでメソッドや変数の名前を `ID` を使うようにしています。
`Symbol` と `ID` を変換するには、 `SYM2ID()` と `ID2SYM()` マクロを使います。
`Symbol` ではなくCの文字列 `char*` との双方向に変換したいときもあるでしょう。
`char*` から `ID` を取得するためには `rb_intern()` を、
その逆向きでは `rb_id2name()` を使います。

多くのAPI関数が `ID` を必要としていますが、
適切な `ID` が手元にないことも沢山あるでしょう。
そのため、代わりに `char*` を引数に取って自動で `rb_intern()` してくれる関数も沢山あります。
これらの関数はより読みやすく、 `rb_intern()` の呼び出しでのオーバーヘッドは無視できる程度なので、
この導入記事では可能な限り `char*` バージョンのAPI関数が使われる傾向にあります。
特定のCの文字列をAPIの呼出しで頻繁に使う場合は、
`ID` に変換して保管しておき、
`ID` バージョンの関数を使うことでいくらかのパフォーマンス向上を確かめられるかもしれません。
（Rubyのヘッダから自分で見つける必要がありますが。）

## send ##

この節には直接Rubyのメソッドを呼び出すAPI関数が含まれます。
`rb_eval_string()`などよりも可能なときはいつでもこれらの関数を贔屓すべきです。
これらの関数は構文解析の過程が飛ばされますしいくつかのコンパイル時検査が免除されるのでより速いのです。

一番簡単な方法はオブジェクトにメソッドをこのように送ることです。

{% highlight c %}
{% include c/funcall.h %}
{% endhighlight %}

これは大雑把には次のRubyコードと同じです。

{% highlight ruby %}
{% include c/funcall.rb %}
{% endhighlight %}

最初の引数はレシーバです。
その次はメソッド名用の[`ID`](#symbol)です。
3つ目の引数はメソッド引数の数です。
これの引数は`rb_funcall()`がvarargs関数であることから必要になります。
それから実際メソッド引数に行き着きます。

その代わりに、4つ目の引数が引数のCの配列を指す`VALUE*`であるような、`rb_funcallv()`を使うことができます。
これにもRubyでの`public_send`のような派生`rb_funcallv_public()`があります。

### Passing Blocks ###

If you want to pass a `Proc` as the block to a method, that's easy. The
function is just like `rb_funcallv()` but with the proc on the end.

{% highlight c %}
{% include c/proc.h %}
{% endhighlight %}

If you don't have a proc for the block, you'll need to define a certain kind
of C function to represent the block. Then there's a different variant of
`rb_funcallv()` but with a couple extra arguments for the block:

{% highlight c %}
{% include c/block.h %}
{% endhighlight %}

The last argument to `rb_block_call()` is helpful for passing in values
outside the block function's scope, but in this example we don't need it
(thus `nil`). I also recommend against using the first argument to your
block function unless you're **sure** that only one value was yielded. You
can always get all the arguments from `argv`, so why not play it
safe?[^break]

## Builtins ##

Many of Ruby's built-in classes have API functions defined for their most
useful methods. Using them can save you from the verbosity of always using
`rb_funcall()` and can provide more compile-time checks. There are far too
many functions to list here, so I recommend checking them out in the header
`ruby/intern.h`.

Functions are generally named like `rb_(class)_(method)` and take at least
one `VALUE` argument (the receiver). E.g. `rb_ary_pop()` for `Array#pop`,
`rb_obj_dup()` for `Object#dup`, etc.

## Require ##

The API can also load some Ruby code from a script. There's an equivalent to
`require`:

{% highlight c %}
{% include c/require.h %}
{% endhighlight %}

As with `require`, these could raise exceptions. Read the [next
section](#exceptions) for how to handle them.

There are also functions for `load` if you want to load a script multiple
times:

{% highlight c %}
{% include c/load.h %}
{% endhighlight %}

Just like [`load` in Ruby][rbload], these functions can wrap the loaded code
in an anonymous module to protect the global namespace. Just pass a nonzero
value for the second argument.

[rbload]: http://www.ruby-doc.org/core/Kernel.html#method-i-load

## Exceptions ##

### Raise ###

To raise an exception, use:

{% highlight c %}
{% include c/raise.h %}
{% endhighlight %}

The first and second arguments are the exception class and
message&mdash;like `raise` in Ruby. The big difference is that the message
is a format string [just like in `rb_sprintf()`](#string), letting you more
easily build a useful message.

You can also construct exception objects directly using `rb_exc_new_cstr`,
`rb_exc_new`, and `rb_exc_new_str`. All of these accept an exception class
as their first argument and then they work just like their [string](#string)
counterparts, constructing an exception using a null-terminated string,
non-null-terminated string, and a `String` object, resp. Then you can raise
your exception object with `rb_exc_raise`.

### Rescue ###

There are several ways to rescue exceptions using the API. All of them
require the code you're protecting to be in a function that takes and
returns a single `VALUE`.

{% highlight c %}
{% include c/danger.h %}
{% endhighlight %}

Unless you wanted to rescue a function of exactly this type, you will
probably need to make a wrapper function in this format that runs the
desired code. The way to access a rescued exception is also independent of
the way it is rescued:

{% highlight c %}
{% include c/handle.h %}
{% endhighlight %}

`rb_errinfo()` essentially gives you the `VALUE` of Ruby's `$!` (which will
be `Qnil` if no exception occurred). Unlike in Ruby, you must manually clear
the exception after reading it[^clear]. Otherwise later API calls might read
the old value and think another exception has occurred.

Next we will go over several methods of rescuing; you can use whichever you
like, but I think that generally the right choice is determined by your
[use-case](#the-two-paths) of the API.

#### rb_rescue2 ####

If you're compiling a library to be loaded by Ruby, you have it easy. Any
exceptions raised in the API can be rescued as usual in your Ruby code. If
you want to rescue an exception in the API, you can use `rb_rescue2()` which
is similar to Ruby's `rescue`.

{% highlight c %}
{% include c/rescue2.h %}
{% endhighlight %}

The first two arguments are the function to protect and its argument, the
next two are the function to call if an exception is raised and its
argument.  `rb_rescue2()` is a varargs function, so after that comes a list
of the exception classes you want to rescue. The last argument should always
be `0` to indicate the end of the class list. Like `rescue` in Ruby, any
exceptions not in this list will not be rescued. If you just want to rescue
`StandardError` (like a blank `rescue` in Ruby), you can use `rb_rescue()`
which takes just the first four arguments of `rb_rescue2()`.

The API does not provide an easy way to run different rescue code for
different exception classes as Ruby does. You'll need to rescue all the
classes you want at once and use some kind of switch to handle them
separately.

The API also does not directly provide an equivalent to Ruby's `else`
i.e. code to run when _no_ exception was raised. One way to do this is using
the return value of `rb_rescue2()`. If no exception is raised, it returns
the return value of the first (dangerous) function, otherwise the return
value of the second (rescue) function. By having these return, say, `Qtrue`
and `Qfalse` you can detect which case you are in.

#### rb_protect ####

If you're embedding the Ruby interpreter in C, you need to be _extremely
careful_ when calling API functions that could raise exceptions: **an
uncaught exception will segfault the VM and kill your program**. You could
call `rb_rescue2()` with `rb_eException`, but there's another approach for
rescuing all exceptions:

{% highlight c %}
{% include c/protect.h %}
{% endhighlight %}

Like `rb_rescue2()`, the first two arguments are for calling the function to
protect. However, like `rb_eval_string_protect()`, if an exception is raised
it returns `Qnil` and sets `state` to some nonzero value. If you want to
re-raise the exception, pass `state` to `rb_jump_tag()` (this also works for
the state from the other `*_protect()` functions).

### Ensure ###

`rb_ensure()` is similar to `rb_rescue()` except that it doesn't do anything
about exceptions and the second function is _always_ called after the
first.  That may sound simple enough, but that means that if you want the
usual `begin; rescue; ensure; end` structure as in Ruby, you'll need another
layer of wrapping:

{% highlight c %}
{% include c/ensure.h %}
{% endhighlight %}

Like `ensure` in Ruby, the return value of `ensure_func()` is never used. If
no exception occurs, `rb_rescue()` will return the value of `begin_func()`
which returns the value of `dangerous_func()`. If an exception does occur,
`rb_rescue()` returns the value of `rescue_func()`.

## Definitions, Declarations ##

So far we've been creating and modifying objects directly in the VM's
memory, but none of our API calls have had a visible effect _within the Ruby
code_: a `String` made with `rb_str_new_cstr()` can only be accessed from C
by default.

There are a few ways to make things visible to Ruby but they all work the
same general way: by defining some name that Ruby can access e.g. a variable
name, a method name, etc. A general warning though: unlike Ruby, **the API
lets you give things invalid names**. Ruby will raise a `SyntaxError` or
`NameError` if you try to name a class `foo` (not constant) or an instance
variable `bar` (no `@`), but the API will happily create them. The API
handles this by **not exposing invalid names to Ruby**. Since that's
probably not what you want, double check the names you choose!

Most of the API functions in this section correspond closely to
metaprogramming methods in Ruby. When you're trying to do something using
the API, it can be helpful to think about how you would do it in Ruby using
only metaprogramming method calls. For example, rather than `class Foo; def
bar; end; end`, think `Foo = Class.new; Foo.define_method(:bar) {}`.

### Global Variables ###

The simplest way to deal with globals is:

{% highlight c %}
{% include c/global.h %}
{% endhighlight %}

If you're frequently accessing Ruby's globals, you can set up a `VALUE`
which will be automatically synchronized with one.

{% highlight c %}
{% include c/global2.h %}
{% endhighlight %}

The `VALUE` should be initialized before you create the global in Ruby and
it should be global in C as well&mdash;you don't want it to go out of scope
while Ruby is using it! For `rb_define_hooked_variable()`, you can pass
`NULL` for the getter/setter if you want to synchronize normally for that
operation. Or you can throw out `global` entirely with
`rb_define_virtual_variable()` though of course the getter and setter _must_
be defined in that case.

If you ever create a global `VALUE` in C which is _not_ exposed to Ruby, you
must tell the garbage collector about it to prevent it from being
prematurely cleaned up:

{% highlight c %}
{% include c/gc.h %}
{% endhighlight %}

### Class and Instance Variables ###

Getting/setting instance variables is similar to the simple way of accessing
globals, but of course you need an object to get the variable from.

{% highlight c %}
{% include c/ivar.h %}
{% endhighlight %}

There isn't an automatic way to synchronize instance variables like you can
with globals.

To iterate over all instance variables, use `rb_ivar_foreach`.

For class variables, the methods are `rb_cv_get()` and `rb_cv_set()` and of
course the first argument should be a class object.

### Constants ####

Constants are defined similarly, but with the module to define them under:

{% highlight c %}
{% include c/constant.h %}
{% endhighlight %}

You undefine a constant by setting it to `Qundef`. Getting a constant's
`VALUE` is a little nuanced. The API function you call depends on what you
want to happen if the constant is _not_ defined in the module you specify:

{% highlight c %}
{% include c/const_get.h %}
{% endhighlight %}

All of these API calls will get private constants too.

### Modules and Classes ###

Defining modules is super easy.

{% highlight c %}
{% include c/module.h %}
{% endhighlight %}

Classes work the same way but they also need a superclass.

{% highlight c %}
{% include c/class.h %}
{% endhighlight %}

### Methods ###

Here's where it gets interesting. There are many kinds of API calls for
defining methods, but before you use any of them you'll need a C function
that the method calls. The function must return a `VALUE` and have one
`VALUE` argument for the receiver of the method. There are three ways you
can define its other arguments:

{% highlight c %}
{% include c/methodc.h %}
{% endhighlight %}

So really the API only lets you define two types of methods: ones that take
a fixed number of arguments, and ones that slurp up all of their
arguments. What about all of Ruby's fancy argument features? Where are
optional arguments, options hashes, blocks, and all the mixtures of those?

#### Parsing Arguments ####

Well, if you accept a variable number of arguments you could code all of
that logic yourself in the method, and make it _behave_ like it has a
fancier method definition in Ruby. Thankfully, the API has a shortcut for
doing exactly that.  To use it, you should use the C array function
definition, then you can pass `argc` and `argv` along to:

{% highlight c %}
{% include c/scan.h %}
{% endhighlight %}

Here `fmt` is a format string describing how the method arguments would look
in Ruby. The string can have at most 6 characters, where each character
describes a different section of the arguments. The six sections and their
corresponding characters are (in order):

1. The number of leading mandatory arguments: a digit
2. The number of optional arguments: a digit
3. A splatted argument: `*`
4. The number of trailing mandatory arguments: a digit
5. Keyword arguments: `:`
6. A block argument: `&`

Each section is optional, so you can leave out the characters for things you
don't need. Be aware that the parsing of the format string is greedy: `1*`
describes a method with one mandatory argument and a splat. If you want one
_optional_ argument and a splat you must specify `01*`. Following the format
string, you must pass a `VALUE*` for each _Ruby_ argument. The number of
pointers passed should equal the "total" of the six sections, though you can
pass `NULL` for an argument you don't care about. For example the format
string `21*&` should have 5 `VALUE*`s passed (2 mandatory, 1 optional, 1
splatted, 1 block).

`rb_scan_args()` unpacks `argv` using the `VALUE*`s you pass it and will
raise a fitting exception if the wrong number of arguments were passed.

{% highlight c %}
{% include c/methodex.h %}
{% endhighlight %}

You can also use the return value of `rb_scan_args()` to determine how the
function was called. It returns the number of arguments that were passed in
Ruby.

#### Handling Blocks ####

There are two ways to check if your C method has been called with a block:

{% highlight c %}
{% include c/checkblock.h %}
{% endhighlight %}

There are two ways to capture the block as a proc. If you're using
`rb_scan_args()` for your method arguments, just include `&` in your format
string to get it. If you aren't using `rb_scan_args()`, there's an API call
equivalent to `Proc.new` which converts the method's block to a proc:

    VALUE block;
    block = rb_block_proc();

If you don't want to capture the block, there are a few ways to yield to it:

{% highlight c %}
{% include c/yield.h %}
{% endhighlight %}

There's also `rb_yield_values2()` which is like `rb_yield_values()` but
instead of varargs the second argument is a `VALUE*`[^yield].

#### Super ####

You might want to call `super` in your method.

{% highlight c %}
{% include c/super.h %}
{% endhighlight %}

Unlike in Ruby `rb_call_super()` will **not** implicitly pass along the
method arguments to the super if you give it no arguments. You must
explicitly pass the correct `argc` and `argv` (it _does_ automatically pass
`self`). For that reason I recommend using the C array style of method
definition if you want to use `rb_call_super()`.

#### Definition ####

Setting up the C function is the hard part, now it's easy to define the
method in Ruby. Every API call to create a method takes at least the method
name (`char*`), a pointer to your C function, and an `argc` describing its
arguments.  `argc` should be:

1. For a fixed number of arguments, the number of arguments (not counting
   the receiver)
2. For a variable number of arguments in a C array, `-1`
3. For a variable number of arguments in a Ruby Array, `-2`

Everything is pretty self-explanatory from there:

{% highlight c %}
{% include c/methodr.h %}
{% endhighlight %}

There's also a shortcut for defining a method in a module _and_ its
singleton class. This is used a lot in `Math`, for example, letting you
`include Math` to avoid typing `Math.` before every method call.

{% highlight c %}
{% include c/modulefunc.h %}
{% endhighlight %}

### Other Stuff ###

Some simple API functions for class/method definitions:

{% highlight c %}
{% include c/etc.h %}
{% endhighlight %}

## Data ##

By now you should be able to create and manipulate Ruby classes using the
API, but how can you create a Ruby class that encapsulates data from the C
world? If your data can be naturally translated into `VALUE`s it's easy:
convert and assign to instance variables as usual. But what if your data
have no Ruby analog (e.g. data structures defined by some C library)?

The API lets you encapsulate C data by creating a `VALUE` of the desired
class and then storing a `void*` pointing to the C data inside the Ruby
object. Then whenever you need access to the C data, you can unpack the
pointer and cast it back to the correct type. But where does this
encapsulation occur? Let's answer that question with a question: what
happens when you tell Ruby to create an object using `new`? Basically this:

{% highlight ruby %}
{% include c/new.rb %}
{% endhighlight %}

Before calling the _instance method_ `initialize` that we know so well,
`new` first calls the _class method_ `allocate` to actually create the
object. That is the method you'll need to define if you want your objects to
wrap C data. The following example creates a class `Foo` which wraps an
`int` that can be set by `initialize`:

{% highlight c %}
{% include c/wrap.h %}
{% endhighlight %}

In most cases you'll probably be wrapping something more complicated (like a
`struct`), but the principles will be the same. After allocating the C data,
we use the `TypedData_Wrap_Struct()`[^oldwrap] macro to wrap the pointer in
a `VALUE`. This wrapping takes three arguments: the class of the object
(`self` because we're in a class method), a pointer to a struct, and the
data pointer to be wrapped. The tricky part is the struct pointer; it
provides additional information for internal use by Ruby:

* `wrap_struct_name` is a string used by Ruby to identify your type. It
  doesn't really matter what it is as long as it's sensible and unique
* `function` is a struct containing several function pointers for use by the
  garbage collector
* `dmark` will be described later, but as long your C data doesn't point to
  any Ruby objects you don't need it
* `dfree` will be called when your object is destroyed and should free all
  memory allocated by the object
* `dsize` is called by Ruby to check how much memory your object is taking
  up.  It _can_ be omitted, but it's polite to include it
* `data` can point to arbitrary data. Think of it as wrapping C data at a
  class level. Also not manadatory
* `flags` lets you enable additional optimizations when your objects are
  garbage collected. As long as your `dfree` function doesn't unlock the
  [GVL](#c-in-ruby-threads) (why would you do that???) you can safely set it
  to `RUBY_TYPED_FREE_IMMEDIATELY` for a slight performance improvement

If you don't set some of these members, you should zero them out so that
Ruby doesn't accidentally read garbage data. That's why I used C99's
[designated initializer][desinit] syntax in the example above: any members
you omit will be safely cleared by the compiler.

[desinit]: https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html

`VALUE`s that wrap C data will have type `T_DATA` with respect to the
[`TYPE()` macro](#value). This helps ensure a clear separation between
native Ruby objects and those wrapping C data.

Once you've done all of that work to wrap up the C data, getting it back out
is easy: `TypedData_Get_Struct()` takes the object to unwrap, the C type of
the underlying data, the same struct pointer as before, and the pointer to
assign the data to.

This separation of allocation and initialization doesn't jive with
[RAII][raii], so if you're using C++ you will probably want to use
[placement new][place] when wrapping data. If you're having trouble
splitting up allocation and initialization, you can just wrap your data in a
`struct` and do the _actual_ allocation in `initialize`.

[raii]: http://wikipedia.org/wiki/Resource_Acquisition_Is_Initialization
[place]: http://en.cppreference.com/w/cpp/language/new#Allocation

In simple cases (like the previous example) you can make your code a little
less verbose. If the function to free your data just calls `free()` as in
the example, you can pass `RUBY_DEFAULT_FREE` for `dfree` and Ruby will free
it for you (**don't** use `NULL` unless you like memory leaks). Similarly,
if your allocation is just a `malloc()` as in the example, the macro
`TypedData_Make_Struct()` does the allocation for you _and_ wraps it. We
could shorten the previous example as such:

{% highlight c %}
{% include c/makestruct.h %}
{% endhighlight %}

### Marking ###

That `dmark` pointer in the type structure above is the pointer to your
object's "mark function". This is so named because of the garbage
collector's "mark and sweep" algorithm. The basic idea behind mark and sweep
is that when the garbage collector needs to free up memory, it performs two
passes: the first (mark) pass iterates through every _referenced_ Ruby
object and marks it as active, then the second (sweep) pass iterates through
every _allocated_ Ruby object and frees the ones that haven't been marked
active.

This is relevant to wrapping C data because it's possible that you might
wrap a C `struct` which contains a Ruby `VALUE`&mdash;which the garbage
collector is responsible for cleaning up. Since the garbage collector is
only aware of `VALUE`s referenced _by Ruby_ (not by C pointers), it won't be
able to mark the referenced `VALUE` as active. The result is that as soon as
the garbage collector needs to free up some memory, your C data is going to
end up with a reference to a nonexistent Ruby object. Note that this kind of
wrapping of Ruby data inside C data is a really bad idea, precisely because
of this kind of issue. But if you really must...

In the following example, we'll wrap a C `struct` which contains a
`VALUE`. The mark function has the same signature as the free function and
all it has to do is mark any `VALUE`s in the `struct`:

{% highlight c %}
{% include c/mark.h %}
{% endhighlight %}

If your `struct` contains a pointer to a C array of `VALUE`s, you can
instead use `rb_gc_mark_locations()` which takes two arguments: the pointers
to the start and end of the array (the end being equal to the starting
pointer plus the array length).[^maybe]

## Threading ##

### Ruby in C Threads ###

If you're making a lot of API calls and running a lot of Ruby code from C,
at some point you might catch yourself thinking, "I'm running all of these
slow Ruby methods using the API. Maybe I can thread things to keep my code
fast!" That's a reasonable thought, but when you act on it keep in mind that
**the Ruby VM is not at all thread safe**. Ideally, all of your API code
should run in a single thread. If not, you'll probably need to wrap every
API call with a locked mutex to make sure that you never ever have multiple
threads interacting with the API at the same time.

If you just want to create normal Ruby `Thread`s using the API (and don't
mind the GVL, as described in the next section), there's an easy way to do
that:

{% highlight c %}
{% include c/thread.h %}
{% endhighlight %}

Other `Thread` functions are in `ruby/intern.h` (but there's always
`rb_funcall()` for everything else).

### C in Ruby Threads ###

On the other hand, if you expose some heavy C code to Ruby with the API (if
you're writing an extension that wraps a C library, for example), you should
spend some time thinking about a nasty thing called the global VM lock
(GVL).  Because most of the API is not `Thread` safe, the GVL locks down
almost all Ruby code so that only a single `Thread` can run at a time. This
is the reason why you'll often hear people say that `Thread` does not allow
true parallelism.

The VM also applies the GVL to any C code you expose to Ruby. That's why you
can use the API without worrying about it exploding when someone calls your
C code from inside a `Thread`. The downside of this is that if your C code
takes a while to run, you won't see any performance benefit from calling it
in a `Thread` because **it will block all other threads** while it runs. But
the GVL is only needed to protect API calls. If you have some C code that
doesn't use the API, you can tell the VM to release the GVL before running
your code in a thread and to reacquire it when it completes, allowing for
true parallelism.  Locking and unlocking the GVL does carry a performance
hit, so only resort to this if you notice that you're having significant
problems due to blocked threads.

The code to do this is considered so fancy by the Ruby developers that you
actually need to include another header to use it. First we'll look at the
slightly simpler way to release the GVL:

{% highlight c %}
{% include c/gvl2.h %}
{% endhighlight %}

Since the function that is run without the GVL gets and returns data using
`void*`, you may want to define a `struct` for passing data via pointers.

If you unlock the GVL as above you will find that while your code does run
in parallel, it can't be interrupted (by signals, `Thread.kill`, etc.)! To
allow for that you must pass an unblocking function using the last two
arguments:

{% highlight c %}
{% include c/gvl.h %}
{% endhighlight %}

The unblocking function is called in the event of an interrupt. To make it
work, you will probably need to pass a pointer to both functions that can be
used to communicate an interrupt from one to the other. The interrupted
function should perform any necessary cleanup before returning early.

Alternatively, if the interrupted function doesn't _need_ to perform any
special cleanup, you can use the built in unblocking function
`RUBY_UBF_IO`[^ubf] (which ignores the unblocking argument). That simply
forwards the interrupt to the running thread.[^int]

If you go through all of that effort to release the GVL only to find that
you need to make an API call in your unlocked thread, there's a function to
temporarily reacquire the GVL:

{% highlight c %}
{% include c/with_gvl.h %}
{% endhighlight %}

## See Also ##

### extension.rdoc ###

Ruby does have [official API documentation][readme]. It's a bit spotty and
has some poor recommendations (in my opinion), but it is also a little more
exhaustive on certain topics. In many cases this is because I intentionally
skipped something that I either found not useful or better documented
elsewhere.

[readme]: https://github.com/ruby/ruby/blob/master/doc/extension.rdoc

### Headers ###

I think some of the handiest resources are the Ruby headers themselves. The
full API (i.e. everything you get by including `ruby.h`) easily consists of
a thousand functions, macros, constants, and globals&mdash;most of which
have never been documented. However _most_ things are reasonably named and
you should be able to figure out what they do from the header. Most
everything you need should be in the headers `ruby/ruby.h` and
`ruby/intern.h`. The former has all of the VM and metaprogramming functions,
the latter has all of the functions for interacting with Ruby's built in
classes.

There are also some headers _not_ pulled in by `ruby.h` which you can
include to get additional API functionality. Maybe one day I'll write
another section to this guide going over them:

* `ruby/debug.h` (experimental) functions for profiling and tracing code
* `ruby/encoding.h` functions for working with string encodings
* `ruby/io.h` additional functions for Ruby's IO class
* `ruby/re.h` additional functions for Ruby's Regexp class
* `ruby/thread.h` functions for working with the [GVL](#c-in-ruby-threads)
* `ruby/version.h` functions for version introspection. Do not use this as
  feature-detection code!
* `ruby/vm.h` (experimental) functions for VM control

### Source ###

If you find some function in the header that isn't documented anywhere, your
next stop should be the Ruby source code.

{% highlight shell_session %}
$ git clone https://github.com/ruby/ruby.git
{% endhighlight %}

When reading through the source code, always keep the headers at hand: there
are lots of really useful functions in there that _look_ like they should be
in the API, but actually aren't. In most cases there should be an API
function elsewhere that wraps the call to the useful function.

### Examples ###

Head over to the [Examples](../examples) page for short, compilable examples
of the API in action.

### Contribute ###

Now that you've finished reading my guide, did you notice something
significant that I left out? Did I make some stupid mistake? Check out the
[source][gh] for this site on Github and you can report issues, submit pull
requests, and download all of the code examples.

[gh]: https://github.com/silverhammermba/emberb

## 脚註 ##

[^intern]: That's a blatant lie. The API _definitely_ lets you mess around
           with the internal data structures of objects (look for things with
           names starting with capital R). But it's generally not a good idea
           and not necessary.

[^undef]: There's also `Qundef` representing an undefined value, but
          this has no Ruby equivalent and is [rarely](#handling-blocks)
          [used](#constants-1). In fact, outside of those rare occassions,
          `Qundef` can segfault the VM if Ruby was expecting a normal `VALUE`.

[^wrap]: There's also `rb_eval_string_wrap()` which _should_ be useful, but is
         actually the same as `rb_eval_string_protect()` due to a [bug][bug2].

[^chr]: There is a `CHR2FIX()` macro, but in my tests this sometimes gave
        unexpected results. `LONG2FIX()` should work.

[^wchar]: I don't know what the best way is to handle `wchar_t`. In my tests I had
          some success just treating them as `char`s, but I think that may have
          been a happy accident, and could certainly fail on different platforms.

[^clear]: The documentation [states][control] that "You have to clear the error
          info [when] ignoring the caught exception" during `rb_protect`. But I
          can't find any documentation of when it would be cleared for
          you&mdash;it seems like you _always_ have to clear it.

[^yield]: And there's `rb_yield_block()` which takes two unused arguments and is
          never called by anything in Ruby. Odd.

[^break]: The documentation [mentions][control] `rb_iter_break()` and
          `rb_iter_break_value()` for breaking out of a block, but can't you
          just return early? I can't think of a use-case for these.

[^int]: There is also the function `rb_thread_call_without_gvl2()`. The
        documentation in `thread.c` says that if it "detects interrupt, it
        returns immediately," but I'm not sure what this means. If the
        unblocking function doesn't kill the thread, it still waits for the
        thread to finish on its own before returning.

[^ubf]: You can also use `RUBY_UBF_PROCESS`, but this seems to be a leftover
        from deprecated code and has the exact same effect.

[^oldwrap]: The `TypedData*` macros are the preferred way to wrap data since
            Ruby 1.9.2. If you're using an older version of Ruby you can check
            out an older version of this guide on Github to see how it used to
            be done.

[^maybe]: There's also the enigmatically named `rb_gc_mark_maybe()`, but I'm not
          sure when it is needed.

[^tdata]: Or use `T_DATA` if the object [wraps a C pointer](#data).

[control]:
https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-Control+Structure
[bug2]: https://bugs.ruby-lang.org/issues/10466
