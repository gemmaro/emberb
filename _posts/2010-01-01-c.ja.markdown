---
layout: chapter
title: 'RubyのC API'
---

## 始める前に ##

このガイドを完全に理解するためには、C言語はそこそこ、Rubyは _かなり_ 慣れ親しんでいるとよいでしょう。

RubyのC APIを使うのに発展的なC言語の概念は要りませんが、
APIは**膨大**で大半が**文書化されていません**。
APIを使い始めだすと、いつの日にか、
はっきりしない関数やマクロの振舞いを見つけるためにRubyのソースコードを探ることになるでしょう。
Rubyのソースはそこそこ洗練されたC言語で書かれているので、
すいすい読めはするでしょうけれども。

C APIは、普通のRubyのコードよりもデカくてゴチャっとした書き方だと見なせます。
とはいえ、簡素で明快なRubyの様式は、ひとたびAPIの言葉に翻訳されるとかなり非直感的になることがあります。
Rubyの内部論理と設計の背後にある思想に裏打ちされたしっかりとした直感があれば、
長い旅路のさなかでも正しいAPI関数へと進み続けられるでしょう。

## 分岐点 ##

公式のRubyインタプリタはC言語で書かれています。
Rubyでできるあらゆることは、RubyのC APIを呼び出す関数を使ってもできます。
いったいなぜそんなことをするのでしょうか？
もっともな理由が2つあります。

1. 意匠を凝らしたC言語ないしC++のアプリケーションを書いている最中で、
   Rubyの動的な柔軟性をコードのいくつかの箇所に使って、
   効果を引き出そうとするとき。
   アプリケーションの内部でRubyインタプリタを実行でき、
   Rubyのコードの結果をAPIで受け取ることができます。
2. 意匠を凝らしたRubyのアプリケーションを書いている最中で、
   C言語（もしくは既にあるC言語のライブラリ）の速度と能力を
   コードのいくつかの箇所に使って、
   効果を引き出そうとするとき。
   APIを使えば、RubyにC言語のコードをさらけ出すことができます。
   そうしてできた特別なライブラリをコンパイルするとRubyから `require` できます。

目標によってC言語のコードの組み立てかたは変わってきます。
C言語にRubyインタプリタを組込みたければ、
[C言語でRubyを実行する](../embed.ja)をお読みください。
コンパイルされたC言語のライブラリを `require` したければ、
[RubyでC言語を実行する](../extend.ja)をお読みください。
どちらかを読み終えたら、ここに戻ってきてAPIについて学びましょう。

## Eval ##

ちゃちゃっと雑にCでRubyを動かすには、 `eval` します。

{% highlight c %}
{% include c/eval.h %}
{% endhighlight %}

これはやりたいことのためのAPI関数が見つからないときは選択肢に入ります[^wrap]。
`rb_eval_string_protect()` はRubyのコードの結果を返し、
何か例外が発生したときはゼロではない値を `state` に設定します。
`VALUE` はあらゆるRubyのオブジェクトのためのCのデータ型です。
次の節で後述します。

`state` がゼロではないとき、
`result` は `nil` を表す `VALUE` になっているでしょうから、
そのときは例外に対処しなければいけません。
代わりに `rb_eval_string()` を使うこともできます。
この関数は引数 `state` を取らず、通常の方法で例外を発生させます。
これら2つの場合での制御方法については[例外](#exceptions)節を参照してください。

Rubyでの `eval` とは異なり、
これらの関数は独立の束縛状態で評価します。
ちょうど何かを `require` するときと同じです。
したがって文字列中のローカル変数は他の場所から参照できませんし、逆もまた然りです。

しかし、Rubyで `eval` するときのように、
これらの関数を使うことはあまりよくありません。
パーサが起動されなければいけないのが非効率ですし、
Cで書くことの利点が失われています。
Rubyのメソッドを呼びたいだけであれば、
もっといい方法を[後述](#send)します。

## VALUE ##

先に進む前に、
`VALUE` について理解しなければいけません。
VMの内部をめちゃくちゃにしてしまう危険があるので、
APIからは直接Rubyのオブジェクトを扱えません[^intern]。
その代わり、CのコードはRubyのオブジェクトへの _ポインタ_
を保持したり受け渡したりします（Rubyの変数がオブジェクトへのポインタを持つのと同じです）。
ポインタはさまざまなAPIの関数やマクロに渡すことができ、
そのためRubyのオブジェクトに安全にアクセスしたり操作したりできます。
`VALUE` はAPIで定義されたCの型で、このポインタを扱います。

おそらく最も頻繁に湧いてくる疑問は次のようなものでしょう。
「この `VALUE` は正しい型なのだろうか？」
この疑問に答えるマクロは2つあり、
そのどちらも[`T_` 定数](datatypes)を引数に取ります。
この定数は比較したい型に対応するRubyのクラスです。
例えば `T_STRING` や `T_ARRAY` などです。

[datatypes]:
https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-Data+Types

{% highlight c %}
{% include c/checktype.h %}
{% endhighlight %}

この検査はサブクラスでも同様にはたらきます。
`Array` のサブクラスであることを確認したいときは `T_ARRAY` を使いますし、
`Object` のサブクラスであることを確認したいときには `T_OBJECT` を使います[^tdata]。
つまり、この検査は _`is_a?` と同じではない_ ということでもあります。
Rubyのありとあらゆるものについて `is_a? Object` であるにせよ、
`T_OBJECT` に対する検査は、
他にもっと適した定数がないときにのみ真となります。

特定のクラスには、前述したものより少し効率的なマクロが使えます。

{% highlight c %}
{% include c/check_p.h %}
{% endhighlight %}

いくつかの型を取りうる `VALUE` を扱いたいときは、
前述のマクロはちょっと不恰好です。
そんな場合は `TYPE()` マクロを使って `T_` 定数を取得し、
`switch` 文で制御できます。

{% highlight c %}
{% include c/type.h %}
{% endhighlight %}

### 定数 ###

ほとんどの標準的なRubyの定数はAPIで大域的な `VALUE` が定義されています。
したがってそれらの定数を使うのにAPIの呼び出しは要りません。
モジュールは `rb_m` で前置されます。
たとえば `rb_mKernel` です。
クラスは `rb_c` で前置されます。
たとえば `rb_cObject` です。
`Exception` のサブクラスは `rb_e` で前置されます。
たとえば `rb_eRubtimeError` です。
標準的なIOストリームは `rb_` で前置されます。
たとえば `rb_stderr` です。
`nil`, `false`, `true` は `Q` で前置されます。
例えば `Qnil` です。
[^undef] 便宜上、 `Qfalse` はCの偽値 (`0`) でもあります。

### 変換 ###

いくつかのRubyのクラスはCの型に対応します。
この対応する組み合わせは、CとRubyの間のデータのやりとりをするには一番です。

#### Fixnum ####

Rubyの `Fixnum` はCの `long` に対応します。
`FIX2LONG()` マクロにより、 `long` を `Fixnum` に変換できます。
より小さいCの型については、
`FIX2UINT()`, `FIX2INT()`, `FIX2SHORT()` があります。
しかし、これらのマクロは変換時に数値が大きすぎて収まらない場合は `RangeError` を生じます。

逆向きの変換もできて、
`LONG2FIX()` は `long` *に加えて* `long` より小さい全てのCの整数型からの変換に使えます。

#### Bignum ####

Rubyの `Bignum` は `Fixnum` より大きいあらゆる整数に使えます。
例えば `long long` が必要なときとかです。
`rb_big2()` と `rb_big2u()` を使えば、 `Bignum` から
それぞれ `long long` や `unsigned long long` に直せます。
（もしくは `RangeError` が発生します。）

逆向きの変換については [数値](#numeric) を参照してください。

#### Float ####

Rubyの `Float` はCの `double` に対応します。
`RFLOAT_VALUE()` マクロを使えば、 `Float` から `double` が得られます。

逆向きの変換については [数値](#numeric) を参照してください。

#### Numeric ####

たくさんの "NUM" マクロがあり、
ダックタイピングっぽい使いかたをしています。
これらのマクロはCの型を適切と思われるRubyの `Numeric` のサブクラス（のインスタンス）に変換します。

* `INT2NUM()` は `int` からの変換用
* `UINT2NUM()` は `unsigned int` からの変換用
* `LONG2NUM()` は `long` からの変換用
* `ULONG2NUM()` は `unsigned long` からの変換用
* `LL2NUM()` は `long long` からの変換用
* `ULL2NUM()` は `unsigned long long` からの変換用
* `DBL2NUM()` は `double` からの変換用

そして、逆方向のマクロもあります。
これらのマクロは、あらゆる `Numeric` な数値から欲しいCの型の値への変換を試みるものです。
値が範囲に収まらなかったときは `RangeError` を発生させますし、
暗黙の数値の変換ができなかったときは `TypeError` が発生します。
（なので `Numeric` ではないオブジェクトを渡しても大丈夫です。）

* `NUM2CHR()` は `char` からの変換用（`unsigned char` からでも変換できます）
* `NUM2SHORT()` は `short` からの変換用
* `NUM2USHORT()` は `unsigned short` からの変換用
* `NUM2INT()` は `int` からの変換用
* `NUM2UINT()` は `unsigned int` からの変換用
* `NUM2LONG()` は `long` からの変換用
* `NUM2ULONG()` は `unsigned long` からの変換用
* `NUM2LL()` は `long long` からの変換用
* `NUM2ULL()` は `unsigned long long` からの変換用
* `NUM2DBL()` は `double` からの変換用

これらのマクロについて **特に** 注意すべき点は、
符号なしの型に変換に変換する *どの* マクロも、負値を渡したときに例外が発生しないということです。
（驚くべきことに[バグではありません][bug]。）
`NUM2CHR()` にはもう2つ妙なところがあります。
変換前の値が _int_ には大きすぎるときに `RangeError` のみ生じることと、
文字列を渡したときに `TypeError` を発生させず最初の文字の数値を返すということです。

変換が安全だとわかっていれば、
前の節のマクロのほうを使うべきです。
なぜなら範囲の確認を省けるためです。

[bug]: https://bugs.ruby-lang.org/issues/9089

#### String ####

Rubyの `String` はだいたいCの `char*` に対応します。
もっとも簡素なマクロは `StringValueCStr()` です。
このマクロは `String` からnull終端付きの `char*` を返します。
ただしこれには問題があって、Rubyの `String` が *nullを含むかもしれません*。
そのような場合には `StringValueCStr()` は `ArgumentError` を発生させます！
その代わりに `StringValuePtr()` マクロと `RSTRING_LEN()` マクロを使えば、それぞれ
（終端が付いていない可能性がある） `char*` とその長さの `long` 値を取得できます。

逆に、null終端付きの `char*` からRubyの `String` への変換には、
`rb_str_new_cstr()` が使えます。
そして、もし `String` にnullを含めたいときは、
`rb_str_new()` を使います。
`rb_str_new()` は `char*` と文字列の長さ（型は `long`）を引数に取ります。
これらの文字列のエンコーディングは `ASCII-8BIT` なのですが、
Ruby側のコードで望んだものではないこともあります。
そんなときは文字列の `VALUE` を `rb_str_export_locale()` に渡して、
自分のロケールのエンコーディングでの `VALUE` を取得することができます。

もっと複雑な文字列を構築したければ、
`printf` のような関数 `rb_sprintf()` でできます。
この関数では通常の変換での全ての指定子だけではなく、
APIで定義された指定子 `PRIsVALUE` も使えます。
`PRIsVALUE` は対応する `VALUE` を引数に取ります。
この変換指定子はオブジェクトに `to_s` メッセージを送って文字列にに置き換えます。
`+` フラグを加えることで `inspect` を使った結果の文字列に置き換えることもできます。

{% highlight c %}
{% include c/printf.h %}
{% endhighlight %}

この自前の指定子はAPIにあるあらゆる `printf` っぽい関数で使えるでしょう。
`PRIsVALUE` は `i` 変換指定子を乗っ取ることで実現されているので、
`int` を文字列にするときは `d` を使って、
Rubyに「それって実は `VALUE` なんじゃないか」と勘違いさせないようにするべきです。

#### Symbol ####

APIではRubyの `Symbol` に対応するCの型 `ID` が定義されています。
Rubyが `Symbol` をメソッドや変数名として受け渡しするように、
多くのAPI呼び出しでメソッドや変数の名前を `ID` を使うようにしています。
`Symbol` と `ID` を変換するには、 `SYM2ID()` と `ID2SYM()` マクロを使います。
`Symbol` ではなくCの文字列 `char*` との双方向に変換したいときもあるでしょう。
`char*` から `ID` を取得するためには `rb_intern()` を、
その逆向きでは `rb_id2name()` を使います。

多くのAPI関数が `ID` を必要としていますが、
適切な `ID` が手元にないことも沢山あるでしょう。
そのため、代わりに `char*` を引数に取って自動で `rb_intern()` してくれる関数も沢山あります。
これらの関数はより読みやすく、 `rb_intern()` の呼び出しでのオーバーヘッドは無視できる程度なので、
この導入記事では可能な限り `char*` バージョンのAPI関数が使われる傾向にあります。
特定のCの文字列をAPIの呼出しで頻繁に使う場合は、
`ID` に変換して保管しておき、
`ID` バージョンの関数を使うことでいくらかのパフォーマンス向上を確かめられるかもしれません。
（Rubyのヘッダから自分で見つける必要がありますが。）

## send ##

この節には直接Rubyのメソッドを呼び出すAPI関数が含まれます。
`rb_eval_string()`などよりも可能なときはいつでもこれらの関数を贔屓すべきです。
これらの関数は構文解析の過程が飛ばされますしいくつかのコンパイル時検査が免除されるのでより速いのです。

一番簡単な方法はオブジェクトにメソッドをこのように送ることです。

{% highlight c %}
{% include c/funcall.h %}
{% endhighlight %}

これは大雑把には次のRubyコードと同じです。

{% highlight ruby %}
{% include c/funcall.rb %}
{% endhighlight %}

最初の引数はレシーバです。
その次はメソッド名用の[`ID`](#symbol)です。
3つ目の引数はメソッド引数の数です。
これの引数は`rb_funcall()`がvarargs関数であることから必要になります。
それから実際メソッド引数に行き着きます。

その代わりに、4つ目の引数が引数のCの配列を指す`VALUE*`であるような、`rb_funcallv()`を使うことができます。
これにもRubyでの`public_send`のような派生`rb_funcallv_public()`があります。

### ブロックを渡す ###

`Proc`をブロックとしてメソッドに渡したければ話は早いです。
関数はほぼ`rb_funcallv()`と同じですが後ろにprocが付きます。

{% highlight c %}
{% include c/proc.h %}
{% endhighlight %}

ブロック用のprocがなければ、ブロックを表現する何らかの類のC関数を定義する必要があります。
それから`rb_funcallv()`の異なる派生でブロック用に2つ引数が追加されたものがあります。

{% highlight c %}
{% include c/block.h %}
{% endhighlight %}

`rb_block_call()`への最後の引数はブロック関数のスコープの外側にある値を渡すのに便利ですが、この例ではその必要はありません（なので`nil`にしています）。
また、1つの値だけがyieldされることを**確信**していない限り、最初の引数を使うことはお勧めしません。
いつでも全ての引数を`argv`から手に入れられるので、危うきに近寄らずともいいじゃないですか[^break]。

## 組み込みの機能 ##

多くのRubyの組み込みクラスには、その中でも飛びっきり便利なメソッド用に定義されたAPI関数があります。
それらを使えば、`rb_funcall()`を使ってばかりで冗長になるのを避けられたり、より良いコンパイル時の検証がもたらされるかもしれません。
関数があまりにも多すぎて一覧にするにはここは狭すぎるので、ヘッダファイル`ruby/intern.h`を眺めることを推奨します。

関数はおおよそ`rb_（クラス）_（メソッド）`のように命名されていて少なくとも1つの`VALUE`引数（レシーバ）を取ります。
例えば`rb_ary_pop()`は`Array#pop`用ですし、`rb_obj_dup()`は`Object#dup`用、といった具合です。

## require ##

APIでは何らかのRubyコードをスクリプトから読み込むこともできます。
`require`と等価なものがあります。

{% highlight c %}
{% include c/require.h %}
{% endhighlight %}

`require`するときは例外が発生し得ます。
対処方法については[次節](#exceptions)を読んでください。

スクリプトを複数回読み込みたければ`load`用の関数もあります。

{% highlight c %}
{% include c/load.h %}
{% endhighlight %}

ちょうど[Rubyの`load`](rbload)と同じように、こうした関数は読み込まれたコードを匿名のモジュールに包んで大域名前空間を保護するのに使えます。
ただ非ゼロの値を2つ目の引数に渡せばよいです。

[rbload]: http://www.ruby-doc.org/core/Kernel.html#method-i-load

## 例外 ##

### raise ###

例外を投げるには以下を使ってください。

{% highlight c %}
{% include c/raise.h %}
{% endhighlight %}

1つ目と2つ目の引数は例外クラスと文言で、Rubyの`raise`に見えます。
大きな違いは文言が（ちょうど`rb_sprintf()`のような）書式文字列である点で、役立つ文言をより簡単に構築できます。

また`rb_exc_new_cstr`、`rb_exc_new`、`rb_exc_new_str`を直接使って例外オブジェクトを構築することもできます。
これら全ては例外クラスを1つ目の引数に受け付けて、そうしてちょうど対応する[文字列](#string)にしたがってはたらきます。
例外はそれぞれnull終端文字列、非null終端文字列、`String`オブジェクトを使って構築されます。
それから`rb_exc_raise`で例外オブジェクトを投げられます。

### rescue ###

APIを使って例外を補足するにはいくつか方法があります。
全て保護しているコードが単一の`VALUE`を取って返す関数の中にある必要があります。

{% highlight c %}
{% include c/danger.h %}
{% endhighlight %}

厳密にこの型の関数を救出したいのでない限り、恐らくこの形式で所望のコードを走らせる梱包関数を作る必要があるでしょう。
救出された例外にアクセスする方法もまた救出される方法とは独立です。

{% highlight c %}
{% include c/handle.h %}
{% endhighlight %}

`rb_errinfo()`は欠かせないRubyの`$!`（1つも例外が起こらなければ`Qnil`になります）の`VALUE`を与えます。
Rubyとは異なり読んだ後で例外を手動で消し去らなければなりません[^clear]。
さもなくばその後のAPI呼び出しが古い値を読んで別の例外が起こったと考えるかもしれません。

次に救出のいくつかの方法を眺めていきます。
どれでも好きなものを使ってよいですが、一般的には正しい選択はAPIの[用途](#the-two-paths)により決定されると考えています。

#### rb_rescue2 ####

Rubyによって読み込まれるライブラリをコンパイルしている場合、話は簡単です。
APIで投げられるいかなる例外もいつも通りRubyのコードで救出できます。
APIで例外を救出したければRubyの`rescue`と似ている`rb_rescue2()`を使うことができます。

{% highlight c %}
{% include c/rescue2.h %}
{% endhighlight %}

始めから2つの引数は保護する関数とその引数です。
その次の2つは例外が投げられた場合に呼ばれる関数とその引数です。
`rb_rescue2()`はvarargs関数なのでその後には救出したい例外クラスのリストが来ます。
最後の引数は常に`0`でクラスのリストの末尾を示します。
Rubyの`rescue`のようにこのリストにないどんな例外も救出されることはありません。
もし（Rubyでの空の`rescue`のように）`StandardError`を救出したいだけなら、`rb_rescue2()`の最初の4つの引数だけを取る`rb_rescue()`を使うことができます。

APIはRubyとは違ってそれぞれの例外クラス用に救出コードを走らせる簡単な方法を提供していません。
一度に欲しい全てのクラスを救出してswitchの類を使って個別に取り扱う必要があります。

またAPIはRubyの`else`と等価なもの、つまり _何らの_ 例外も投げられなかったときに走るコード、を直接は提供していません。
これをする1つの方法は`rb_rescue2()`の返り値を使うことです。
もし1つも例外が投げられなければ最初の（危険な）関数の返り値を、さもなくば2つ目の（救出）関数の返り値を返します。
これらが返すもの、ここでは`Qtrue`と`Qfalse`としましょう、を受け取ることによって、どちらの場合にあるのかを検出できます。

#### rb_protect ####

RubyインタプリタをCに埋め込みたい場合、例外を投げ得るAPI関数を呼ぶときは _極めて慎重_ にならねばなりません。
**捕捉されない例外はVMをセグフォルトさせてプログラムをキルする**のです。
`rb_eException`と共に`rb_rescue2()`を呼ぶようにできますが、全ての例外を救出する別の手法があります。

{% highlight c %}
{% include c/protect.h %}
{% endhighlight %}

`rb_rescue2()`と同様、最初2つの引数は保護する関数を呼び出すためのものです。
しかし、`rb_eval_string_protect()`のように、例外が投げられれば`Qnil`を返し`state`を非ゼロの値に設定します。
例外を再度投げたければ`state`を`rb_jump_tag()`に渡してください（これは他の`*_protect()`関数からの状態についても動作します）。

### ensure ###

`rb_ensure()`は`rb_rescue()`に似ていますが例外を関知しないことと2つ目の関数が _常に_
1つ目のものの後に呼ばれる点が例外です。
充分に単純に思われるかもしれませんが、これが意味しているのは、もしRubyでするような通常の`begin; rescue;
end`の構造が欲しければ、梱包に別の層が必要になってくるということです。

{% highlight c %}
{% include c/ensure.h %}
{% endhighlight %}

Rubyでの`ensure`のように、`ensure_func()`の返り値は決して使われません。
何も例外が起きなければ`rb_rescue()`は`begin_func()`の値を返します。
ここで`begin_func()`は`dangerous_func()`の値を返します。
もし例外が発生したら`rb_rescue()`は`rescue_func()`の値を返します。

## 定義、宣言 ##

ここまでVMのメモリ内で直接オブジェクトを作ったり変更したりしてきましたが、どのAPI呼び出しも _Rubyのコードの内部_
での目に見える効果はありませんでした。
`rb_str_new_cstr()`で作られた`String`は、既定ではCからのみアクセスできます。

Rubyから見えるようにするにはいくつかの方法がありますが、全て同じ汎用的な仕組みではたらきます。
その共通するところはRubyがアクセスできる何らかの名前を定義するという点です。
例えば変数名やメソッド名などなどです。
しかし注意を呼び掛けておきましょう。
Rubyとは違い、**APIでは不正な名前を与えることができます**。
クラスに`foo`（定数でない）やインスタンス変数に`bar`（`@`がない）を名付けようとするとRubyは`SyntaxError`や`NameError`を投げるでしょうが、APIは嬉々としてそうした名前で作ります。
APIはこれを **不正な名前をRubyにさらけ出さない** ようにして扱います。
恐らくそれはしたいことではないので、選ぶ名前は二重確認してくださいね。

この節のほとんどのAPI関数はRubyのメタプログラミングに近いです。
APIを使って何かしようとするときは、Rubyでメタプログラミングのメソッド呼び出しだけを使ってするとしたらどうするだろうと考えると役立つことがあります。
例えば`class Foo; def bar; end`とするより、`Foo = Class.new; Foo.define_method(:bar)
{}`と考えるのです。

### 大域変数 ###

大域変数を扱う一番簡単な方法は以下です。

{% highlight c %}
{% include c/global.h %}
{% endhighlight %}

Rubyの大域変数に頻繁にアクセスするときは`VALUE`を準備しておけば自動的に同期が取られます。

{% highlight c %}
{% include c/global2.h %}
{% endhighlight %}

`VALUE`はRubyで大域変数を作る前に初期化するべきで、そうしておけばCでも大域変数になります。
Rubyが使っている間はスコープを外れてほしくはないですからね。
`rb_define_hooked_variable()`にすると、そうした操作で通常の同期をしたい場合にゲッターやセッターに`NULL`を渡すことができます。
もしくは`rb_define_virtual_variable()`では完全に`global`を投げ出すこともできますが、もちろんゲッターとセッターはそうした場合で定義されている
_必要_ があります。

Rubyに露出 _しない_
大域変数`VALUE`をCで作ったならば、中途半端に掃除されてしまうのを防ぐためにガベージコレクタにそのことを伝えなければなりません。

{% highlight c %}
{% include c/gc.h %}
{% endhighlight %}

### クラスとインスタンス変数 ###

インスタンス変数の取得と設定は大域変数にアクセスする単純な方法と似ていますが、もちろん変数を取得してくるオブジェクトが必要です。

{% highlight c %}
{% include c/ivar.h %}
{% endhighlight %}

大域変数でしたようにインスタンス変数を同期する自動化された方法はありません。

全てのインスタンス変数を巡回するには`rb_ivar_foreach`を使ってください。

クラス変数については、メソッドは`rb_cv_get()`と`rb_cv_set()`がありもちろん最初の引数はクラスオブジェクトです。

### 定数

定数は似たように定義されていますが、それらを配下に置くためのモジュールを伴います。

{% highlight c %}
{% include c/constant.h %}
{% endhighlight %}

`Qundef`を設定すると定数は未定義にされます。
定数の`VALUE`の取得は微妙に違ってきます。
呼び出すべきAPI関数は、定数が指定されたモジュールで定義されて _いない_ ときに何が起こってほしいのかに依ります。

{% highlight c %}
{% include c/const_get.h %}
{% endhighlight %}

これら全てのAPIはプライベート定数も取得します。

### モジュールとクラス ###

モジュールの定義は超簡単です。

{% highlight c %}
{% include c/module.h %}
{% endhighlight %}

クラスは同じやり方ですがスーパークラスも必要です。

{% highlight c %}
{% include c/class.h %}
{% endhighlight %}

### メソッド ###

ここから面白くなってきます。メソッド定義のためのAPI呼び出しには多くの種類がありますが、どれかを使う前にそのメソッドを呼び出すC関数が必要です。その関数は`VALUE`を返しメソッドのレシーバ用の`VALUE`引数を1つ持たねばなりません。他の引数を定義するのには3つの方法があります。

{% highlight c %}
{% include c/methodc.h %}
{% endhighlight %}

なので本当のところAPIでは2つの種類のメソッドのみが定義できるのです。且つは固定数の引数を取り、且つは全ての引数を一飲みします。Rubyの素敵な引数の機能はどうなったのでしょうか。オプション引数、オプションハッシュ、ブロック、これらの混在はどこにあるのでしょうか。

#### 引数を解析する ####

さて、様々な個数の引数を受け付ける場合は全ての仕組みをメソッドで自力でコードにすることができ、Rubyで凝ったメソッド定義したような感じで _振る舞う_
ようにできます。ありがたいことにAPIにはちょうどそういうことをするための早道があります。それを使うにはC配列関数の定義を使うとよく、それから`argc`と`argv`を以下の流れに沿って渡すことができます。

{% highlight c %}
{% include c/scan.h %}
{% endhighlight %}

ここで`fmt`はメソッド引数がRubyでどのような見た目をしているのかを記述する書式文字列です。文字列は最大6個の文字を持つことができ、そこではそれぞれの文字はそれぞれ異なる節の引数を記述するのです。6つの節と（順番通りに）対応する文字は以下の通りです。

1. 先頭にある必須引数の数：数字
2. オプション引数の数：数字
3. 展開される引数：`*`
4. 後ろに続く必須引数の数：数字
5. キーワード引数：`:`
6. ブロック引数：`&`

それぞれの節は省略できるので、必要ではないものについてはそのための文字を空けたままにできます。書式文字列の解析は貪欲に行われる点に注意してください。`1*`は必須引数と展開を持つメソッドを示しています。1つの
_オプション_ 引数と展開であってほしければ`01*`と指定せねばなりません。書式文字列にしたがってそれぞれの _Ruby_
の引数用に`VALUE*`を渡さなければなりません。渡されるポインタの数は6つの節の「合計」に等しいのですが、関心のない引数については`NULL`を渡すことができます。例えば書式文字列`21*&`には5つの`VALUE*`が渡されなければなりません（2つの必須引数、1つのオプション引数、1つの展開、1つのブロックです）。

`rb_scan_args()`は渡した`VALUE*`を使って`argv`を開封し、もし誤った数の引数が渡されたときは符牒が合わない旨の例外を投げます。

{% highlight c %}
{% include c/methodex.h %}
{% endhighlight %}

`rb_scan_args()`の返り値を使って関数がどう呼ばれたのかを確定することもできます。そうすることでRubyで渡された引数の数が返ります。

#### ブロックの扱い ####

Cのメソッドがブロック付きで呼ばれたかどうかを確認する方法は2つあります。

{% highlight c %}
{% include c/checkblock.h %}
{% endhighlight %}

Procとしてブロックを捕捉する方法は2つあります。メソッド引数に`rb_scan_args()`を使っている場合、書式文字列に`&`を含めるだけで取得できます。`rb_scan_args()`を使っていなければメソッドのブロックをProcに変換する`Proc.new`と等価なAPI呼び出しがあります。

    VALUE block;
    block = rb_block_proc();

ブロックを捉えたくなければyieldする方法が2つあります。

{% highlight c %}
{% include c/yield.h %}
{% endhighlight %}

`rb_yield_values()`のような`rb_yield_values2()`もあり、varargs`の代わりに2つ目の引数が`VALUE*`になっています[^yield]。

#### Super ####

You might want to call `super` in your method.

{% highlight c %}
{% include c/super.h %}
{% endhighlight %}

Unlike in Ruby `rb_call_super()` will **not** implicitly pass along the
method arguments to the super if you give it no arguments. You must
explicitly pass the correct `argc` and `argv` (it _does_ automatically pass
`self`). For that reason I recommend using the C array style of method
definition if you want to use `rb_call_super()`.

#### Definition ####

Setting up the C function is the hard part, now it's easy to define the
method in Ruby. Every API call to create a method takes at least the method
name (`char*`), a pointer to your C function, and an `argc` describing its
arguments.  `argc` should be:

1. For a fixed number of arguments, the number of arguments (not counting
   the receiver)
2. For a variable number of arguments in a C array, `-1`
3. For a variable number of arguments in a Ruby Array, `-2`

Everything is pretty self-explanatory from there:

{% highlight c %}
{% include c/methodr.h %}
{% endhighlight %}

There's also a shortcut for defining a method in a module _and_ its
singleton class. This is used a lot in `Math`, for example, letting you
`include Math` to avoid typing `Math.` before every method call.

{% highlight c %}
{% include c/modulefunc.h %}
{% endhighlight %}

### Other Stuff ###

Some simple API functions for class/method definitions:

{% highlight c %}
{% include c/etc.h %}
{% endhighlight %}

## Data ##

By now you should be able to create and manipulate Ruby classes using the
API, but how can you create a Ruby class that encapsulates data from the C
world? If your data can be naturally translated into `VALUE`s it's easy:
convert and assign to instance variables as usual. But what if your data
have no Ruby analog (e.g. data structures defined by some C library)?

The API lets you encapsulate C data by creating a `VALUE` of the desired
class and then storing a `void*` pointing to the C data inside the Ruby
object. Then whenever you need access to the C data, you can unpack the
pointer and cast it back to the correct type. But where does this
encapsulation occur? Let's answer that question with a question: what
happens when you tell Ruby to create an object using `new`? Basically this:

{% highlight ruby %}
{% include c/new.rb %}
{% endhighlight %}

Before calling the _instance method_ `initialize` that we know so well,
`new` first calls the _class method_ `allocate` to actually create the
object. That is the method you'll need to define if you want your objects to
wrap C data. The following example creates a class `Foo` which wraps an
`int` that can be set by `initialize`:

{% highlight c %}
{% include c/wrap.h %}
{% endhighlight %}

In most cases you'll probably be wrapping something more complicated (like a
`struct`), but the principles will be the same. After allocating the C data,
we use the `TypedData_Wrap_Struct()`[^oldwrap] macro to wrap the pointer in
a `VALUE`. This wrapping takes three arguments: the class of the object
(`self` because we're in a class method), a pointer to a struct, and the
data pointer to be wrapped. The tricky part is the struct pointer; it
provides additional information for internal use by Ruby:

* `wrap_struct_name` is a string used by Ruby to identify your type. It
  doesn't really matter what it is as long as it's sensible and unique
* `function` is a struct containing several function pointers for use by the
  garbage collector
* `dmark` will be described later, but as long your C data doesn't point to
  any Ruby objects you don't need it
* `dfree` will be called when your object is destroyed and should free all
  memory allocated by the object
* `dsize` is called by Ruby to check how much memory your object is taking
  up.  It _can_ be omitted, but it's polite to include it
* `data` can point to arbitrary data. Think of it as wrapping C data at a
  class level. Also not manadatory
* `flags` lets you enable additional optimizations when your objects are
  garbage collected. As long as your `dfree` function doesn't unlock the
  [GVL](#c-in-ruby-threads) (why would you do that???) you can safely set it
  to `RUBY_TYPED_FREE_IMMEDIATELY` for a slight performance improvement

If you don't set some of these members, you should zero them out so that
Ruby doesn't accidentally read garbage data. That's why I used C99's
[designated initializer][desinit] syntax in the example above: any members
you omit will be safely cleared by the compiler.

[desinit]: https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html

`VALUE`s that wrap C data will have type `T_DATA` with respect to the
[`TYPE()` macro](#value). This helps ensure a clear separation between
native Ruby objects and those wrapping C data.

Once you've done all of that work to wrap up the C data, getting it back out
is easy: `TypedData_Get_Struct()` takes the object to unwrap, the C type of
the underlying data, the same struct pointer as before, and the pointer to
assign the data to.

This separation of allocation and initialization doesn't jive with
[RAII][raii], so if you're using C++ you will probably want to use
[placement new][place] when wrapping data. If you're having trouble
splitting up allocation and initialization, you can just wrap your data in a
`struct` and do the _actual_ allocation in `initialize`.

[raii]: http://wikipedia.org/wiki/Resource_Acquisition_Is_Initialization
[place]: http://en.cppreference.com/w/cpp/language/new#Allocation

In simple cases (like the previous example) you can make your code a little
less verbose. If the function to free your data just calls `free()` as in
the example, you can pass `RUBY_DEFAULT_FREE` for `dfree` and Ruby will free
it for you (**don't** use `NULL` unless you like memory leaks). Similarly,
if your allocation is just a `malloc()` as in the example, the macro
`TypedData_Make_Struct()` does the allocation for you _and_ wraps it. We
could shorten the previous example as such:

{% highlight c %}
{% include c/makestruct.h %}
{% endhighlight %}

### Marking ###

That `dmark` pointer in the type structure above is the pointer to your
object's "mark function". This is so named because of the garbage
collector's "mark and sweep" algorithm. The basic idea behind mark and sweep
is that when the garbage collector needs to free up memory, it performs two
passes: the first (mark) pass iterates through every _referenced_ Ruby
object and marks it as active, then the second (sweep) pass iterates through
every _allocated_ Ruby object and frees the ones that haven't been marked
active.

This is relevant to wrapping C data because it's possible that you might
wrap a C `struct` which contains a Ruby `VALUE`&mdash;which the garbage
collector is responsible for cleaning up. Since the garbage collector is
only aware of `VALUE`s referenced _by Ruby_ (not by C pointers), it won't be
able to mark the referenced `VALUE` as active. The result is that as soon as
the garbage collector needs to free up some memory, your C data is going to
end up with a reference to a nonexistent Ruby object. Note that this kind of
wrapping of Ruby data inside C data is a really bad idea, precisely because
of this kind of issue. But if you really must...

In the following example, we'll wrap a C `struct` which contains a
`VALUE`. The mark function has the same signature as the free function and
all it has to do is mark any `VALUE`s in the `struct`:

{% highlight c %}
{% include c/mark.h %}
{% endhighlight %}

If your `struct` contains a pointer to a C array of `VALUE`s, you can
instead use `rb_gc_mark_locations()` which takes two arguments: the pointers
to the start and end of the array (the end being equal to the starting
pointer plus the array length).[^maybe]

## Threading ##

### Ruby in C Threads ###

If you're making a lot of API calls and running a lot of Ruby code from C,
at some point you might catch yourself thinking, "I'm running all of these
slow Ruby methods using the API. Maybe I can thread things to keep my code
fast!" That's a reasonable thought, but when you act on it keep in mind that
**the Ruby VM is not at all thread safe**. Ideally, all of your API code
should run in a single thread. If not, you'll probably need to wrap every
API call with a locked mutex to make sure that you never ever have multiple
threads interacting with the API at the same time.

If you just want to create normal Ruby `Thread`s using the API (and don't
mind the GVL, as described in the next section), there's an easy way to do
that:

{% highlight c %}
{% include c/thread.h %}
{% endhighlight %}

Other `Thread` functions are in `ruby/intern.h` (but there's always
`rb_funcall()` for everything else).

### C in Ruby Threads ###

On the other hand, if you expose some heavy C code to Ruby with the API (if
you're writing an extension that wraps a C library, for example), you should
spend some time thinking about a nasty thing called the global VM lock
(GVL).  Because most of the API is not `Thread` safe, the GVL locks down
almost all Ruby code so that only a single `Thread` can run at a time. This
is the reason why you'll often hear people say that `Thread` does not allow
true parallelism.

The VM also applies the GVL to any C code you expose to Ruby. That's why you
can use the API without worrying about it exploding when someone calls your
C code from inside a `Thread`. The downside of this is that if your C code
takes a while to run, you won't see any performance benefit from calling it
in a `Thread` because **it will block all other threads** while it runs. But
the GVL is only needed to protect API calls. If you have some C code that
doesn't use the API, you can tell the VM to release the GVL before running
your code in a thread and to reacquire it when it completes, allowing for
true parallelism.  Locking and unlocking the GVL does carry a performance
hit, so only resort to this if you notice that you're having significant
problems due to blocked threads.

The code to do this is considered so fancy by the Ruby developers that you
actually need to include another header to use it. First we'll look at the
slightly simpler way to release the GVL:

{% highlight c %}
{% include c/gvl2.h %}
{% endhighlight %}

Since the function that is run without the GVL gets and returns data using
`void*`, you may want to define a `struct` for passing data via pointers.

If you unlock the GVL as above you will find that while your code does run
in parallel, it can't be interrupted (by signals, `Thread.kill`, etc.)! To
allow for that you must pass an unblocking function using the last two
arguments:

{% highlight c %}
{% include c/gvl.h %}
{% endhighlight %}

The unblocking function is called in the event of an interrupt. To make it
work, you will probably need to pass a pointer to both functions that can be
used to communicate an interrupt from one to the other. The interrupted
function should perform any necessary cleanup before returning early.

Alternatively, if the interrupted function doesn't _need_ to perform any
special cleanup, you can use the built in unblocking function
`RUBY_UBF_IO`[^ubf] (which ignores the unblocking argument). That simply
forwards the interrupt to the running thread.[^int]

If you go through all of that effort to release the GVL only to find that
you need to make an API call in your unlocked thread, there's a function to
temporarily reacquire the GVL:

{% highlight c %}
{% include c/with_gvl.h %}
{% endhighlight %}

## See Also ##

### extension.rdoc ###

Ruby does have [official API documentation][readme]. It's a bit spotty and
has some poor recommendations (in my opinion), but it is also a little more
exhaustive on certain topics. In many cases this is because I intentionally
skipped something that I either found not useful or better documented
elsewhere.

[readme]: https://github.com/ruby/ruby/blob/master/doc/extension.rdoc

### Headers ###

I think some of the handiest resources are the Ruby headers themselves. The
full API (i.e. everything you get by including `ruby.h`) easily consists of
a thousand functions, macros, constants, and globals&mdash;most of which
have never been documented. However _most_ things are reasonably named and
you should be able to figure out what they do from the header. Most
everything you need should be in the headers `ruby/ruby.h` and
`ruby/intern.h`. The former has all of the VM and metaprogramming functions,
the latter has all of the functions for interacting with Ruby's built in
classes.

There are also some headers _not_ pulled in by `ruby.h` which you can
include to get additional API functionality. Maybe one day I'll write
another section to this guide going over them:

* `ruby/debug.h` (experimental) functions for profiling and tracing code
* `ruby/encoding.h` functions for working with string encodings
* `ruby/io.h` additional functions for Ruby's IO class
* `ruby/re.h` additional functions for Ruby's Regexp class
* `ruby/thread.h` functions for working with the [GVL](#c-in-ruby-threads)
* `ruby/version.h` functions for version introspection. Do not use this as
  feature-detection code!
* `ruby/vm.h` (experimental) functions for VM control

### Source ###

If you find some function in the header that isn't documented anywhere, your
next stop should be the Ruby source code.

{% highlight shell_session %}
$ git clone https://github.com/ruby/ruby.git
{% endhighlight %}

When reading through the source code, always keep the headers at hand: there
are lots of really useful functions in there that _look_ like they should be
in the API, but actually aren't. In most cases there should be an API
function elsewhere that wraps the call to the useful function.

### Examples ###

Head over to the [Examples](../examples) page for short, compilable examples
of the API in action.

### Contribute ###

Now that you've finished reading my guide, did you notice something
significant that I left out? Did I make some stupid mistake? Check out the
[source][gh] for this site on Github and you can report issues, submit pull
requests, and download all of the code examples.

[gh]: https://github.com/silverhammermba/emberb

## 脚註 ##

[^intern]: That's a blatant lie. The API _definitely_ lets you mess around
           with the internal data structures of objects (look for things with
           names starting with capital R). But it's generally not a good idea
           and not necessary.

[^undef]: There's also `Qundef` representing an undefined value, but
          this has no Ruby equivalent and is [rarely](#handling-blocks)
          [used](#constants-1). In fact, outside of those rare occassions,
          `Qundef` can segfault the VM if Ruby was expecting a normal `VALUE`.

[^wrap]: There's also `rb_eval_string_wrap()` which _should_ be useful, but is
         actually the same as `rb_eval_string_protect()` due to a [bug][bug2].

[^chr]: There is a `CHR2FIX()` macro, but in my tests this sometimes gave
        unexpected results. `LONG2FIX()` should work.

[^wchar]: I don't know what the best way is to handle `wchar_t`. In my tests I had
          some success just treating them as `char`s, but I think that may have
          been a happy accident, and could certainly fail on different platforms.

[^clear]: The documentation [states][control] that "You have to clear the error
          info [when] ignoring the caught exception" during `rb_protect`. But I
          can't find any documentation of when it would be cleared for
          you&mdash;it seems like you _always_ have to clear it.

[^yield]: And there's `rb_yield_block()` which takes two unused arguments and is
          never called by anything in Ruby. Odd.

[^break]: The documentation [mentions][control] `rb_iter_break()` and
          `rb_iter_break_value()` for breaking out of a block, but can't you
          just return early? I can't think of a use-case for these.

[^int]: There is also the function `rb_thread_call_without_gvl2()`. The
        documentation in `thread.c` says that if it "detects interrupt, it
        returns immediately," but I'm not sure what this means. If the
        unblocking function doesn't kill the thread, it still waits for the
        thread to finish on its own before returning.

[^ubf]: You can also use `RUBY_UBF_PROCESS`, but this seems to be a leftover
        from deprecated code and has the exact same effect.

[^oldwrap]: The `TypedData*` macros are the preferred way to wrap data since
            Ruby 1.9.2. If you're using an older version of Ruby you can check
            out an older version of this guide on Github to see how it used to
            be done.

[^maybe]: There's also the enigmatically named `rb_gc_mark_maybe()`, but I'm not
          sure when it is needed.

[^tdata]: Or use `T_DATA` if the object [wraps a C pointer](#data).

[control]:
https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-Control+Structure
[bug2]: https://bugs.ruby-lang.org/issues/10466
