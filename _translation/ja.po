# Japanese translations for emberb
# emberbの和訳
# Copyright (C) 2022, 2023 gemmaro.
# This file is distributed under the same license as the emberb.
#
# TODO: rescueとレスキューのどちらかに揃える
#
# TODO: translate bellow in Makefile
#
#   # this is just a hack to get the Ruby version in this guide
#   # you can just hard-code it e.g. RUBY=2.4
msgid ""
msgstr ""
"Project-Id-Version: https://silverhammermba.github.io/emberb/\n"
"POT-Creation-Date: 2024-10-22 21:20+0900\n"
"PO-Revision-Date: 2024-10-22 21:21+0900\n"
"Last-Translator: gemmaro <gemmaro.dev@gmail.com>\n"
"Language-Team: none\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: Yaml Front Matter Hash Value: layout
#: ../_posts/2010-01-01-c.markdown:1 ../_posts/2012-01-01-embed.markdown:1
#: ../_posts/2013-01-01-extend.markdown:1
#: ../_posts/2014-01-01-examples.markdown:1
#, no-wrap
msgid "chapter"
msgstr "chapter"

#. type: Yaml Front Matter Hash Value: title
#: ../_posts/2010-01-01-c.markdown:1
#, no-wrap
msgid "The Ruby C API"
msgstr "RubyのC API"

#. type: Title ##
#: ../_posts/2010-01-01-c.markdown:6
#, no-wrap
msgid "Before You Start"
msgstr "始める前に"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:10
msgid ""
"For the greatest chance of success with this guide, I recommend being fairly "
"comfortable with C and _very_ comfortable with Ruby."
msgstr ""
"この手引きを完全に理解するためには、C言語はそこそこ、Rubyは _かなり_ 慣れ親し"
"んでいるとよいでしょう。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:16
msgid ""
"Using Ruby's C API does not require any advanced C concepts, however the API "
"is **huge** and largely **undocumented**. After you start using it, you will "
"likely find yourself delving through the Ruby source code at some point to "
"figure out the behavior of some obscure function or macro. The Ruby source "
"uses some fairly sophisticated C, so you should at least feel comfortable "
"reading it."
msgstr ""
"RubyのC APIを使うのに発展的なC言語の概念は要りませんが、APIは**膨大**で大半が"
"**文書化されていません**。APIを使い始めだすと、いつの日にか、はっきりしない関"
"数やマクロの挙動を調べるためにRubyのソースコードを探ることになるでしょう。"
"Rubyのソースはそこそこ洗練されたC言語で書かれているので、すいすい読めはするで"
"しょうけれども。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:22
msgid ""
"You can think of the C API is being a big, clunky alternative to writing "
"normal Ruby code. However the simple, elegant patterns of Ruby can be pretty "
"unintuitive once translated into the language of the API. Having a strong "
"intuition for Ruby's internal logic and the ideas behind its design will go "
"a long way toward steering you toward the correct API functions."
msgstr ""
"C APIは、普通のRubyのコードよりもデカくてゴチャっとした書き方だと見なせます。"
"とはいえ、簡素で明快なRubyの様式は、ひとたびAPIの言葉に翻訳されるとかなり非直"
"感的になることがあります。Rubyの内部的な仕組みと設計の背景にある思想に裏打ち"
"されたしっかりとした直感があれば、長い旅路のさなかでも正しいAPI関数へと進み続"
"けられるでしょう。"

#. type: Title ##
#: ../_posts/2010-01-01-c.markdown:23
#, no-wrap
msgid "The Two Paths"
msgstr "分岐点"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:28
msgid ""
"The official Ruby interpreter is written in C. That means that everything "
"you can do in Ruby, you can also do using function calls to Ruby's C API. "
"Why in the world would you do this? There are two good reasons:"
msgstr ""
"公式のRubyインタプリタはC言語で書かれています。\n"
"Rubyでできるあらゆることは、RubyのC APIを呼び出す関数を使ってもできます。\n"
"いったいなぜそんなことをするのでしょうか？\n"
"もっともな理由が2つあります。"

#. type: Bullet: '1. '
#: ../_posts/2010-01-01-c.markdown:37
msgid ""
"You're writing some fancy application in C or C++ and you want some parts of "
"your code to leverage the dynamic flexibility of Ruby. You can run the Ruby "
"interpreter inside of your application and use the API to retrieve the "
"results of Ruby code."
msgstr ""
"意匠を凝らしたC言語ないしC++のアプリケーションを書いている最中で、\n"
"Rubyの動的な柔軟性をコードのいくつかの箇所に使って、\n"
"効果を引き出そうとするとき。\n"
"アプリケーションの内部でRubyインタプリタを実行でき、\n"
"Rubyのコードの結果をAPIで受け取ることができます。"

#. type: Bullet: '2. '
#: ../_posts/2010-01-01-c.markdown:37
msgid ""
"You're writing some fancy application in Ruby and you want some parts of "
"your code to leverage the speed and power of C (or an existing C library). "
"You can expose C code to Ruby using the API and compile a special library "
"that Ruby can `require`."
msgstr ""
"意匠を凝らしたRubyのアプリケーションを書いている最中で、\n"
"C言語（もしくは既にあるC言語のライブラリ）の速度と能力を\n"
"コードのいくつかの箇所に使って、\n"
"効果を引き出そうとするとき。\n"
"APIを使えば、RubyにC言語のコードをさらけ出すことができます。\n"
"そうしてできた特別なライブラリをコンパイルするとRubyから `require` できます。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:42
msgid ""
"You'll need to structure your C code differently depending on your goal. If "
"you want to embed the Ruby interpreter in C, read [Running Ruby in C](../"
"embed). If you want to `require` a compiled C library, read [Running C in "
"Ruby](../extend).  After you finish that, come back here to learn about the "
"API."
msgstr ""
"目標によってC言語のコードの組み立てかたは変わってきます。\n"
"C言語にRubyインタプリタを組込みたければ、[C言語でRubyを実行する](../embed)を"
"お読みください。\n"
"コンパイルされたC言語のライブラリを `require` したければ、[RubyでC言語を実行"
"する](../extend)をお読みください。\n"
"どちらかを読み終えたら、ここに戻ってきてAPIについて学びましょう。"

#. type: Title ##
#: ../_posts/2010-01-01-c.markdown:43
#, no-wrap
msgid "Eval"
msgstr "Eval"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:46
msgid "The quick 'n' dirty way to run some Ruby code from C is to `eval` it"
msgstr "ちゃちゃっと雑にCでRubyを動かすには、 `eval` します。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:50
msgid "{% highlight c %} {% include c/eval.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/eval.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:55
msgid ""
"This is a good fallback if you can't find an API function for something that "
"you want to do[^wrap]. `rb_eval_string_protect()` returns the result of the "
"Ruby code and sets `state` to some nonzero value if any exception is raised. "
"`VALUE` is the C data type for all Ruby objects, as explained in the next "
"section."
msgstr ""
"これはやりたいことをするためのAPI関数が見つからないときは選択肢に入ります"
"[^wrap]。`rb_eval_string_protect()` はRubyのコードの結果を返し、何か例外が発"
"生したときはゼロではない値を `state` に設定します。`VALUE` はあらゆるRubyのオ"
"ブジェクトのためのCのデータ型です。次の節で後述します。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:60
msgid ""
"If `state` is nonzero, `result` will be a `VALUE` representing `nil` and you "
"should handle the exception. Alternatively, you can use `rb_eval_string()` "
"which doesn't take a `state` argument and instead raises any exceptions "
"normally. See [Exceptions](#exceptions) for how to handle both of these "
"cases."
msgstr ""
"`state` がゼロではないとき、`result` は `nil` を表す `VALUE` になっているで"
"しょうから、そのときは例外に対処しなければいけません。代わりに "
"`rb_eval_string()` を使うこともできます。この関数は引数 `state` を取らず、通"
"常の方法で例外を発生させます。これら2つの場合での制御方法については[例外]"
"(#exceptions)の節を参照してください。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:64
msgid ""
"Unlike `eval` in Ruby, these functions evaluate the string in an isolated "
"binding—like when you `require` something. So local variables in the string "
"will not be accessible from elsewhere and vice versa."
msgstr ""
"Rubyでの`eval`とは異なり、これらの関数は何かしらを`require`したときに、独立し"
"たbindingのようなものの中で文字列を評価します。\n"
"そのため文字列中の局所変数は他所から参照できませんし、逆もまた然りです。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:69
msgid ""
"However, like using `eval` in Ruby, using these functions is not a good "
"practice. It's inefficient since the parser is invoked and it somewhat "
"defeats the point of writing in C. If you just want to call some Ruby "
"method, we'll go over a better way to do that [later on](#send)."
msgstr ""
"しかし、Rubyで `eval` するときのように、\n"
"これらの関数を使うことはあまりよくありません。\n"
"パーサが起動されなければいけないのが非効率ですし、\n"
"Cで書くことの利点が失われています。\n"
"Rubyのメソッドを呼びたいだけであれば、\n"
"もっといい方法を[後述](#send)します。"

#. type: Title ##
#: ../_posts/2010-01-01-c.markdown:70
#, no-wrap
msgid "VALUE"
msgstr "VALUE"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:79
msgid ""
"Before we go any further, we need to understand `VALUE`s. Due to the danger "
"of monkeying around inside the VM, the API never lets you directly access "
"Ruby's objects[^intern]. Instead, your C code will store and pass around "
"_pointers_ to Ruby objects (like how variables in Ruby contain pointers to "
"objects). These pointers can be passed to various API functions and macros "
"that will safely access and manipulate the Ruby objects. `VALUE` is the API-"
"defined C type for these pointers."
msgstr ""
"先に進む前に、\n"
"`VALUE` について理解しなければいけません。\n"
"VMの内部をめちゃくちゃにしてしまう危険があるので、\n"
"APIからは直接Rubyのオブジェクトを扱えません[^intern]。\n"
"その代わり、CのコードはRubyのオブジェクトへの _ポインタ_ を保持したり受け渡し"
"たりします（Rubyの変数がオブジェクトへのポインタを持つのと同じです）。\n"
"ポインタはさまざまなAPIの関数やマクロに渡すことができ、\n"
"そのためRubyのオブジェクトに安全にアクセスしたり操作したりできます。\n"
"`VALUE` はAPIで定義されたCの型で、このポインタを扱います。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:84
msgid ""
"Probably the most frequent question you'll have is: \"is this `VALUE` the "
"right type?\". There are a couple macros for performing this test, and both "
"take a [`T_` constant][datatypes] corresponding to the Ruby class you're "
"testing for e.g. `T_STRING`, `T_ARRAY`, etc."
msgstr ""
"おそらく最も頻繁に湧いてくる疑問は次のようなものでしょう。\n"
"「この `VALUE` は正しい型なのだろうか？」\n"
"この疑問に答えるマクロは2つあり、\n"
"そのどちらも[`T_` 定数](datatypes)を引数に取ります。\n"
"この定数は比較したい型に対応するRubyのクラスです。\n"
"例えば `T_STRING` や `T_ARRAY` などです。"

# 空白を空けないことによって意図しない改行を回避しています
#. type: Link reference
#: ../_posts/2010-01-01-c.markdown:85
#, no-wrap
msgid "[datatypes]: https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-Data+Types"
msgstr "[datatypes]:https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-Data+Types"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:90
msgid "{% highlight c %} {% include c/checktype.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/checktype.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:96
msgid ""
"These tests work for subclasses too: if you're testing for a subclass of "
"`Array` use `T_ARRAY`, if you're testing for a subclass of `Object` use "
"`T_OBJECT`[^tdata]. That being said, these tests _do not work like `is_a?`_; "
"even though everything in Ruby `is_a? Object`, testing against `T_OBJECT` "
"will only return true for objects for which there is no better fitting "
"constant."
msgstr ""
"この検査はサブクラスでも同様にはたらきます。\n"
"`Array` のサブクラスであることを確認したいときは `T_ARRAY` を使いますし、\n"
"`Object` のサブクラスであることを確認したいときには `T_OBJECT` を使います"
"[^tdata]。\n"
"つまり、この検査は _`is_a?` と同じではない_ ということでもあります。\n"
"Rubyのありとあらゆるものについて `is_a? Object` であるにせよ、\n"
"`T_OBJECT` に対する検査は、\n"
"他にもっと適した定数がないときにのみ真となります。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:99
msgid ""
"For certain classes, there are specialized macros that are a little more "
"efficient than the previous:"
msgstr "特定のクラスについては、前述したものより少し便利なマクロが使えます。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:103
msgid "{% highlight c %} {% include c/check_p.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/check_p.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:107
msgid ""
"If you want to handle a `VALUE` that could be one of a variety of types, the "
"previous macros can be a little clumsy. In that case you can use the "
"`TYPE()` macro to get the `T_` constant and handle your logic in a `switch`:"
msgstr ""
"いくつかの型を取りうる `VALUE` を扱いたいときは、前述のマクロはちょっと不恰好"
"です。そんな場合は `TYPE()` マクロを使って `T_` 定数を取得し、`switch` 文で制"
"御できます。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:111
msgid "{% highlight c %} {% include c/type.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/type.h %}\n"
"{% endhighlight %}"

#. type: Title ###
#: ../_posts/2010-01-01-c.markdown:112
#, no-wrap
msgid "Constants"
msgstr "定数"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:121
msgid ""
"Most of the standard Ruby constants have global `VALUE`s defined for them in "
"the API so you don't need an API call to access them. Modules are prefixed "
"with `rb_m` e.g. `rb_mKernel`; classes are prefixed with `rb_c` e.g. "
"`rb_cObject`; subclasses of `Exception` are prefixed with `rb_e` e.g. "
"`rb_eRuntimeError`; and the standard IO streams are prefixed with `rb_` e.g. "
"`rb_stderr`. `nil`, `false`, and `true` are prefixed with `Q` e.g. `Qnil`."
"[^undef] As a convenience, `Qfalse` is also false in C (`0`)."
msgstr ""
"ほとんどの標準的なRubyの定数はAPIで大域的な `VALUE` が定義されています。した"
"がってそうした定数を使うのにAPIの呼び出しは要りません。モジュールは `rb_m` で"
"前置されます。例えば`rb_mKernel` です。クラスは `rb_c` で前置されます。例えば"
"`rb_cObject` です。`Exception` のサブクラスは `rb_e` で前置されます。例えば"
"`rb_eRubtimeError` です。標準的なIOストリームは `rb_` で前置されます。例えば"
"`rb_stderr` です。`nil`, `false`, `true` は `Q` で前置されます。例えば "
"`Qnil` です[^undef]。便宜上、 `Qfalse` はCの偽値 (`0`) でもあります。"

#. type: Title ###
#: ../_posts/2010-01-01-c.markdown:122
#, no-wrap
msgid "Translation"
msgstr "変換"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:126
msgid ""
"A few Ruby classes are analogous to C types. These classes will be your "
"primary means of transferring data between C and Ruby."
msgstr ""
"いくつかのRubyのクラスはCの型に対応します。\n"
"この対応する組み合わせは、CとRubyの間のデータのやりとりにうってつけです。"

#. type: Title ####
#: ../_posts/2010-01-01-c.markdown:127
#, no-wrap
msgid "Fixnum"
msgstr "Fixnum"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:133
msgid ""
"Ruby's `Fixnum` corresponds to C's `long`. The `FIX2LONG()` macro gives you "
"the `long` for a `Fixnum`. For smaller C types there's `FIX2UINT()`, "
"`FIX2INT()`, and `FIX2SHORT()`, but these will raise a `RangeError` if the "
"number wouldn't fit."
msgstr ""
"Rubyの `Fixnum` はCの `long` に対応します。\n"
"`FIX2LONG()` マクロにより、 `long` を `Fixnum` に変換できます。\n"
"より小さいCの型については、\n"
"`FIX2UINT()`, `FIX2INT()`, `FIX2SHORT()` があります。\n"
"しかし、これらのマクロは変換時に数値が大きすぎて収まらない場合は "
"`RangeError` を生じます。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:136
msgid ""
"In the other direction, `LONG2FIX()` works for `long` **and** every smaller "
"integer C type[^chr]."
msgstr ""
"逆向きの変換もできて、\n"
"`LONG2FIX()` は `long` *に加えて* `long` より小さい全てのCの整数型からの変換"
"に使えます。"

#. type: Title ####
#: ../_posts/2010-01-01-c.markdown:137
#, no-wrap
msgid "Bignum"
msgstr "Bignum"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:143
msgid ""
"Ruby's `Bignum` is for anything bigger than a `Fixnum`, so it works if you "
"need to work with `long long`, for example. `rb_big2ll()` and `rb_big2ull()` "
"will get you `long long` and `unsigned long long` from a `Bignum` (or raise "
"a `RangeError` if appropriate)."
msgstr ""
"Rubyの `Bignum` は `Fixnum` より大きいあらゆる整数に使えます。例えば `long "
"long` が必要なときとかです。`rb_big2()` と `rb_big2u()` を使えば、 `Bignum` "
"からそれぞれ `long long` や `unsigned long long` に直せます（直せなければ"
"`RangeError` が発生します）。"

# Numericは節の名前なので訳しません。
#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:145 ../_posts/2010-01-01-c.markdown:152
msgid "See [Numeric](#numeric) for the reverse direction."
msgstr "逆向きの変換については [Numeric](#numeric) を参照してください。"

#. type: Title ####
#: ../_posts/2010-01-01-c.markdown:146
#, no-wrap
msgid "Float"
msgstr "Float"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:150
msgid ""
"Ruby's `Float` corresponds to C's `double`. The `RFLOAT_VALUE()` macro gives "
"you the `double` for a `Float`."
msgstr ""
"Rubyの `Float` はCの `double` に対応します。\n"
"`RFLOAT_VALUE()` マクロを使えば、 `Float` から `double` が得られます。"

#. type: Title ####
#: ../_posts/2010-01-01-c.markdown:153
#, no-wrap
msgid "Numeric"
msgstr "Numeric"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:158
msgid ""
"There are a host of \"NUM\" macros that try to be more duck-typish about "
"things.  These will convert their C types to whatever Ruby `Numeric` "
"subclass seems appropriate:"
msgstr ""
"たくさんの \"NUM\" マクロがあり、\n"
"ダックタイピングっぽい使いかたをしています。\n"
"これらのマクロはCの型を適切と思われるRubyの `Numeric` のサブクラス（のインス"
"タンス）に変換します。"

#. type: Bullet: '* '
#: ../_posts/2010-01-01-c.markdown:166
msgid "`INT2NUM()` for `int`"
msgstr "`INT2NUM()` は `int` からの変換用"

#. type: Bullet: '* '
#: ../_posts/2010-01-01-c.markdown:166
msgid "`UINT2NUM()` for `unsigned int`"
msgstr "`UINT2NUM()` は `unsigned int` からの変換用"

#. type: Bullet: '* '
#: ../_posts/2010-01-01-c.markdown:166
msgid "`LONG2NUM()` for `long`"
msgstr "`LONG2NUM()` は `long` からの変換用"

#. type: Bullet: '* '
#: ../_posts/2010-01-01-c.markdown:166
msgid "`ULONG2NUM()` for `unsigned long`"
msgstr "`ULONG2NUM()` は `unsigned long` からの変換用"

#. type: Bullet: '* '
#: ../_posts/2010-01-01-c.markdown:166
msgid "`LL2NUM()` for `long long`"
msgstr "`LL2NUM()` は `long long` からの変換用"

#. type: Bullet: '* '
#: ../_posts/2010-01-01-c.markdown:166
msgid "`ULL2NUM()` for `unsigned long long`"
msgstr "`ULL2NUM()` は `unsigned long long` からの変換用"

#. type: Bullet: '* '
#: ../_posts/2010-01-01-c.markdown:166
msgid "`DBL2NUM()` for `double`"
msgstr "`DBL2NUM()` は `double` からの変換用"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:171
msgid ""
"And there are macros for the opposite direction, which will try to convert "
"whatever `Numeric` to the desired C type. These will raise a `RangeError` if "
"the value wouldn't fit or `TypeError` if there is no implicit numeric "
"conversion (so you can safely pass non-`Numeric` objects)."
msgstr ""
"そして、逆方向のマクロもあります。\n"
"これらのマクロは、あらゆる `Numeric` な数値から欲しいCの型の値への変換を試み"
"るものです。\n"
"値が範囲に収まらなかったときは `RangeError` を発生させますし、\n"
"暗黙の数値の変換ができなかったときは `TypeError` が発生します（なので "
"`Numeric` ではないオブジェクトを渡しても大丈夫です）。"

#. type: Bullet: '* '
#: ../_posts/2010-01-01-c.markdown:182
msgid "`NUM2CHR()` for `char` (works for `unsigned char` too)"
msgstr ""
"`NUM2CHR()` は `char` からの変換用（`unsigned char` からでも変換できます）"

#. type: Bullet: '* '
#: ../_posts/2010-01-01-c.markdown:182
msgid "`NUM2SHORT()` for `short`"
msgstr "`NUM2SHORT()` は `short` からの変換用"

#. type: Bullet: '* '
#: ../_posts/2010-01-01-c.markdown:182
msgid "`NUM2USHORT()` for `unsigned short`"
msgstr "`NUM2USHORT()` は `unsigned short` からの変換用"

#. type: Bullet: '* '
#: ../_posts/2010-01-01-c.markdown:182
msgid "`NUM2INT()` for `int`"
msgstr "`NUM2INT()` は `int` からの変換用"

#. type: Bullet: '* '
#: ../_posts/2010-01-01-c.markdown:182
msgid "`NUM2UINT()` for `unsigned int`"
msgstr "`NUM2UINT()` は `unsigned int` からの変換用"

#. type: Bullet: '* '
#: ../_posts/2010-01-01-c.markdown:182
msgid "`NUM2LONG()` for `long`"
msgstr "`NUM2LONG()` は `long` からの変換用"

#. type: Bullet: '* '
#: ../_posts/2010-01-01-c.markdown:182
msgid "`NUM2ULONG()` for `unsigned long`"
msgstr "`NUM2ULONG()` は `unsigned long` からの変換用"

#. type: Bullet: '* '
#: ../_posts/2010-01-01-c.markdown:182
msgid "`NUM2LL()` for `long long`"
msgstr "`NUM2LL()` は `long long` からの変換用"

#. type: Bullet: '* '
#: ../_posts/2010-01-01-c.markdown:182
msgid "`NUM2ULL()` for `unsigned long long`"
msgstr "`NUM2ULL()` は `unsigned long long` からの変換用"

#. type: Bullet: '* '
#: ../_posts/2010-01-01-c.markdown:182
msgid "`NUM2DBL()` for `double`"
msgstr "`NUM2DBL()` は `double` からの変換用"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:189
msgid ""
"A **major** gotcha with these is that _none_ of the macros for converting to "
"unsigned types raise an exception if you pass a negative value (surprisingly "
"this [isn't a bug][bug]). `NUM2CHR()` also has a couple quirks: it will only "
"raise a `RangeError` if the value is too big for an _int_ and when passed a "
"string it returns the numeric value of the first character rather than "
"raising a `TypeError`."
msgstr ""
"これらのマクロについて **特に** 注意すべき点は、符号なしの型に変換に変換する "
"*どの* マクロも、負値を渡したときに例外が発生しないということです（驚くべきこ"
"とに[バグではありません][bug]）。`NUM2CHR()` にはもう2つ妙なところがありま"
"す。変換前の値が _int_ には大きすぎるときに `RangeError` のみ生じることと、文"
"字列を渡したときに `TypeError` を発生させず最初の文字の数値を返すということで"
"す。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:192
msgid ""
"If you know that the conversion is safe, you should prefer the macros from "
"the previous sections as they skip the range checks."
msgstr ""
"変換が安全だとわかっていれば、\n"
"前の節のマクロのほうを使うべきです。\n"
"なぜなら範囲の確認を省けるためです。"

#. type: Link reference
#: ../_posts/2010-01-01-c.markdown:193
#, no-wrap
msgid "[bug]: https://bugs.ruby-lang.org/issues/9089"
msgstr "[bug]: https://bugs.ruby-lang.org/issues/9089"

#. type: Title ####
#: ../_posts/2010-01-01-c.markdown:195
#, no-wrap
msgid "String"
msgstr "String"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:203
msgid ""
"Ruby's `String` kinda corresponds to C's `char*`. The simplest macro is "
"`StringValueCStr()` which returns a null-terminated `char*` for a `String`. "
"The problem here is that a Ruby `String` _might contain nulls_ - in which "
"case `StringValueCStr()` will raise an `ArgumentError`! Instead you can use "
"the macros `StringValuePtr()` and `RSTRING_LEN()` to get a (possibly "
"unterminated)  `char*` and the string's length as a `long`."
msgstr ""
"Rubyの `String` はだいたいCの `char*` に対応します。もっとも簡素なマクロは "
"`StringValueCStr()` です。このマクロは `String` からnull終端付きの `char*` を"
"返します。ただしこれには問題があって、Rubyの `String` が *nullを含むかもしれ"
"ません*。そのような場合には `StringValueCStr()` は `ArgumentError` を発生させ"
"ます！その代わりに `StringValuePtr()` マクロと `RSTRING_LEN()` マクロを使え"
"ば、それぞれ（終端が付いていない可能性がある）`char*` とその長さの `long` 値"
"を取得できます。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:211
msgid ""
"Conversely, if you have a null-terminated `char*`, you can use "
"`rb_str_new_cstr()` to create a Ruby `String`. And if you want your `String` "
"to contain nulls, use `rb_str_new()` which takes a `char*` and the string's "
"length (as a `long`). The encodings of these strings will be `ASCII-8BIT`, "
"which is often undesirable in Ruby. You can pass the string `VALUE` to "
"`rb_str_export_locale()` to get a new `VALUE` with your locale's "
"encoding[^wchar]."
msgstr ""
"逆に、null終端付きの `char*` からRubyの `String` への変換には、"
"`rb_str_new_cstr()` が使えます。\n"
"そして、もし `String` にnullを含めたいときは、`rb_str_new()` を使います。\n"
"`rb_str_new()` は `char*` と文字列の長さ（型は `long`）を引数に取ります。\n"
"これらの文字列のエンコーディングは `ASCII-8BIT` なのですが、Ruby側のコードで"
"望んだものではないこともあります。\n"
"そんなときは文字列の `VALUE` を `rb_str_export_locale()` に渡して、自分のロ"
"ケールのエンコーディングでの `VALUE` を取得できます。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:218
msgid ""
"If you want to build more complex strings, you can do so using the `printf`-"
"like function `rb_sprintf()`. This accepts all of the usual conversion "
"specifiers, but also accepts an API-defined specifier `PRIsVALUE` which "
"takes a corresponding `VALUE` argument. This conversion specifier "
"substitutes a string by sending the object `to_s`. You can substitute the "
"result of `inspect` instead by adding the `+` flag."
msgstr ""
"もっと複雑な文字列を構築したければ、`printf` のような関数 `rb_sprintf()`があ"
"ります。この関数では通常の変換での全ての指定子だけではなく、APIで定義された指"
"定子 `PRIsVALUE` も使えます。`PRIsVALUE` は対応する `VALUE` を引数に取りま"
"す。この変換指定子はオブジェクトに `to_s` メッセージを送って文字列に置き換え"
"ます。`+` フラグを加えることで `inspect` を使った結果の文字列に置き換えること"
"もできます。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:222
msgid "{% highlight c %} {% include c/printf.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/printf.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:227
msgid ""
"This custom specifier should work for any `printf`-like function in the "
"API.  `PRIsVALUE` works by hijacking the `i` conversion specifier, so when "
"printing an `int` you should use `d` to ensure that Ruby doesn't think it's "
"actually a `VALUE`."
msgstr ""
"この独自の指定子はAPIにあるあらゆる `printf` っぽい関数で使えるでしょう。"
"`PRIsVALUE` は `i` 変換指定子を間借りすることで実現されているので、Rubyに「そ"
"れって実は `VALUE` なんじゃないか」と勘違いさせないように、`int` を文字列にす"
"るときは `d` を使うべきです。"

#. type: Title ####
#: ../_posts/2010-01-01-c.markdown:228
#, no-wrap
msgid "Symbol"
msgstr "Symbol"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:236
msgid ""
"The API defines a C type `ID` which corresponds to Ruby's `Symbol`. Just "
"like how Ruby passes around `Symbol`s as method or variable names, many API "
"calls that need a method or variable name use an `ID`. To convert between a "
"`Symbol` and an `ID` use the `SYM2ID()` and `ID2SYM()` macros. Instead of a "
"`Symbol` you may want to convert to/from a `char*` C string. To get an `ID` "
"from a `char*` use `rb_intern()` and for the reverse use `rb_id2name()`."
msgstr ""
"APIではRubyの `Symbol` に対応するCの型 `ID` が定義されています。Rubyが "
"`Symbol` をメソッドや変数名として受け渡しするように、多くのAPI呼び出しでメ"
"ソッドや変数の名前として`ID` を使うようにしています。`Symbol` と `ID` を変換"
"するには、 `SYM2ID()` と `ID2SYM()` マクロを使います。`Symbol` ではなくCの文"
"字列 `char*` と相互に変換したいときもあるでしょう。`char*` から `ID` を取得す"
"るためには `rb_intern()` を、その逆向きでは `rb_id2name()` を使います。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:246
msgid ""
"Since many API functions require an `ID` and in many cases you will not have "
"the appropriate `ID` at hand, the API also defines a slew of functions that "
"instead take a `char*` and which do the `rb_intern()` call for you. Since "
"these functions are often more readable and the overhead of the "
"`rb_intern()` call is negligible, I have opted to use the `char*` versions "
"of the API functions wherever possible in this guide. If you find yourself "
"frequently using a certain C string in API calls, you may see some "
"performance benefit by storing the `ID` and using the `ID` versions of the "
"functions (though you'll have to look these up yourself in the Ruby headers)."
msgstr ""
"多くのAPI関数が `ID` を必要としていますが、適切な `ID` が手元にないことも沢山"
"あるでしょう。\n"
"そのため、代わりに `char*` を引数に取って自動で `rb_intern()` してくれる関数"
"も沢山あります。\n"
"これらの関数はより読みやすく、 `rb_intern()` の呼び出しでのオーバーヘッドは無"
"視できる程度なので、本手引きでは可能な限り `char*` バージョンのAPI関数が使わ"
"れる傾向にあります。\n"
"特定のCの文字列をAPIの呼出しで頻繁に使う場合は、`ID` に変換して保管しておき、"
"`ID` バージョンの関数を使うことでいくらかの効率性の向上を確かめられるかもしれ"
"ません（Rubyのヘッダから自分で見つける必要がありますが）。"

#. type: Title ##
#: ../_posts/2010-01-01-c.markdown:247
#, no-wrap
msgid "Send"
msgstr "send"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:253
msgid ""
"This section contains API functions for directly calling Ruby methods. You "
"should prefer these functions to `rb_eval_string()` and the like whenever "
"possible. They are faster since they skip the parser and allow for some "
"compile-time checks."
msgstr ""
"この節には直接Rubyのメソッドを呼び出すAPI関数が含まれます。`rb_eval_string()`"
"などより、できるだけ常にこれらの関数を贔屓すべきです。これらの関数では構文解"
"析の過程が飛ばされますし、いくつかのコンパイル時検査が免除されるのでより速い"
"のです。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:255
msgid "The easiest way to send an object a method looks like this:"
msgstr "一番簡単な方法はオブジェクトにメソッドをこのように送ることです。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:259
msgid "{% highlight c %} {% include c/funcall.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/funcall.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:261
msgid "This is roughly equivalent to the Ruby code"
msgstr "これは大雑把には次のRubyコードと同じです。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:265
msgid "{% highlight ruby %} {% include c/funcall.rb %} {% endhighlight %}"
msgstr ""
"{% highlight ruby %}\n"
"{% include c/funcall.rb %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:270
msgid ""
"The first argument is the receiver. The next is the [`ID`](#symbol) for the "
"method name. The third argument is the number of method arguments, which is "
"needed since `rb_funcall()` is a varargs function. Then come the actual "
"method arguments."
msgstr ""
"最初の引数はレシーバです。その次はメソッド名用の[`ID`](#symbol)です。3つ目の"
"引数はメソッド引数の数です。この引数が必要なのは`rb_funcall()`がvarargs関数だ"
"からです。それから実際メソッド引数に行き着きます。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:274
msgid ""
"Alternatively, you can use `rb_funcallv()` where the fourth argument is a "
"`VALUE*` pointing to a C array of arguments. This also has the variant "
"`rb_funcallv_public()` which is like `public_send` in Ruby."
msgstr ""
"これに代えて4つ目の引数が引数のCの配列を指す`VALUE*`になっている"
"`rb_funcallv()`を使うことができます。これにもRubyでの`public_send`のような派"
"生、`rb_funcallv_public()`があります。"

#. type: Title ###
#: ../_posts/2010-01-01-c.markdown:275
#, no-wrap
msgid "Passing Blocks"
msgstr "ブロックを渡す"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:279
msgid ""
"If you want to pass a `Proc` as the block to a method, that's easy. The "
"function is just like `rb_funcallv()` but with the proc on the end."
msgstr ""
"`Proc`をブロックとしてメソッドに渡したければ話は早いです。\n"
"関数はほぼ`rb_funcallv()`と同じですが後ろにprocが付きます。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:283
msgid "{% highlight c %} {% include c/proc.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/proc.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:287
msgid ""
"If you don't have a proc for the block, you'll need to define a certain kind "
"of C function to represent the block. Then there's a different variant of "
"`rb_funcallv()` but with a couple extra arguments for the block:"
msgstr ""
"ブロック用のprocがなければ、ブロックを表現する何らかの類のC関数を定義する必要"
"があります。それから`rb_funcallv()`の異なる派生形で、ブロック用に2つ引数が追"
"加されたものがあります。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:291
msgid "{% highlight c %} {% include c/block.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/block.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:297
msgid ""
"The last argument to `rb_block_call()` is helpful for passing in values "
"outside the block function's scope, but in this example we don't need it "
"(thus `nil`). I also recommend against using the first argument to your "
"block function unless you're **sure** that only one value was yielded. You "
"can always get all the arguments from `argv`, so why not play it safe?"
"[^break]"
msgstr ""
"`rb_block_call()`への最後の引数はブロック関数のスコープの外側にある値を渡すの"
"に便利ですが、この例ではその必要はありません（なので`nil`にしています）。\n"
"また、1つの値だけがyieldされることを**確信**していない限り、最初の引数を使う"
"ことはお勧めしません。\n"
"いつでも全ての引数を`argv`から手に入れられるので、危うきに近寄らずともいい"
"じゃないですか[^break]。"

#. type: Title ##
#: ../_posts/2010-01-01-c.markdown:298
#, no-wrap
msgid "Builtins"
msgstr "組み込みの機能"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:305
msgid ""
"Many of Ruby's built-in classes have API functions defined for their most "
"useful methods. Using them can save you from the verbosity of always using "
"`rb_funcall()` and can provide more compile-time checks. There are far too "
"many functions to list here, so I recommend checking them out in the header "
"`ruby/intern.h`."
msgstr ""
"多くのRubyの組み込みクラスには、その中でも飛びっきり便利なメソッド用に定義さ"
"れたAPI関数があります。\n"
"それらを使えば、`rb_funcall()`を使ってばかりで冗長になるのを避けられたり、よ"
"り良いコンパイル時の検証がもたらされるかもしれません。\n"
"関数があまりにも多すぎて一覧にするにはここは狭すぎるので、ヘッダファイル"
"`ruby/intern.h`を眺めることを推奨します。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:309
msgid ""
"Functions are generally named like `rb_(class)_(method)` and take at least "
"one `VALUE` argument (the receiver). E.g. `rb_ary_pop()` for `Array#pop`, "
"`rb_obj_dup()` for `Object#dup`, etc."
msgstr ""
"関数はおおよそ`rb_（クラス）_（メソッド）`のように命名されていて少なくとも1つ"
"の`VALUE`引数（レシーバ）を取ります。\n"
"例えば`rb_ary_pop()`は`Array#pop`用ですし、`rb_obj_dup()`は`Object#dup`用、と"
"いった具合です。"

#. type: Title ##
#: ../_posts/2010-01-01-c.markdown:310
#, no-wrap
msgid "Require"
msgstr "require"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:314
msgid ""
"The API can also load some Ruby code from a script. There's an equivalent to "
"`require`:"
msgstr ""
"APIには何らかのRubyコードをスクリプトから読み込むための、`require`と等価なも"
"のがあります。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:318
msgid "{% highlight c %} {% include c/require.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/require.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:321
msgid ""
"As with `require`, these could raise exceptions. Read the [next section]"
"(#exceptions) for how to handle them."
msgstr ""
"`require`するときは例外が発生し得ます。\n"
"対処方法については[次節](#exceptions)を読んでください。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:323
msgid ""
"There are also functions for `load` if you want to load a script multiple "
"times:"
msgstr "スクリプトを複数回読み込みたければ、`load`用の関数もあります。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:327
msgid "{% highlight c %} {% include c/load.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/load.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:331
msgid ""
"Just like [`load` in Ruby][rbload], these functions can wrap the loaded code "
"in an anonymous module to protect the global namespace. Just pass a nonzero "
"value for the second argument."
msgstr ""
"ちょうど[Rubyの`load`][rbload]と同じように、こうした関数は読み込まれたコード"
"を匿名のモジュールに包んで大域名前空間を保護するのに使えます。単に非ゼロの値"
"を2つ目の引数に渡せばよいのです。"

#. type: Link reference
#: ../_posts/2010-01-01-c.markdown:332
#, no-wrap
msgid "[rbload]: http://www.ruby-doc.org/core/Kernel.html#method-i-load"
msgstr "[rbload]: http://www.ruby-doc.org/core/Kernel.html#method-i-load"

#. type: Title ##
#: ../_posts/2010-01-01-c.markdown:334
#, no-wrap
msgid "Exceptions"
msgstr "例外"

#. type: Title ###
#: ../_posts/2010-01-01-c.markdown:336
#, no-wrap
msgid "Raise"
msgstr "raise"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:339
msgid "To raise an exception, use:"
msgstr "例外を投げるには以下を使ってください。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:343
msgid "{% highlight c %} {% include c/raise.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/raise.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:348
msgid ""
"The first and second arguments are the exception class and message—like "
"`raise` in Ruby. The big difference is that the message is a format string "
"[just like in `rb_sprintf()`](#string), letting you more easily build a "
"useful message."
msgstr ""
"1つ目と2つ目の引数は例外クラスと文言で、Rubyの`raise`のような感じです。\n"
"大きな違いは、文言が（[ちょうど`rb_sprintf()`のような](#string)）書式文字列で"
"ある点で、有用な文言をより簡単に構築できます。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:355
msgid ""
"You can also construct exception objects directly using `rb_exc_new_cstr`, "
"`rb_exc_new`, and `rb_exc_new_str`. All of these accept an exception class "
"as their first argument and then they work just like their [string]"
"(#string)  counterparts, constructing an exception using a null-terminated "
"string, non-null-terminated string, and a `String` object, resp. Then you "
"can raise your exception object with `rb_exc_raise`."
msgstr ""
"また`rb_exc_new_cstr`、`rb_exc_new`、`rb_exc_new_str`を直接使って例外オブジェ"
"クトを構築することもできます。これら全ては例外クラスを1つ目の引数に受け取り、"
"そうしてそれぞれの関数に対応する[文字列](#string)に対してはたらきます。すなわ"
"ち例外はそれぞれnull終端文字列、非null終端文字列、`String`オブジェクトを使っ"
"て構築されます。それから`rb_exc_raise`で例外オブジェクトを投げられます。"

#. type: Title ###
#: ../_posts/2010-01-01-c.markdown:356
#, no-wrap
msgid "Rescue"
msgstr "rescue"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:361
msgid ""
"There are several ways to rescue exceptions using the API. All of them "
"require the code you're protecting to be in a function that takes and "
"returns a single `VALUE`."
msgstr ""
"APIを使って例外を捕捉するにはいくつか方法があります。\n"
"全ての方法で保護対象のコードは単一の`VALUE`を取って返す関数の中にある必要があ"
"ります。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:365
msgid "{% highlight c %} {% include c/danger.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/danger.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:369
msgid ""
"Unless you wanted to rescue a function of exactly this type, you will "
"probably need to make a wrapper function in this format that runs the "
"desired code. The way to access a rescued exception is also independent of "
"the way it is rescued:"
msgstr ""
"厳密にこの型の関数を救出したいのでない限り、恐らくこの形式で所望のコードを走"
"らせる梱包関数を作る必要があるでしょう。救出された例外にアクセスする方法もま"
"た、救出される方法とは独立です。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:373
msgid "{% highlight c %} {% include c/handle.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/handle.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:378
msgid ""
"`rb_errinfo()` essentially gives you the `VALUE` of Ruby's `$!` (which will "
"be `Qnil` if no exception occurred). Unlike in Ruby, you must manually clear "
"the exception after reading it[^clear]. Otherwise later API calls might read "
"the old value and think another exception has occurred."
msgstr ""
"`rb_errinfo()`により、欠かせないRubyの`$!`（1つも例外が起こらなければ`Qnil`に"
"なります）の`VALUE`が与えられます。Rubyとは異なり読んだ後で例外を手動で消し去"
"らなければなりません[^clear]。さもなくばその後のAPI呼び出しが古い値を読んで別"
"の例外が起こったと考えるかもしれません。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:382
msgid ""
"Next we will go over several methods of rescuing; you can use whichever you "
"like, but I think that generally the right choice is determined by your [use-"
"case](#the-two-paths) of the API."
msgstr ""
"次に救出するための方法をいくつか眺めていきます。どれでも好きなものを使ってよ"
"いですが、一般に正しい選択はAPIの[用途](#the-two-paths)により決まると考えてい"
"ます。"

#. type: Title ####
#: ../_posts/2010-01-01-c.markdown:383
#, no-wrap
msgid "rb_rescue2"
msgstr "rb_rescue2"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:389
msgid ""
"If you're compiling a library to be loaded by Ruby, you have it easy. Any "
"exceptions raised in the API can be rescued as usual in your Ruby code. If "
"you want to rescue an exception in the API, you can use `rb_rescue2()` which "
"is similar to Ruby's `rescue`."
msgstr ""
"Rubyによって読み込まれるライブラリをコンパイルしている場合、話は簡単です。\n"
"APIで投げられるいかなる例外もいつも通りRubyのコードで救出できます。\n"
"APIで例外を救出したければRubyの`rescue`と似ている`rb_rescue2()`を使うことがで"
"きます。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:393
msgid "{% highlight c %} {% include c/rescue2.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/rescue2.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:402
msgid ""
"The first two arguments are the function to protect and its argument, the "
"next two are the function to call if an exception is raised and its "
"argument.  `rb_rescue2()` is a varargs function, so after that comes a list "
"of the exception classes you want to rescue. The last argument should always "
"be `0` to indicate the end of the class list. Like `rescue` in Ruby, any "
"exceptions not in this list will not be rescued. If you just want to rescue "
"`StandardError` (like a blank `rescue` in Ruby), you can use `rb_rescue()` "
"which takes just the first four arguments of `rb_rescue2()`."
msgstr ""
"始めから2つの引数は保護する関数とその引数です。その次の2つは例外が投げられた"
"場合に呼ばれる関数とその引数です。`rb_rescue2()`はvarargs関数なのでその後には"
"救出したい例外クラスのリストが来ます。最後の引数は常に`0`で、クラスのリストの"
"末尾を示します。Rubyの`rescue`のように、このリストにない例外は何も救出されま"
"せん。もし（Rubyでの空の`rescue`のように）`StandardError`を救出したいだけな"
"ら、`rb_rescue2()`の最初の4つの引数だけを取る`rb_rescue()`を使うことができま"
"す。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:406
msgid ""
"The API does not provide an easy way to run different rescue code for "
"different exception classes as Ruby does. You'll need to rescue all the "
"classes you want at once and use some kind of switch to handle them "
"separately."
msgstr ""
"Rubyとは違い、APIではそれぞれの例外クラス用に救出コードを走らせる簡単な方法を"
"提供していません。一旦欲しい全てのクラスを救出して、switchの類を使って個別に"
"取り扱う必要があります。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:413
msgid ""
"The API also does not directly provide an equivalent to Ruby's `else` i.e. "
"code to run when _no_ exception was raised. One way to do this is using the "
"return value of `rb_rescue2()`. If no exception is raised, it returns the "
"return value of the first (dangerous) function, otherwise the return value "
"of the second (rescue) function. By having these return, say, `Qtrue` and "
"`Qfalse` you can detect which case you are in."
msgstr ""
"またAPIはRubyの`else`と等価なもの、つまり _何ら_ 例外が投げられなかったときに"
"走るコード、を直接は提供していません。このための1つの方法は`rb_rescue2()`の返"
"り値を使うことです。もし1つも例外が投げられなければ最初の（危険な）関数の返り"
"値を、さもなくば2つ目の（救出）関数の返り値を返します。これらが返すもの、ここ"
"では`Qtrue`と`Qfalse`としましょう、を受け取ることによって、どちらの場合になっ"
"ているのかを検出できます。"

#. type: Title ####
#: ../_posts/2010-01-01-c.markdown:414
#, no-wrap
msgid "rb_protect"
msgstr "rb_protect"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:421
msgid ""
"If you're embedding the Ruby interpreter in C, you need to be _extremely "
"careful_ when calling API functions that could raise exceptions: **an "
"uncaught exception will segfault the VM and kill your program**. You could "
"call `rb_rescue2()` with `rb_eException`, but there's another approach for "
"rescuing all exceptions:"
msgstr ""
"RubyインタプリタをCに埋め込みたい場合、例外を投げ得るAPI関数を呼ぶときは _極"
"めて慎重_ にならねばなりません。\n"
"**捕捉されない例外はVMをセグフォルトさせてプログラムをキルする**のです。\n"
"`rb_eException`と共に`rb_rescue2()`を呼ぶようにできますが、全ての例外を救出す"
"る別の手法があります。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:425
msgid "{% highlight c %} {% include c/protect.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/protect.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:431
msgid ""
"Like `rb_rescue2()`, the first two arguments are for calling the function to "
"protect. However, like `rb_eval_string_protect()`, if an exception is raised "
"it returns `Qnil` and sets `state` to some nonzero value. If you want to re-"
"raise the exception, pass `state` to `rb_jump_tag()` (this also works for "
"the state from the other `*_protect()` functions)."
msgstr ""
"`rb_rescue2()`と同様、最初2つの引数は保護する関数を呼び出すためのものです。し"
"かし、`rb_eval_string_protect()`のように、例外が投げられれば`Qnil`を返し"
"`state`を非ゼロの値に設定します。例外を再度投げたければ`state`を"
"`rb_jump_tag()`に渡してください（これは他の`*_protect()`関数からの状態につい"
"ても同じことが言えます）。"

#. type: Title ###
#: ../_posts/2010-01-01-c.markdown:432
#, no-wrap
msgid "Ensure"
msgstr "ensure"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:439
msgid ""
"`rb_ensure()` is similar to `rb_rescue()` except that it doesn't do anything "
"about exceptions and the second function is _always_ called after the "
"first.  That may sound simple enough, but that means that if you want the "
"usual `begin; rescue; ensure; end` structure as in Ruby, you'll need another "
"layer of wrapping:"
msgstr ""
"`rb_ensure()`は`rb_rescue()`に似ていますが、例外を関知しないことと2つ目の関数"
"が _常に_ 1つ目のものの後に呼ばれる点で異なります。充分に単純に思われるかもし"
"れませんが、これが意味しているのは、もしRubyでするような通常の`begin; "
"rescue; end`の構造が欲しければ、梱包に別の層が必要になってくるということで"
"す。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:443
msgid "{% highlight c %} {% include c/ensure.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/ensure.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:448
msgid ""
"Like `ensure` in Ruby, the return value of `ensure_func()` is never used. If "
"no exception occurs, `rb_rescue()` will return the value of `begin_func()` "
"which returns the value of `dangerous_func()`. If an exception does occur, "
"`rb_rescue()` returns the value of `rescue_func()`."
msgstr ""
"Rubyでの`ensure`のように、`ensure_func()`の返り値は決して使われません。何も例"
"外が起きなければ`rb_rescue()`は`begin_func()`の値を返します。ここで、"
"`begin_func()`は`dangerous_func()`の値を返します。もし例外が発生したら"
"`rb_rescue()`は`rescue_func()`の値を返します。"

#. type: Title ##
#: ../_posts/2010-01-01-c.markdown:449
#, no-wrap
msgid "Definitions, Declarations"
msgstr "定義、宣言"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:454
msgid ""
"So far we've been creating and modifying objects directly in the VM's "
"memory, but none of our API calls have had a visible effect _within the Ruby "
"code_: a `String` made with `rb_str_new_cstr()` can only be accessed from C "
"by default."
msgstr ""
"ここまでVMのメモリ内で直接オブジェクトを作ったり変更したりしてきましたが、ど"
"のAPI呼び出しも _Rubyのコードの内部_ での目に見える効果はありませんでした。\n"
"`rb_str_new_cstr()`で作られた`String`は、既定ではCからのみアクセスできます。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:463
msgid ""
"There are a few ways to make things visible to Ruby but they all work the "
"same general way: by defining some name that Ruby can access e.g. a variable "
"name, a method name, etc. A general warning though: unlike Ruby, **the API "
"lets you give things invalid names**. Ruby will raise a `SyntaxError` or "
"`NameError` if you try to name a class `foo` (not constant) or an instance "
"variable `bar` (no `@`), but the API will happily create them. The API "
"handles this by **not exposing invalid names to Ruby**. Since that's "
"probably not what you want, double check the names you choose!"
msgstr ""
"Rubyから見えるようにするにはいくつかの方法がありますが、全て同じ汎用的な仕組"
"みではたらきます。その共通するところはRubyがアクセスできる何らかの名前を定義"
"するという点です。例えば変数名やメソッド名などです。しかし注意を呼び掛けてお"
"きましょう。Rubyとは違い、**APIでは不正な名前を与えることができます**。クラス"
"に`foo`（定数でない）やインスタンス変数に`bar`（`@`がない）を名付けようとする"
"とRubyは`SyntaxError`や`NameError`を投げるでしょうが、APIは嬉々としてそうした"
"名前で作り、**不正な名前をRubyにさらけ出さない** ようにして対処します。そうし"
"たいわけではないでしょうから、選ぶ名前はダブルチェックしてくださいね。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:469
msgid ""
"Most of the API functions in this section correspond closely to "
"metaprogramming methods in Ruby. When you're trying to do something using "
"the API, it can be helpful to think about how you would do it in Ruby using "
"only metaprogramming method calls. For example, rather than `class Foo; def "
"bar; end; end`, think `Foo = Class.new; Foo.define_method(:bar) {}`."
msgstr ""
"この節のほとんどのAPI関数はRubyのメタプログラミングに近いです。APIを使って何"
"かしようとするときは、Rubyでメタプログラミングのメソッド呼び出しだけを使って"
"するとしたらどうするだろうと考えると役立つことがあります。例えば`class Foo; "
"def bar; end`とするのではなく、`Foo = Class.new; Foo.define_method(:bar) {}`"
"と考えるのです。"

#. type: Title ###
#: ../_posts/2010-01-01-c.markdown:470
#, no-wrap
msgid "Global Variables"
msgstr "大域変数"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:473
msgid "The simplest way to deal with globals is:"
msgstr "大域変数を扱う一番簡単な方法は以下です。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:477
msgid "{% highlight c %} {% include c/global.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/global.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:480
msgid ""
"If you're frequently accessing Ruby's globals, you can set up a `VALUE` "
"which will be automatically synchronized with one."
msgstr ""
"Rubyの大域変数に頻繁にアクセスするときは`VALUE`を準備しておけば自動的に同期が"
"取られます。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:484
msgid "{% highlight c %} {% include c/global2.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/global2.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:491
msgid ""
"The `VALUE` should be initialized before you create the global in Ruby and "
"it should be global in C as well—you don't want it to go out of scope while "
"Ruby is using it! For `rb_define_hooked_variable()`, you can pass `NULL` for "
"the getter/setter if you want to synchronize normally for that operation. Or "
"you can throw out `global` entirely with `rb_define_virtual_variable()` "
"though of course the getter and setter _must_ be defined in that case."
msgstr ""
"`VALUE`はRubyで大域変数を作る前に初期化するべきで、そうしておけばCでも大域変"
"数になります。\n"
"Rubyが使っている間はスコープを外れてほしくはないですからね。\n"
"`rb_define_hooked_variable()`にすると、そうした操作で通常の同期をしたい場合に"
"ゲッターやセッターに`NULL`を渡すことができます。\n"
"もしくは`rb_define_virtual_variable()`で完全に`global`を投げ出すこともできま"
"すが、もちろんゲッターとセッターはそうした場合で定義されている*必要*がありま"
"す。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:495
msgid ""
"If you ever create a global `VALUE` in C which is _not_ exposed to Ruby, you "
"must tell the garbage collector about it to prevent it from being "
"prematurely cleaned up:"
msgstr ""
"Rubyに露出 _しない_ 大域変数`VALUE`をCで作った場合、中途半端に掃除されてしま"
"うのを防ぐためにガベージコレクタにそのことを伝えなければなりません。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:499
msgid "{% highlight c %} {% include c/gc.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/gc.h %}\n"
"{% endhighlight %}"

#. type: Title ###
#: ../_posts/2010-01-01-c.markdown:500
#, no-wrap
msgid "Class and Instance Variables"
msgstr "クラスとインスタンス変数"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:504
msgid ""
"Getting/setting instance variables is similar to the simple way of accessing "
"globals, but of course you need an object to get the variable from."
msgstr ""
"インスタンス変数の取得と設定は大域変数にアクセスする単純な方法と似ています"
"が、もちろん変数を取得してくるオブジェクトが必要です。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:508
msgid "{% highlight c %} {% include c/ivar.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/ivar.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:511
msgid ""
"There isn't an automatic way to synchronize instance variables like you can "
"with globals."
msgstr ""
"大域変数もそうでしたがインスタンス変数を同期する自動化された方法はありませ"
"ん。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:513
msgid "To iterate over all instance variables, use `rb_ivar_foreach`."
msgstr ""
"全てのインスタンス変数を巡回するには`rb_ivar_foreach`を使ってください。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:516
msgid ""
"For class variables, the methods are `rb_cv_get()` and `rb_cv_set()` and of "
"course the first argument should be a class object."
msgstr ""
"クラス変数については、メソッドは`rb_cv_get()`と`rb_cv_set()`があり、もちろん"
"最初の引数はクラスオブジェクトです。"

#. type: Title ###
#: ../_posts/2010-01-01-c.markdown:517
#, no-wrap
msgid "Constants ####"
msgstr "定数"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:520
msgid ""
"Constants are defined similarly, but with the module to define them under:"
msgstr ""
"定数は似たように定義されていますが、それらを配下に置くためのモジュールを伴い"
"ます。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:524
msgid "{% highlight c %} {% include c/constant.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/constant.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:528
msgid ""
"You undefine a constant by setting it to `Qundef`. Getting a constant's "
"`VALUE` is a little nuanced. The API function you call depends on what you "
"want to happen if the constant is _not_ defined in the module you specify:"
msgstr ""
"`Qundef`を設定すると定数は未定義にされます。定数の`VALUE`の取得に関しては少し"
"ずつ違います。定数が指定されたモジュールで定義されて _いない_ ときに何が起"
"こってほしいのかに依って呼び出すべきAPI関数が決まります。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:532
msgid "{% highlight c %} {% include c/const_get.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/const_get.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:534
msgid "All of these API calls will get private constants too."
msgstr "これら全てのAPIはプライベート定数も取得します。"

#. type: Title ###
#: ../_posts/2010-01-01-c.markdown:535
#, no-wrap
msgid "Modules and Classes"
msgstr "モジュールとクラス"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:538
msgid "Defining modules is super easy."
msgstr "モジュールの定義は超簡単です。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:542
msgid "{% highlight c %} {% include c/module.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/module.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:544
msgid "Classes work the same way but they also need a superclass."
msgstr "クラスも同じやり方ですが、こちらはスーパークラスも必要になります。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:548
msgid "{% highlight c %} {% include c/class.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/class.h %}\n"
"{% endhighlight %}"

#. type: Title ###
#: ../_posts/2010-01-01-c.markdown:549
#, no-wrap
msgid "Methods"
msgstr "メソッド"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:555
msgid ""
"Here's where it gets interesting. There are many kinds of API calls for "
"defining methods, but before you use any of them you'll need a C function "
"that the method calls. The function must return a `VALUE` and have one "
"`VALUE` argument for the receiver of the method. There are three ways you "
"can define its other arguments:"
msgstr ""
"ここから面白くなってきます。メソッド定義のためのAPI呼び出しには多くの種類があ"
"りますが、どれかを使う前にそのメソッドを呼び出すC関数が必要です。その関数は"
"`VALUE`を返しメソッドのレシーバ用の`VALUE`引数を1つ持たねばなりません。他の引"
"数を定義するのには3つの方法があります。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:559
msgid "{% highlight c %} {% include c/methodc.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/methodc.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:564
msgid ""
"So really the API only lets you define two types of methods: ones that take "
"a fixed number of arguments, and ones that slurp up all of their arguments. "
"What about all of Ruby's fancy argument features? Where are optional "
"arguments, options hashes, blocks, and all the mixtures of those?"
msgstr ""
"なので本当のところAPIでは2つの種類のメソッドのみが定義できるのです。且つは固"
"定数の引数を取り、且つは全ての引数を一飲みします。Rubyの素敵な引数の機能はど"
"うなったのでしょうか。オプション引数、オプションハッシュ、ブロック、これらの"
"混在はどこにあるのでしょうか。"

#. type: Title ####
#: ../_posts/2010-01-01-c.markdown:565
#, no-wrap
msgid "Parsing Arguments"
msgstr "引数を解析する"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:572
msgid ""
"Well, if you accept a variable number of arguments you could code all of "
"that logic yourself in the method, and make it _behave_ like it has a "
"fancier method definition in Ruby. Thankfully, the API has a shortcut for "
"doing exactly that.  To use it, you should use the C array function "
"definition, then you can pass `argc` and `argv` along to:"
msgstr ""
"さて、様々な個数の引数を受け付けられたら、メソッド内で自力で全ての仕組みを"
"コードに書くことができ、あたかもRubyで凝ったメソッドを定義したように _振る舞"
"わ_ せられます。ありがたいことにAPIにはちょうどそういうことをするための早道が"
"あります。それにはC配列関数の定義を使うとよく、それから`argc`と`argv`を以下の"
"流れに沿って渡すことができます。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:576
msgid "{% highlight c %} {% include c/scan.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/scan.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:581
msgid ""
"Here `fmt` is a format string describing how the method arguments would look "
"in Ruby. The string can have at most 6 characters, where each character "
"describes a different section of the arguments. The six sections and their "
"corresponding characters are (in order):"
msgstr ""
"ここで`fmt`はメソッド引数がRubyでどのような見た目をしているのかを記述する書式"
"文字列です。文字列は最大6個の文字を持つことができ、そこではそれぞれの文字はそ"
"れぞれ異なる節の引数を記述するのです。6つの節と（順番通りに）対応する文字は以"
"下の通りです。"

#. type: Bullet: '1. '
#: ../_posts/2010-01-01-c.markdown:588
msgid "The number of leading mandatory arguments: a digit"
msgstr "先頭にある必須引数の数：数字"

#. type: Bullet: '2. '
#: ../_posts/2010-01-01-c.markdown:588
msgid "The number of optional arguments: a digit"
msgstr "オプション引数の数：数字"

#. type: Bullet: '3. '
#: ../_posts/2010-01-01-c.markdown:588
msgid "A splatted argument: `*`"
msgstr "展開される引数：`*`"

#. type: Bullet: '4. '
#: ../_posts/2010-01-01-c.markdown:588
msgid "The number of trailing mandatory arguments: a digit"
msgstr "後ろに続く必須引数の数：数字"

#. type: Bullet: '5. '
#: ../_posts/2010-01-01-c.markdown:588
msgid "Keyword arguments: `:`"
msgstr "キーワード引数：`:`"

#. type: Bullet: '6. '
#: ../_posts/2010-01-01-c.markdown:588
msgid "A block argument: `&`"
msgstr "ブロック引数：`&`"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:598
msgid ""
"Each section is optional, so you can leave out the characters for things you "
"don't need. Be aware that the parsing of the format string is greedy: `1*` "
"describes a method with one mandatory argument and a splat. If you want one "
"_optional_ argument and a splat you must specify `01*`. Following the format "
"string, you must pass a `VALUE*` for each _Ruby_ argument. The number of "
"pointers passed should equal the \"total\" of the six sections, though you "
"can pass `NULL` for an argument you don't care about. For example the format "
"string `21*&` should have 5 `VALUE*`s passed (2 mandatory, 1 optional, 1 "
"splatted, 1 block)."
msgstr ""
"それぞれの節は省略できるので、必要ではないものについてはそのための文字を空け"
"たままにできます。書式文字列の解析は貪欲に行われる点に注意してください。`1*`"
"は必須引数と展開を持つメソッドを示しています。1つの _オプション_ 引数と展開で"
"あってほしければ`01*`と指定せねばなりません。書式文字列にしたがってそれぞれ"
"の _Ruby_ の引数用に`VALUE*`を渡さなければなりません。渡されるポインタの数は6"
"つの節の「合計」に等しいのですが、関心のない引数については`NULL`を渡すことが"
"できます。例えば書式文字列`21*&`には5つの`VALUE*`が渡されなければなりません"
"（2つの必須引数、1つのオプション引数、1つの展開、1つのブロックです）。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:601
msgid ""
"`rb_scan_args()` unpacks `argv` using the `VALUE*`s you pass it and will "
"raise a fitting exception if the wrong number of arguments were passed."
msgstr ""
"`rb_scan_args()`は渡した`VALUE*`を使って`argv`を開封し、もし誤った数の引数が"
"渡されたときは符牒が合わない旨の例外を投げます。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:605
msgid "{% highlight c %} {% include c/methodex.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/methodex.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:609
msgid ""
"You can also use the return value of `rb_scan_args()` to determine how the "
"function was called. It returns the number of arguments that were passed in "
"Ruby."
msgstr ""
"`rb_scan_args()`の返り値を使って、関数がどう呼ばれたのかを確定することもでき"
"ます。そうすることでRubyで渡された引数の数が返ります。"

#. type: Title ####
#: ../_posts/2010-01-01-c.markdown:610
#, no-wrap
msgid "Handling Blocks"
msgstr "ブロックの扱い"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:613
msgid ""
"There are two ways to check if your C method has been called with a block:"
msgstr ""
"Cのメソッドがブロック付きで呼ばれたかどうかを確認する方法は2つあります。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:617
msgid "{% highlight c %} {% include c/checkblock.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/checkblock.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:622
msgid ""
"There are two ways to capture the block as a proc. If you're using "
"`rb_scan_args()` for your method arguments, just include `&` in your format "
"string to get it. If you aren't using `rb_scan_args()`, there's an API call "
"equivalent to `Proc.new` which converts the method's block to a proc:"
msgstr ""
"Procとしてブロックを捕捉する方法は2つあります。メソッド引数に`rb_scan_args()`"
"を使っている場合、書式文字列に`&`を含めるだけで取得できます。`rb_scan_args()`"
"を使っていなければメソッドのブロックをProcに変換する`Proc.new`と等価なAPI呼び"
"出しがあります。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:625
#, no-wrap
msgid ""
"    VALUE block;\n"
"    block = rb_block_proc();\n"
msgstr ""
"    VALUE block;\n"
"    block = rb_block_proc();\n"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:627
msgid ""
"If you don't want to capture the block, there are a few ways to yield to it:"
msgstr "ブロックを捉えたくなければ、yieldする方法が2つあります。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:631
msgid "{% highlight c %} {% include c/yield.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/yield.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:634
msgid ""
"There's also `rb_yield_values2()` which is like `rb_yield_values()` but "
"instead of varargs the second argument is a `VALUE*`[^yield]."
msgstr ""
"`rb_yield_values()`に似た`rb_yield_values2()`もあり、`varargs`の代わりに2つ目"
"の引数が`VALUE*`になっています[^yield]。"

#. type: Title ####
#: ../_posts/2010-01-01-c.markdown:635
#, no-wrap
msgid "Super"
msgstr "super"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:638
msgid "You might want to call `super` in your method."
msgstr "メソッドで`super`を呼びたいことがあるかもしれません。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:642
msgid "{% highlight c %} {% include c/super.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/super.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:648
msgid ""
"Unlike in Ruby `rb_call_super()` will **not** implicitly pass along the "
"method arguments to the super if you give it no arguments. You must "
"explicitly pass the correct `argc` and `argv` (it _does_ automatically pass "
"`self`). For that reason I recommend using the C array style of method "
"definition if you want to use `rb_call_super()`."
msgstr ""
"Rubyとは異なり、引数を1つも与えなければ`rb_call_super()`はメソッドの引数を"
"superに暗黙に渡すことは**ありません**。明示的に正しい`argc`及び`argv`を渡さな"
"ければならないのです（`self`を自動的に渡し*ます*）。そういった理由から"
"`rb_call_super()`を使いたければCの配列スタイルのメソッド定義を使うことをお勧"
"めします。"

#. type: Title ####
#: ../_posts/2010-01-01-c.markdown:649
#, no-wrap
msgid "Definition"
msgstr "定義"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:655
msgid ""
"Setting up the C function is the hard part, now it's easy to define the "
"method in Ruby. Every API call to create a method takes at least the method "
"name (`char*`), a pointer to your C function, and an `argc` describing its "
"arguments.  `argc` should be:"
msgstr ""
"Cの関数を用意するのは大変ですが、Ruby用にメソッドを定義するのは簡単です。メ"
"ソッドをつくるAPI呼び出しは全て最低でもメソッド名 (`char*`)、Cの関数へのポイ"
"ンタ、引数を表す`argc`を取ります。`argc`は以下のようなものです。"

#. type: Bullet: '1. '
#: ../_posts/2010-01-01-c.markdown:660
msgid ""
"For a fixed number of arguments, the number of arguments (not counting the "
"receiver)"
msgstr "引数が一定数のときは、その引数の数（レシーバは数えません）"

#. type: Bullet: '2. '
#: ../_posts/2010-01-01-c.markdown:660
msgid "For a variable number of arguments in a C array, `-1`"
msgstr "Cの配列中の引数の数が可変なときは、`-1`"

#. type: Bullet: '3. '
#: ../_posts/2010-01-01-c.markdown:660
msgid "For a variable number of arguments in a Ruby Array, `-2`"
msgstr "Rubyの配列中の引数の数が可変なときは、`-2`"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:662
msgid "Everything is pretty self-explanatory from there:"
msgstr "これ以降の全てはかなりそれ自体が分かりやすいものです。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:666
msgid "{% highlight c %} {% include c/methodr.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/methodr.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:670
msgid ""
"There's also a shortcut for defining a method in a module _and_ its "
"singleton class. This is used a lot in `Math`, for example, letting you "
"`include Math` to avoid typing `Math.` before every method call."
msgstr ""
"モジュール _と_ そのシングルトンクラス中でメソッドを定義する早道もあります。"
"例えば`Math`で多用されており、例として`include Math`とすることで一々メソッド"
"呼び出しで`Math.`と打つのを避けられます。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:674
msgid "{% highlight c %} {% include c/modulefunc.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/modulefunc.h %}\n"
"{% endhighlight %}"

#. type: Title ###
#: ../_posts/2010-01-01-c.markdown:675
#, no-wrap
msgid "Other Stuff"
msgstr "その他のもの"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:678
msgid "Some simple API functions for class/method definitions:"
msgstr "クラスやメソッドの定義のための単純なAPI関数があります。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:682
msgid "{% highlight c %} {% include c/etc.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/etc.h %}\n"
"{% endhighlight %}"

#. type: Title ##
#: ../_posts/2010-01-01-c.markdown:683
#, no-wrap
msgid "Data"
msgstr "データ"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:690
msgid ""
"By now you should be able to create and manipulate Ruby classes using the "
"API, but how can you create a Ruby class that encapsulates data from the C "
"world? If your data can be naturally translated into `VALUE`s it's easy: "
"convert and assign to instance variables as usual. But what if your data "
"have no Ruby analog (e.g. data structures defined by some C library)?"
msgstr ""
"今となってはAPIを使ってRubyのクラスを作ったり操作したりできるでしょう。しかし"
"Cの世界でデータをカプセル化するRubyのクラスを作るにはどうすればよいのでしょう"
"か。データが自然に`VALUE`に翻訳できるのであれば簡単です。いつも通り変換してイ"
"ンスタンス変数に代入すればよいです。でもデータに、Rubyでいうところのこれ、と"
"いったものがないとしたらどうでしょうか（例：何らかのCのライブラリで定義された"
"データ構造）。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:697
msgid ""
"The API lets you encapsulate C data by creating a `VALUE` of the desired "
"class and then storing a `void*` pointing to the C data inside the Ruby "
"object. Then whenever you need access to the C data, you can unpack the "
"pointer and cast it back to the correct type. But where does this "
"encapsulation occur? Let's answer that question with a question: what "
"happens when you tell Ruby to create an object using `new`? Basically this:"
msgstr ""
"APIを使うと、所望の`VALUE`を作り、Rubyのオブジェクトの中にCのデータを指す"
"`void*`を格納することで、Cのデータをカプセル化できます。そうしてCのデータにア"
"クセスする必要が生じたら、ポインタを開封して正しい型に変換し戻せばよいので"
"す。しかしどの時点でこのカプセル化は起こるのでしょうか。その質問へは次の質問"
"でもって答えましょう。`new`を使ってオブジェクトを作るようRubyに伝えたとき何が"
"起こるでしょうか。基本的にはこうです。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:701
msgid "{% highlight ruby %} {% include c/new.rb %} {% endhighlight %}"
msgstr ""
"{% highlight ruby %}\n"
"{% include c/new.rb %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:707
msgid ""
"Before calling the _instance method_ `initialize` that we know so well, "
"`new` first calls the _class method_ `allocate` to actually create the "
"object. That is the method you'll need to define if you want your objects to "
"wrap C data. The following example creates a class `Foo` which wraps an "
"`int` that can be set by `initialize`:"
msgstr ""
"私達がよく知っている _インスタンスメソッド_ `initialize`を呼ぶ前に、`new`は最"
"初に _クラスメソッド_ `allocate`を呼んで実際にオブジェクトを作るのです。これ"
"こそが、Cのデータを包み込むオブジェクトが欲しい場合に定義する必要のあるメソッ"
"ドです。以下の例は`initialize`によって設定できる`int`を包むクラス`Foo`を作っ"
"ています。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:711
msgid "{% highlight c %} {% include c/wrap.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/wrap.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:719
msgid ""
"In most cases you'll probably be wrapping something more complicated (like a "
"`struct`), but the principles will be the same. After allocating the C data, "
"we use the `TypedData_Wrap_Struct()`[^oldwrap] macro to wrap the pointer in "
"a `VALUE`. This wrapping takes three arguments: the class of the object "
"(`self` because we're in a class method), a pointer to a struct, and the "
"data pointer to be wrapped. The tricky part is the struct pointer; it "
"provides additional information for internal use by Ruby:"
msgstr ""
"ほとんどの場合（`struct`のような）もっと複雑なものを包むことになりそうです"
"が、基本は変わりません。Cのデータをアロケートした後は、"
"`TypedData_Wrap_Struct()`[^oldwrap]マクロを使って`VALUE`中のポインタを包みま"
"す。この梱包には3引数要ります。オブジェクトのクラス（クラスメソッドにいるので"
"`self`です）、構造体へのポインタ、そして梱包されるデータのポインタです。引っ"
"掛かりやすいところは構造体ポインタにあります。このポインタはRubyが内部的に使"
"う追加情報を提供するものです。"

#. type: Bullet: '* '
#: ../_posts/2010-01-01-c.markdown:736
msgid ""
"`wrap_struct_name` is a string used by Ruby to identify your type. It "
"doesn't really matter what it is as long as it's sensible and unique"
msgstr ""
"`wrap_struct_name`はRubyによって使われる文字列で、型を識別するために使われま"
"す。意味が通っていて一意である限り本当に何でも構いません"

#. type: Bullet: '* '
#: ../_posts/2010-01-01-c.markdown:736
msgid ""
"`function` is a struct containing several function pointers for use by the "
"garbage collector"
msgstr ""
"`function`はガベージコレクタによって使われるいくつかの関数ポインタを含む構造"
"体です"

#. type: Bullet: '* '
#: ../_posts/2010-01-01-c.markdown:736
msgid ""
"`dmark` will be described later, but as long your C data doesn't point to "
"any Ruby objects you don't need it"
msgstr ""
"`dmark`については後述しますが、CのデータがRubyのオブジェクトを指さない限り不"
"要です"

#. type: Bullet: '* '
#: ../_posts/2010-01-01-c.markdown:736
msgid ""
"`dfree` will be called when your object is destroyed and should free all "
"memory allocated by the object"
msgstr ""
"`dfree`が呼ばれるのは、オブジェクトが破棄されオブジェクトによってアロケートさ"
"れた全てのメモリが解放されるときです"

#. type: Bullet: '* '
#: ../_posts/2010-01-01-c.markdown:736
msgid ""
"`dsize` is called by Ruby to check how much memory your object is taking "
"up.  It _can_ be omitted, but it's polite to include it"
msgstr ""
"`dsize`はがRubyから呼ばれるのはオブジェクトがどの位メモリを取っているのか確認"
"するときです。省略も _可能_ ですが、含めておくのが誠実というものです"

#. type: Bullet: '* '
#: ../_posts/2010-01-01-c.markdown:736
msgid ""
"`data` can point to arbitrary data. Think of it as wrapping C data at a "
"class level. Also not manadatory"
msgstr ""
"`data`は任意のデータを指すことができます。Cのデータをクラス水準で包んだものと"
"考えてください。こちらも必須ではありません"

#. type: Bullet: '* '
#: ../_posts/2010-01-01-c.markdown:736
msgid ""
"`flags` lets you enable additional optimizations when your objects are "
"garbage collected. As long as your `dfree` function doesn't unlock the [GVL]"
"(#c-in-ruby-threads) (why would you do that???) you can safely set it to "
"`RUBY_TYPED_FREE_IMMEDIATELY` for a slight performance improvement"
msgstr ""
"`flags`を使うとオブジェクトがガベージコレクトされたときの追加の最適化を有効に"
"します。`dfree`関数が[GVL](#c-in-ruby-threads)を解放しない限り（そうしたいこ"
"となんてあるのでしょうか）、`RUBY_TYPED_FREE_IMMEDIATELY`を安全に設定すること"
"で僅かに効率性の向上が得られます"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:741
msgid ""
"If you don't set some of these members, you should zero them out so that "
"Ruby doesn't accidentally read garbage data. That's why I used C99's "
"[designated initializer][desinit] syntax in the example above: any members "
"you omit will be safely cleared by the compiler."
msgstr ""
"これらの要素を設定しない場合はRubyがうっかりゴミデータを読まないようにゼロに"
"してしまうべきです。上の例でC99の[明示初期化子][desinit]構文を使っているのは"
"そのためです。どの要素を省いてもコンパイラによって安全に掃除された状態になっ"
"ています"

#. type: Link reference
#: ../_posts/2010-01-01-c.markdown:742
#, no-wrap
msgid "[desinit]: https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html"
msgstr "[desinit]: https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:747
msgid ""
"`VALUE`s that wrap C data will have type `T_DATA` with respect to the "
"[`TYPE()` macro](#value). This helps ensure a clear separation between "
"native Ruby objects and those wrapping C data."
msgstr ""
"Cのデータを包む`VALUE`は、[`TYPE()`マクロ](#value)に関しては型`T_DATA`を持ち"
"ます。これはRuby固有のオブジェクトとCのデータを包んでいるオブジェクトとの間の"
"区別を明確にする補助になります。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:752
msgid ""
"Once you've done all of that work to wrap up the C data, getting it back out "
"is easy: `TypedData_Get_Struct()` takes the object to unwrap, the C type of "
"the underlying data, the same struct pointer as before, and the pointer to "
"assign the data to."
msgstr ""
"一旦Cのデータを包み込む作業が全部終わったら、元に戻すのは簡単です。"
"`TypedData_Get_Struct()`は開封するオブジェクト、通底するデータのCの型、前と同"
"じ構造体ポインタ、そしてデータを代入するポインタを取ります。"

# https://kaworu.jpn.org/cpp/%E9%85%8D%E7%BD%AEnew
#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:758
msgid ""
"This separation of allocation and initialization doesn't jive with [RAII]"
"[raii], so if you're using C++ you will probably want to use [placement new]"
"[place] when wrapping data. If you're having trouble splitting up allocation "
"and initialization, you can just wrap your data in a `struct` and do the "
"_actual_ allocation in `initialize`."
msgstr ""
"このアロケーションと初期化は[RAII](raii)を誤魔化すことはないので、C++を使って"
"いるなら恐らくデータを開封するときに[配置new][place]を使うことになるでしょ"
"う。\n"
"アロケーションと初期化を分離するのが難しければデータを`struct`に包み*実際の*"
"アロケーションを`initialize`ですることもできます。"

#. type: Link reference
#: ../_posts/2010-01-01-c.markdown:759
#, no-wrap
msgid "[raii]: http://wikipedia.org/wiki/Resource_Acquisition_Is_Initialization"
msgstr "[raii]: http://wikipedia.org/wiki/Resource_Acquisition_Is_Initialization"

#. type: Link reference
#: ../_posts/2010-01-01-c.markdown:760
#, no-wrap
msgid "[place]: http://en.cppreference.com/w/cpp/language/new#Allocation"
msgstr "[place]: http://en.cppreference.com/w/cpp/language/new#Allocation"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:769
msgid ""
"In simple cases (like the previous example) you can make your code a little "
"less verbose. If the function to free your data just calls `free()` as in "
"the example, you can pass `RUBY_DEFAULT_FREE` for `dfree` and Ruby will free "
"it for you (**don't** use `NULL` unless you like memory leaks). Similarly, "
"if your allocation is just a `malloc()` as in the example, the macro "
"`TypedData_Make_Struct()` does the allocation for you _and_ wraps it. We "
"could shorten the previous example as such:"
msgstr ""
"（前の例のような）単純な場合ではコードをもっと冗長にならないようにできま"
"す。\n"
"例にあるようにデータを解放するのに`free()`を呼ぶだけなら、`dfree`に"
"`RUBY_DEFAULT_FREE`を渡すことでRubyが代わりに解放してくれます（メモリリークが"
"お好みでなければ`NULL`を使わ*ない*でください）。\n"
"同様にアロケーションで上の例のように単に`malloc()`だけでいいなら、"
"`TypedData_Make_Struct()`がアロケーションをやってくれて、*且つ*梱包もしてくれ"
"ます。\n"
"以前の例を以下のように短くできます。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:773
msgid "{% highlight c %} {% include c/makestruct.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/makestruct.h %}\n"
"{% endhighlight %}"

# マークアンドスイープと合わせます
#. type: Title ###
#: ../_posts/2010-01-01-c.markdown:774
#, no-wrap
msgid "Marking"
msgstr "マークする"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:783
msgid ""
"That `dmark` pointer in the type structure above is the pointer to your "
"object's \"mark function\". This is so named because of the garbage "
"collector's \"mark and sweep\" algorithm. The basic idea behind mark and "
"sweep is that when the garbage collector needs to free up memory, it "
"performs two passes: the first (mark) pass iterates through every "
"_referenced_ Ruby object and marks it as active, then the second (sweep) "
"pass iterates through every _allocated_ Ruby object and frees the ones that "
"haven't been marked active."
msgstr ""
"上の型構造体中の`dmark`ポインタはオブジェクトの「マーク関数」へのポインタで"
"す。これはガベージコレクタの「マーク・アンド・スイープ」アルゴリズムに因んで"
"います。マーク・アンド・スイープの背景にある基本的な考え方において、ガベージ"
"コレクタがメモリを解放する必要があるときに2つの工程を実施します。最初の工程"
"（マーク）では全ての _参照されている_ Rubyのオブジェクトを巡回し活性と印を付"
"けます。それから2つ目の工程（スイープ）では全ての _アロケートされた_ Rubyのオ"
"ブジェクトを巡回し、活性と印が付けられていないものを解放します。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:793
msgid ""
"This is relevant to wrapping C data because it's possible that you might "
"wrap a C `struct` which contains a Ruby `VALUE`—which the garbage collector "
"is responsible for cleaning up. Since the garbage collector is only aware of "
"`VALUE`s referenced _by Ruby_ (not by C pointers), it won't be able to mark "
"the referenced `VALUE` as active. The result is that as soon as the garbage "
"collector needs to free up some memory, your C data is going to end up with "
"a reference to a nonexistent Ruby object. Note that this kind of wrapping of "
"Ruby data inside C data is a really bad idea, precisely because of this kind "
"of issue. But if you really must..."
msgstr ""
"このことはCのデータを包むことに関係してきます。\n"
"なぜかというとRubyの`VALUE`を含むCの`struct`を包む可能性があるからです。\n"
"ガベージコレクタはこの`VALUE`を消し去る使命があります。\n"
"ガベージコレクタは（Cのポインタではなく）*Rubyで*参照された`VALUE`だけはそれ"
"と気付きますが、この場合は`VALUE`を活性だと印を付けられません。\n"
"結果として、ガベージコレクタがメモリを解放する必要が生じるやいなや、Cのデータ"
"は不在のRubyのオブジェクトを参照することになってしまうでしょう。\n"
"なおこういった類の、Cのデータの中にRubyのデータを包むことは本当に悪い考え方"
"で、正にこれに類する問題が理由です。\n"
"でももし本当にそうしなければならないとすれば……。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:797
msgid ""
"In the following example, we'll wrap a C `struct` which contains a `VALUE`. "
"The mark function has the same signature as the free function and all it has "
"to do is mark any `VALUE`s in the `struct`:"
msgstr ""
"以下の例では`VALUE`を含むCの`struct`を包みます。マーク関数は解放関数と同じシ"
"グネチャを持っており、`struct`中の`VALUE`に印を付けて回ることだけに関するもの"
"です。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:801
msgid "{% highlight c %} {% include c/mark.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/mark.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:806
msgid ""
"If your `struct` contains a pointer to a C array of `VALUE`s, you can "
"instead use `rb_gc_mark_locations()` which takes two arguments: the pointers "
"to the start and end of the array (the end being equal to the starting "
"pointer plus the array length).[^maybe]"
msgstr ""
"`struct`が`VALUE`のCの配列へのポインタを含む場合は、代わりに2つの引数を取る"
"`rb_gc_mark_locations()`を使うことができます。この2引数は配列の先頭と末尾への"
"ポインタです（末尾は先頭のポインタに配列の長さを足したものと等しいです）"
"[^maybe]。"

#. type: Title ##
#: ../_posts/2010-01-01-c.markdown:807
#, no-wrap
msgid "Threading"
msgstr "スレッド"

#. type: Title ###
#: ../_posts/2010-01-01-c.markdown:809
#, no-wrap
msgid "Ruby in C Threads"
msgstr "Cのスレッドの中のRuby"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:819
msgid ""
"If you're making a lot of API calls and running a lot of Ruby code from C, "
"at some point you might catch yourself thinking, \"I'm running all of these "
"slow Ruby methods using the API. Maybe I can thread things to keep my code "
"fast!\" That's a reasonable thought, but when you act on it keep in mind "
"that **the Ruby VM is not at all thread safe**. Ideally, all of your API "
"code should run in a single thread. If not, you'll probably need to wrap "
"every API call with a locked mutex to make sure that you never ever have "
"multiple threads interacting with the API at the same time."
msgstr ""
"沢山のAPI呼び出しをしたり沢山のRubyのコードをCから走らせたりする場合、ある時"
"点でふと我に返って、「APIを使ってこの遅いRubyのコードを全部走らせているな。ス"
"レッドっぽいものでコードを速く保てるかもしれないぞ」と思うかもしれません。な"
"るほど理に適った考えですが、**Ruby VMは全くもってスレッド安全ではない**と気に"
"留めておくことに目をつぶればの話です。理想的にはAPIのコード全部は単一スレッド"
"で走らせるべきです。そうでなければ恐らく全てのAPI呼び出しをロックされたミュー"
"テックスに包む必要があるでしょう。同時に複数のスレッドがAPIとやり取りすること"
"がないようにするためです。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:822
msgid ""
"If you just want to create normal Ruby `Thread`s using the API (and don't "
"mind the GVL, as described in the next section), there's an easy way to do "
"that:"
msgstr ""
"単にAPIを使う普通のRubyの`Thread`を作りたいだけなら（そして次節で述べるGVLが"
"気にならなければ）、簡単な方法があります。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:826
msgid "{% highlight c %} {% include c/thread.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/thread.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:829
msgid ""
"Other `Thread` functions are in `ruby/intern.h` (but there's always "
"`rb_funcall()` for everything else)."
msgstr ""
"他の`Thread`の関数は`ruby/intern.h`にあります（しかしどんなものであれいつでも"
"`rb_funcall()`があります）。"

#. type: Title ###
#: ../_posts/2010-01-01-c.markdown:830
#, no-wrap
msgid "C in Ruby Threads"
msgstr "Rubyのスレッドの中のC"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:838
msgid ""
"On the other hand, if you expose some heavy C code to Ruby with the API (if "
"you're writing an extension that wraps a C library, for example), you should "
"spend some time thinking about a nasty thing called the global VM lock "
"(GVL).  Because most of the API is not `Thread` safe, the GVL locks down "
"almost all Ruby code so that only a single `Thread` can run at a time. This "
"is the reason why you'll often hear people say that `Thread` does not allow "
"true parallelism."
msgstr ""
"他方で、重いCのコードをAPIでRubyにさらけ出す場合（例えばCのライブラリを包む拡"
"張を書いている場合など）、大域的VMロック (GVL) と呼ばれる頭痛の種には時間を"
"取って考えてみることです。ほとんどのAPIは`Thread`安全ではないですから、一度に"
"単一の`Thread`だけが走るように、GVLはほぼ全てのRubyのコードをロックしてしまい"
"ます。これが俗に`Thread`では真の並列性がないと言われる所以です。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:850
msgid ""
"The VM also applies the GVL to any C code you expose to Ruby. That's why you "
"can use the API without worrying about it exploding when someone calls your "
"C code from inside a `Thread`. The downside of this is that if your C code "
"takes a while to run, you won't see any performance benefit from calling it "
"in a `Thread` because **it will block all other threads** while it runs. But "
"the GVL is only needed to protect API calls. If you have some C code that "
"doesn't use the API, you can tell the VM to release the GVL before running "
"your code in a thread and to reacquire it when it completes, allowing for "
"true parallelism.  Locking and unlocking the GVL does carry a performance "
"hit, so only resort to this if you notice that you're having significant "
"problems due to blocked threads."
msgstr ""
"またVMはRubyにさらけ出すCのコードには漏れなくGVLを適用します。\n"
"Cのコードを`Thread`の中から呼ぶときに暴発を心配せずAPIを使えるのはそのためで"
"す。\n"
"このことの欠点はCのコードを走らせるのに時間が掛かることで、`Thread`で呼ぶこと"
"による効率性の利点が見られないということです。\n"
"なぜならそのスレッドが走っているときは**他の全てのスレッドをブロックしている"
"**からです。\n"
"しかしGVLはAPI呼び出しを保護するためだけに必要なものです。\n"
"APIを使わないCのコードがあるとき、スレッド中でコードを走らせる前にGVLを免除し"
"てほしいとVMに伝え、処理が完了したあとにGVLを再装填できます。\n"
"こうすれば真の並列性が得られます。\n"
"GVLを封鎖したり解除したりすると効率性への影響はあるので、ブロックされたスレッ"
"ドによる顕著な問題を抱えていると気付いたときだけこの方法に頼るようにしてくだ"
"さい。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:854
msgid ""
"The code to do this is considered so fancy by the Ruby developers that you "
"actually need to include another header to use it. First we'll look at the "
"slightly simpler way to release the GVL:"
msgstr ""
"こういったことをするコードはRubyで開発している人にとっては酷だと思われるの"
"で、実際には使用する別のヘッダを含める必要があるでしょう。まずGVLを解除する少"
"しだけ単純なやり方を見ていきます。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:858
msgid "{% highlight c %} {% include c/gvl2.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/gvl2.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:861
msgid ""
"Since the function that is run without the GVL gets and returns data using "
"`void*`, you may want to define a `struct` for passing data via pointers."
msgstr ""
"GVLなしに走る関数が`void*`を使うデータを取得したり返したりしているので、ポイ"
"ンタを介してデータを渡すために`struct`を定義したいところでしょう。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:866
msgid ""
"If you unlock the GVL as above you will find that while your code does run "
"in parallel, it can't be interrupted (by signals, `Thread.kill`, etc.)! To "
"allow for that you must pass an unblocking function using the last two "
"arguments:"
msgstr ""
"上のようにGVLを解除するとコードは確かに並列で走るものの、（シグナルや`Thread."
"kill`などによって）中断できないことに気付かれるでしょう。中断できるようにする"
"には末尾の2引数を使ってブロック解除関数を渡さなければいけません。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:870
msgid "{% highlight c %} {% include c/gvl.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/gvl.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:875
msgid ""
"The unblocking function is called in the event of an interrupt. To make it "
"work, you will probably need to pass a pointer to both functions that can be "
"used to communicate an interrupt from one to the other. The interrupted "
"function should perform any necessary cleanup before returning early."
msgstr ""
"ブロック解除関数は中断のイベント中に呼ばれます。動作させるためには恐らくポイ"
"ンタを両方の関数に渡して、中断が一方から他方へと伝わるようにするために使う必"
"要があるでしょう。中断された関数は早期に返る前に必要な片付けを実施します。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:880
msgid ""
"Alternatively, if the interrupted function doesn't _need_ to perform any "
"special cleanup, you can use the built in unblocking function "
"`RUBY_UBF_IO`[^ubf] (which ignores the unblocking argument). That simply "
"forwards the interrupt to the running thread.[^int]"
msgstr ""
"代えて中断された関数が特別な片付けをする _必要_ がないならば、（ブロック解除"
"引数を無視する）組み込みのブロック解除関数`RUBY_UBF_IO`[^ubf]が使えます。これ"
"は単純に中断を走っているスレッドに転送します[^int]。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:884
msgid ""
"If you go through all of that effort to release the GVL only to find that "
"you need to make an API call in your unlocked thread, there's a function to "
"temporarily reacquire the GVL:"
msgstr ""
"GVLを解除するためにこうした一通りの骨折りをした後で、ブロックが解除されたス"
"レッドでAPI呼び出しをする必要があるとわかった場合のみ、一時的にGVLを再装填す"
"る関数があります。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:888
msgid "{% highlight c %} {% include c/with_gvl.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include c/with_gvl.h %}\n"
"{% endhighlight %}"

#. type: Title ##
#: ../_posts/2010-01-01-c.markdown:889
#, no-wrap
msgid "See Also"
msgstr "参考文献"

#. type: Title ###
#: ../_posts/2010-01-01-c.markdown:891
#, no-wrap
msgid "extension.rdoc"
msgstr "extension.rdoc"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:897
msgid ""
"Ruby does have [official API documentation][readme]. It's a bit spotty and "
"has some poor recommendations (in my opinion), but it is also a little more "
"exhaustive on certain topics. In many cases this is because I intentionally "
"skipped something that I either found not useful or better documented "
"elsewhere."
msgstr ""
"Rubyには確かに[公式のAPIドキュメント][readme]があります。（私の感想としては）"
"少々むらがあってお勧めしにくいのですが、特定の話題についてはもう少しつまびら"
"かにされていたりもします。筆者が意図的に書かずにおいたところは沢山あります"
"が、それは有益と思われなかったりもっと良いドキュメントがどこかにあったりする"
"からなのです。"

#. type: Link reference
#: ../_posts/2010-01-01-c.markdown:898
#, no-wrap
msgid "[readme]: https://github.com/ruby/ruby/blob/master/doc/extension.rdoc"
msgstr "[readme]: https://github.com/ruby/ruby/blob/master/doc/extension.rdoc"

#. type: Title ###
#: ../_posts/2010-01-01-c.markdown:900
#, no-wrap
msgid "Headers"
msgstr "ヘッダ"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:910
msgid ""
"I think some of the handiest resources are the Ruby headers themselves. The "
"full API (i.e. everything you get by including `ruby.h`) easily consists of "
"a thousand functions, macros, constants, and globals—most of which have "
"never been documented. However _most_ things are reasonably named and you "
"should be able to figure out what they do from the header. Most everything "
"you need should be in the headers `ruby/ruby.h` and `ruby/intern.h`. The "
"former has all of the VM and metaprogramming functions, the latter has all "
"of the functions for interacting with Ruby's built in classes."
msgstr ""
"最も敷居の高い資料はRubyのヘッダ自体だと思っています。\n"
"完全なAPI（すなわち`ruby.h`を含めることで手に入る全てのもの）はゆうに千を越え"
"る関数、マクロ、定数、大域変数からなります。\n"
"そのほとんどは全くドキュメントがありません。\n"
"しかし*ほとんど*のものは理に適った命名でヘッダから何をするものなのかを調べる"
"ことができるでしょう。\n"
"必要になるもののほとんどは`ruby/ruby.h`と`ruby/intern.h`のヘッダにありま"
"す。\n"
"前者はVMとメタプログラミング関数についての全てがあり、後者にはRubyに組み込み"
"クラスとやり取りする関数の全てがあります。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:914
msgid ""
"There are also some headers _not_ pulled in by `ruby.h` which you can "
"include to get additional API functionality. Maybe one day I'll write "
"another section to this guide going over them:"
msgstr ""
"`ruby.h`では取り込まれ _ない_ ヘッダもあり、含めることで追加のAPI機能が得られ"
"るものがあります。\n"
"いつの日か本手引きで節を改めることがあるかもしれません。"

#. type: Bullet: '* '
#: ../_posts/2010-01-01-c.markdown:923
msgid "`ruby/debug.h` (experimental) functions for profiling and tracing code"
msgstr "`ruby/debug.h`（実験的）プロファイリングとコードの追跡用の関数"

#. type: Bullet: '* '
#: ../_posts/2010-01-01-c.markdown:923
msgid "`ruby/encoding.h` functions for working with string encodings"
msgstr "`ruby/encoding.h` 文字列エンコーディングを扱う関数"

#. type: Bullet: '* '
#: ../_posts/2010-01-01-c.markdown:923
msgid "`ruby/io.h` additional functions for Ruby's IO class"
msgstr "`ruby/io.h` RubyのIOクラス用の追加の関数"

#. type: Bullet: '* '
#: ../_posts/2010-01-01-c.markdown:923
msgid "`ruby/re.h` additional functions for Ruby's Regexp class"
msgstr "`ruby/re.h` RubyのRegexpクラス用の追加の関数"

#. type: Bullet: '* '
#: ../_posts/2010-01-01-c.markdown:923
msgid ""
"`ruby/thread.h` functions for working with the [GVL](#c-in-ruby-threads)"
msgstr "`ruby/thread.h` [GVL](#c-in-ruby-threads)を扱うための関数"

#. type: Bullet: '* '
#: ../_posts/2010-01-01-c.markdown:923
msgid ""
"`ruby/version.h` functions for version introspection. Do not use this as "
"feature-detection code!"
msgstr ""
"`ruby/version.h` バージョンを調べる関数。これを機能を検出するコードに使わない"
"ように"

#. type: Bullet: '* '
#: ../_posts/2010-01-01-c.markdown:923
msgid "`ruby/vm.h` (experimental) functions for VM control"
msgstr "`ruby/vm.h`（実験的）VM制御用の関数"

#. type: Title ###
#: ../_posts/2010-01-01-c.markdown:924
#, no-wrap
msgid "Source"
msgstr "ソース"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:928
msgid ""
"If you find some function in the header that isn't documented anywhere, your "
"next stop should be the Ruby source code."
msgstr ""
"どこにもドキュメント化されていないヘッダ中の関数を見付けたら、次なる一手は"
"Rubyのソースコードです。"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:932
msgid ""
"{% highlight shell_session %} $ git clone https://github.com/ruby/ruby.git "
"{% endhighlight %}"
msgstr ""
"{% highlight shell_session %}\n"
"$ git clone https://github.com/ruby/ruby.git\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:937
msgid ""
"When reading through the source code, always keep the headers at hand: there "
"are lots of really useful functions in there that _look_ like they should be "
"in the API, but actually aren't. In most cases there should be an API "
"function elsewhere that wraps the call to the useful function."
msgstr ""
"ソースコードを一読する際は常にヘッダを控えておきましょう。ソースコードには本"
"当に役立ちそうでいてAPIにありそうに _見える_ 関数が沢山あります。ほとんどの場"
"合その役に立つ関数を呼び出すために梱包するAPI関数があることでしょう。"

#. type: Yaml Front Matter Hash Value: title
#: ../_posts/2010-01-01-c.markdown:938 ../_posts/2014-01-01-examples.markdown:1
#, no-wrap
msgid "Examples"
msgstr "例"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:942
msgid ""
"Head over to the [Examples](../examples) page for short, compilable examples "
"of the API in action."
msgstr ""
"[例](../examples)のページには短くてコンパイルできる、実際のAPIの例があるので"
"読んでみてください。"

#. type: Title ###
#: ../_posts/2010-01-01-c.markdown:943
#, no-wrap
msgid "Contribute"
msgstr "貢献する"

#. type: Plain text
#: ../_posts/2010-01-01-c.markdown:949
msgid ""
"Now that you've finished reading my guide, did you notice something "
"significant that I left out? Did I make some stupid mistake? Check out the "
"[source][gh] for this site on Github and you can report issues, submit pull "
"requests, and download all of the code examples."
msgstr ""
"これで本手引きを読み終わりましたが、何か著しく書き漏らしたものがあるでしょう"
"か。\n"
"粗忽な誤りがなかったでしょうか。このサイトの[ソース][gh]をGithubで確認してイ"
"シューを報告したりプルリクエストを送ってください。\n"
"またGithubから全てのコード例をダウンロードできます。"

#. type: Link reference
#: ../_posts/2010-01-01-c.markdown:950
#, no-wrap
msgid "[gh]: https://github.com/silverhammermba/emberb"
msgstr "[gh]: https://github.com/silverhammermba/emberb"

#. type: Title ##
#: ../_posts/2010-01-01-c.markdown:952 ../_posts/2012-01-01-embed.markdown:159
#: ../_posts/2013-01-01-extend.markdown:128
#, no-wrap
msgid "Footnotes"
msgstr "脚註"

#. type: Footnote intern
#: ../_posts/2010-01-01-c.markdown:954
#, no-wrap
msgid ""
"[^intern]: That's a blatant lie. The API _definitely_ lets you mess around\n"
"           with the internal data structures of objects (look for things with\n"
"           names starting with capital R). But it's generally not a good idea\n"
"           and not necessary."
msgstr ""
"[^intern]: まったくの嘘っぱちです。\n"
"           APIにより、*確実に*オブジェクトの内部データ構造を滅茶苦茶にできます（名前が大文字Rで始まるものを探してみてください）。\n"
"           しかし一般には感心しませんし、必要でもないのです。"

#. type: Footnote undef
#: ../_posts/2010-01-01-c.markdown:959
#, no-wrap
msgid ""
"[^undef]: There's also `Qundef` representing an undefined value, but\n"
"          this has no Ruby equivalent and is [rarely](#handling-blocks)\n"
"          [used](#constants-1). In fact, outside of those rare occasions,\n"
"          `Qundef` can segfault the VM if Ruby was expecting a normal `VALUE`."
msgstr ""
"[^undef]: 未定義値を表す`Qundef`もあります。\n"
"          しかし、Rubyでそれと同じものはなく、[滅多に](#handling-blocks)[使われ](#constants-1)ません。\n"
"          実際、こうして稀に出てくることはありますが、Rubyで通常の`VALUE`が期待されるところに`Qundef`があると、VMはセグフォします。"

#. type: Footnote wrap
#: ../_posts/2010-01-01-c.markdown:964
#, no-wrap
msgid ""
"[^wrap]: There's also `rb_eval_string_wrap()` which _should_ be useful, but is\n"
"         actually the same as `rb_eval_string_protect()` due to a [bug][bug2]."
msgstr ""
"[^wrap]: `rb_eval_string_wrap()`もあり、きっと便利なの*でしょう*。\n"
"         しかし実は[バグ][bug2]があり、`rb_eval_string_protect()`と同じものになっています。"

#. type: Footnote chr
#: ../_posts/2010-01-01-c.markdown:967
#, no-wrap
msgid ""
"[^chr]: There is a `CHR2FIX()` macro, but in my tests this sometimes gave\n"
"        unexpected results. `LONG2FIX()` should work."
msgstr ""
"[^chr]: `CHR2FIX()`マクロがありますが、筆者が試したところ、思いがけない結果になることがありました。\n"
"        `LONG2FIX()`は正しく機能するでしょう。"

#. type: Footnote wchar
#: ../_posts/2010-01-01-c.markdown:970
#, no-wrap
msgid ""
"[^wchar]: I don't know what the best way is to handle `wchar_t`. In my tests I had\n"
"          some success just treating them as `char`s, but I think that may have\n"
"          been a happy accident, and could certainly fail on different platforms."
msgstr ""
"[^wchar]: `wchar_t`を扱う、最も良い方法はわかりません。\n"
"          試したところ、単なる`char`として扱えたことがありますが、それはたまたま運が良かっただけで、違うプラットフォームではきっと失敗することでしょう。"

#. type: Footnote clear
#: ../_posts/2010-01-01-c.markdown:974
#, no-wrap
msgid ""
"[^clear]: The documentation [states][control] that \"You have to clear the error\n"
"          info... when ignoring the caught exception\" during `rb_protect`. But I\n"
"          can't find any documentation of when it would be cleared for\n"
"          you—it seems like you _always_ have to clear it."
msgstr ""
"[^clear]: ドキュメントには、`rb_protect`の最中に「捕捉した例外を無視する[場合][when]は……エラー情報を消去しなければいけない」と[記述][control]されています。\n"
"          どのような場合には消去してくれるのかについて書かれたドキュメントは見つかっていません。\n"
"          *常に*消去しなければいけないように思われます。"

#. type: Footnote yield
#: ../_posts/2010-01-01-c.markdown:979
#, no-wrap
msgid ""
"[^yield]: And there's `rb_yield_block()` which takes two unused arguments and is\n"
"          never called by anything in Ruby. Odd."
msgstr ""
"[^yield]: そして、`rb_yield_block()`という使われない引数を2つ取るものがあり、Rubyではどこからも呼ばれません。\n"
"          妙です。"

#. type: Footnote break
#: ../_posts/2010-01-01-c.markdown:982
#, no-wrap
msgid ""
"[^break]: The documentation [mentions][control] `rb_iter_break()` and\n"
"          `rb_iter_break_value()` for breaking out of a block, but can't you\n"
"          just return early? I can't think of a use-case for these."
msgstr ""
"[^break]: ドキュメントではブロックを突破する用に、`rb_iter_block()`と`rb_iter_break_value()`について[言及][control]しています。\n"
"          しかし、単に早期に戻ることはできないのでしょうか。\n"
"          筆者はこれらの使い途が思いつきません。"

#. type: Footnote int
#: ../_posts/2010-01-01-c.markdown:986
#, no-wrap
msgid ""
"[^int]: There is also the function `rb_thread_call_without_gvl2()`. The\n"
"        documentation in `thread.c` says that if it \"detects interrupt, it\n"
"        returns immediately,\" but I'm not sure what this means. If the\n"
"        unblocking function doesn't kill the thread, it still waits for the\n"
"        thread to finish on its own before returning."
msgstr ""
"[^int]: 関数`rb_thread_call_without_gvl2()`もあります。\n"
"        `thread.c`のドキュメントには、「中断を検知すると直ちに戻る」とありますが、どういう意味なのかよく分かりません。\n"
"        ブロック解除関数がスレッドをキルしなければ、戻る前にスレッドがひとりでに終わるまでずっと待機することになります。"

#. type: Footnote ubf
#: ../_posts/2010-01-01-c.markdown:992
#, no-wrap
msgid ""
"[^ubf]: You can also use `RUBY_UBF_PROCESS`, but this seems to be a leftover\n"
"        from deprecated code and has the exact same effect."
msgstr ""
"[^ubf]: `RUBY_UBF_PROCESS`を使うこともできます。\n"
"        しかし、旧式のコードの残滓と思われます。\n"
"        ともあれ全く同じ効果があります。"

#. type: Footnote oldwrap
#: ../_posts/2010-01-01-c.markdown:995
#, no-wrap
msgid ""
"[^oldwrap]: The `TypedData*` macros are the preferred way to wrap data since\n"
"            Ruby 1.9.2. If you're using an older version of Ruby you can check\n"
"            out an older version of this guide on Github to see how it used to\n"
"            be done."
msgstr ""
"[^oldwrap]: `TypedData*`マクロは、Ruby 1.9.2以降では、データを包む好ましいやり方です。\n"
"            古いバージョンのRubyを使っているなら、Githubで本手引きの古いバージョンを確認すれば、かつてどのように使われていたのかがわかります。"

#. type: Footnote maybe
#: ../_posts/2010-01-01-c.markdown:1000
#, no-wrap
msgid ""
"[^maybe]: There's also the enigmatically named `rb_gc_mark_maybe()`, but I'm not\n"
"          sure when it is needed."
msgstr "[^maybe]: 謎めいた名前の`rb_gc_mark_maybe()`もありますが、いつ必要になるのかわかりません。"

#. type: Footnote tdata
#: ../_posts/2010-01-01-c.markdown:1003
#, no-wrap
msgid "[^tdata]: Or use `T_DATA` if the object [wraps a C pointer](#data)."
msgstr "[^tdata]: あるいは、オブジェクトが[Cのポインタを包む](#data)のなら、`T_DATA`を使ってください。"

# 空白を空けないことによって意図しない改行を回避しています
#. type: Link reference
#: ../_posts/2010-01-01-c.markdown:1005
#, no-wrap
msgid "[control]: https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-Control+Structure"
msgstr "[control]: https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-Control+Structure"

#. type: Link reference
#: ../_posts/2010-01-01-c.markdown:1006
#, no-wrap
msgid "[bug2]: https://bugs.ruby-lang.org/issues/10466"
msgstr "[bug2]: https://bugs.ruby-lang.org/issues/10466"

#. type: Title ##
#: ../_posts/2012-01-01-embed.markdown:1
#: ../_posts/2014-01-01-examples.markdown:6
#, no-wrap
msgid "Running Ruby in C"
msgstr "CでRubyを実行する"

#. type: Title ##
#: ../_posts/2012-01-01-embed.markdown:6 ../_posts/2013-01-01-extend.markdown:6
#, no-wrap
msgid "Compiling"
msgstr "コンパイルする"

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:12
msgid ""
"Embedding Ruby requires one header `ruby.h`, which includes a platform-"
"specific header `ruby/config.h`. You will probably need to tell your "
"compiler about the include paths for these headers. You will also need to "
"link with the Ruby lib.  On my machine, my minimal compiler options are:"
msgstr ""
"Rubyを組込むには、`ruby.h`ヘッダが要ります。\n"
"このファイルには、プラットフォーム固有の`ruby/config.h`ヘッダが含まれます。\n"
"恐らく、これらのヘッダのincludeパスをコンパイラに伝える必要があるでしょう。\n"
"Rubyライブラリともリンクする必要があります。\n"
"私の環境では、最小限のコンパイラオプションは次の通りです。"

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:16
msgid ""
"{% highlight shell_session %} $ gcc foo.c -I/usr/include/ruby-{{ site."
"rbversion }}.0 -I/usr/include/ruby-{{ site.rbversion }}.0/x86_64-linux -"
"lruby {% endhighlight %}"
msgstr ""
"{% highlight shell_session %}\n"
"$ gcc foo.c -I/usr/include/ruby-{{ site.rbversion }}.0 -I/usr/include/ruby-"
"{{ site.rbversion }}.0/x86_64-linux -lruby\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:18
msgid ""
"If available, you can use `pkg-config` to get the appropriate options for "
"your OS:"
msgstr ""
"しかしもし可能であれば、`pkg-config`を使うと良いでしょう。\n"
"自分のOSに適したオプションが得られます。"

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:22
msgid ""
"{% highlight shell_session %} $ pkg-config --cflags --libs ruby-{{ site."
"rbversion }} {% endhighlight %}"
msgstr ""
"{% highlight shell_session %}\n"
"$ pkg-config --cflags --libs ruby-{{ site.rbversion }}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:25
msgid ""
"Those approaches might not work if Ruby is installed in a nonstandard "
"location on your machine or your OS does not provide standard header/library "
"directories.  A more robust approach is to ask Ruby itself where things are "
"and to set up the run-time library path:"
msgstr ""

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:29
msgid "{% highlight ruby %} #!/usr/bin/env ruby require 'shellwords'"
msgstr ""

#. type: Title #
#: ../_posts/2012-01-01-embed.markdown:30
#, no-wrap
msgid "location of ruby.h"
msgstr ""

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:32
msgid "hdrdir = Shellwords.escape RbConfig::CONFIG[\"rubyhdrdir\"]"
msgstr ""

#. type: Title #
#: ../_posts/2012-01-01-embed.markdown:32
#, no-wrap
msgid "location of ruby/config.h"
msgstr ""

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:34
msgid "archhdrdir = Shellwords.escape RbConfig::CONFIG[\"rubyarchhdrdir\"]"
msgstr ""

#. type: Title #
#: ../_posts/2012-01-01-embed.markdown:34
#, no-wrap
msgid "location of libruby"
msgstr ""

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:36
msgid "libdir = Shellwords.escape RbConfig::CONFIG[\"libdir\"]"
msgstr ""

#. type: Title #
#: ../_posts/2012-01-01-embed.markdown:37
#, no-wrap
msgid "args for GCC"
msgstr ""

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:40
msgid ""
"puts \"-I#{hdrdir} -I#{archhdrdir} -L#{libdir} -Wl,-rpath,#{libdir}\" {% "
"endhighlight %}"
msgstr ""

#. type: Title ###
#: ../_posts/2012-01-01-embed.markdown:41
#, no-wrap
msgid "Windows"
msgstr ""

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:45
msgid ""
"On Windows, I highly recommend using the [RubyInstaller](https://"
"rubyinstaller.org/downloads/) **with Devkit**.  This gives you access to GCC "
"on the Windows command line as well as `pkgconf` for getting the build flags."
msgstr ""

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:51
msgid ""
"{% highlight shell_session %} $ ridk enable # enable devkit $ pkgconf.exe --"
"cflags --libs C:\\Ruby33-x64\\lib\\pkgconfig\\ruby-3.3.pc # show GCC args $ "
"gcc foo.c ...  {% endhighlight %}"
msgstr ""
"{% highlight shell_session %}\n"
"$ ridk enable # devkitを有効にする\n"
"$ pkgconf.exe --cflags --libs C:\\Ruby33-x64\\lib\\pkgconfig\\ruby-3.3.pc # "
"GCCの引数を表示\n"
"$ gcc foo.c ...\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:55
msgid ""
"Note that the GCC args might not be parsed correctly by PowerShell, so use "
"`cmd` instead.  Also the Ruby 3.3 installer is missing the lib location from "
"its `pkgconf` output for some reason, so you'll need to add the `-L` option "
"manually.  You can locate that with `RbConfig::CONFIG[\"libdir\"]` as above; "
"the installer put it in `C:\\Ruby33-x64\\lib` for me."
msgstr ""

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:59
msgid ""
"Finally, Windows has no `rpath` so you will need to copy any linked DLLs "
"alongside the built executable for it to run.  That includes any DLLs needed "
"by Ruby itself.  The installer put those in `C:\\Ruby33-"
"x64\\bin\\ruby_builtin_dlls` for me."
msgstr ""

#. type: Title ##
#: ../_posts/2012-01-01-embed.markdown:60
#, no-wrap
msgid "Startup, Teardown"
msgstr "起動と終了"

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:65
msgid ""
"Including the Ruby interpreter in your C/C++ program is pretty simple. Just "
"include the header, call a startup function in `main` before you use the "
"API, and a cleanup function after you're done:"
msgstr ""
"RubyインタプリタをCやC++のプログラムに含めることはとても簡単です。\n"
"ヘッダーを含めて、\n"
"APIを使用する前にインタプリタを立ち上げるための関数を `main` で呼び、\n"
"そして完了後に後片付けをする関数を呼べばよいのです。"

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:69
msgid "{% highlight c %} {% include embed/simple.c %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include embed/simple.c %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:74
msgid ""
"If the VM fails to start during `ruby_init()` it will print an error and "
"exit your program! If you would rather have a softer error, you can instead "
"call `ruby_setup()` which returns a nonzero value if a failure occurred "
"(unfortunately it is not clear how to get a message for the error[^err])."
msgstr ""
"`ruby_init()` の最中にVMが実行に失敗したら、エラーを表示してプログラムが終了"
"してしまいます！もっと柔軟にエラーを出したいときは、代わりに失敗したときにゼ"
"ロではない値を返す`ruby_setup()` を使いましょう（残念ながら、この場合のエラー"
"メッセージの出しかたはよくわかっていません[^err]）。"

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:79
msgid ""
"If an error occurs during `rb_cleanup()`, it returns a nonzero value—"
"otherwise it returns the argument you passed it. This allows a little "
"shortcut for returning an error status if the cleanup fails (as demonstrated "
"in the previous example)."
msgstr ""
"`rb_cleanup()` の最中にエラーが発生したときは、ゼロではない値を返します。\n"
"もしエラーが発生しなければ、渡した引数が返ります。\n"
"この仕様により、後片付けに失敗したときのエラーステータスを返す部分が少し短く"
"書けます（先の例で実演したように）。"

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:88
msgid ""
"_Technically_ you don't have to call `ruby_init`/`ruby_setup` in `main`, but "
"the Ruby VM assumes that all future Ruby code will be run from the same "
"stack frame or a lower one (for garbage collection purposes). The easiest "
"way to ensure this is to do set up at the top-level of your program, though "
"other approaches could work. But it would be a bad idea, for example, to "
"init Ruby in some deeply-nested function, pop a bunch of stack frames, and "
"then run a bunch of Ruby code.  {: .alert .alert-danger}"
msgstr ""
"_技術的には_ `main` で `ruby_init` や `ruby_setup` を呼ぶ必要はありません。\n"
"しかし、RubyのVMは以降全てのRubyのコードが同じかこれより低層のスタックフレー"
"ムから\n"
"実行されることを仮定しています（ガベージコレクションのためです）。\n"
"他の方法でも動くにせよ、\n"
"このことを確証する最も簡単な方法がプログラムのトップレベルで立ち上げを行うこ"
"となのです。\n"
"例えば深く入れ子になった関数でRubyを初期化して、沢山のスタックフレームを立ち"
"上げ、\n"
"そして沢山のRubyのコードを実行するようなことはよくありません。\n"
"{: .alert .alert-danger}"

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:94
msgid ""
"During cleanup, the VM might evaluate more Ruby code (if you passed a block "
"to `at_exit`, for example) which could raise an exception. `ruby_cleanup()` "
"handles these by returning a nonzero value and printing an error message. If "
"you instead call `ruby_finalize()` they will be raised normally (see the "
"section on [Exceptions](../c#rescue) for how to handle them)."
msgstr ""
"後片付けをするときにも、VMはRubyのコードを評価するかもしれません（`at_exit` "
"にブロックを渡したときなど）。\n"
"そしてそのときに例外が発生する可能性があります。\n"
"`ruby_cleanup()` はこのような例外が発生したときに、\n"
"ゼロではない値を返してエラーメッセージを表示することで制御します。\n"
"代わりに `ruby_finalize()` を呼ぶと、通常通り例外を発生させます。\n"
"（制御方法については[Exceptions](../c#rescue)節を参照）"

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:96
msgid "Here's an alternative example:"
msgstr "別の例はこちらです。"

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:100
msgid "{% highlight c %} {% include embed/advanced.c %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include embed/advanced.c %}\n"
"{% endhighlight %}"

#. type: Title ###
#: ../_posts/2012-01-01-embed.markdown:101
#, no-wrap
msgid "Limitations"
msgstr "制約"

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:109
msgid ""
"Other than the stack frame warning above, there is another limitation: you "
"only get one Ruby VM per process. The startup/teardown might make it look "
"like you can keep on destroying and rebuilding the VM over and over again, "
"but `ruby_cleanup` only makes sure that your Ruby code is all cleaned up and "
"done.  It doesn't fully clean up the VM state such that it is ready to be re-"
"initialized: if you call `ruby_init` again, it will fail."
msgstr ""
"上記のスタックフレームの警告以外にも制約があります。\n"
"1つのプロセスに1つだけRubyのVMを動かせます。\n"
"起動と終了の方法を見ると、何度でもVMの破壊と創造を繰り返せるような気がしてく"
"るかもしれませんが、\n"
"`ruby_cleanup` はRubyのコードが全ての後片付けが完了したことだけを確認しま"
"す。\n"
"VMの状態を再度初期化できるような状態までは後片付けしません。\n"
"もう一度 `ruby_init` を呼び出すと、実行に失敗してしまうでしょう。"

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:112
msgid ""
"If for some reason you need multiple Ruby VMs in your program, you will need "
"to spin them off in multiple processes to bypass this limitation."
msgstr ""
"何かかの理由があってプログラムで複数のRubyのVMが必要になったら、\n"
"この制約を回避するために複数のプロセスに小分けにしなければいけません。"

#. type: Title ##
#: ../_posts/2012-01-01-embed.markdown:113
#, no-wrap
msgid "Tweaking the VM"
msgstr "VMを設定する"

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:118
msgid ""
"You now have a bare-bones Ruby VM running, but you may want to set up a "
"little more stuff before you start running Ruby code. To set the name of the "
"Ruby script (e.g. `$0`) for error messages and such, use"
msgstr ""
"これでRubyのVMの実行の骨子を会得しました。\n"
"でも、Rubyのコードの実行に先駆けてもう少し設定したいことがあるかもしれませ"
"ん。\n"
"エラーメッセージとかのためにRubyのスクリプトの名前（例：`$0`）を設定したいと"
"きは、\n"
"以下のようにします。"

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:122
msgid "{% highlight c %} ruby_script(\"new name\")  {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"ruby_script(\"new name\")\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:124
msgid "To set up the load path so that gems can be loaded with `require`, use"
msgstr ""
"gemが `require` で呼び出せるようにするためにロードパスを設定するには、\n"
"次のようにします。"

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:128
msgid "{% highlight c %} ruby_init_loadpath()  {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"ruby_init_loadpath()\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:132
msgid ""
"You can also pass options to the VM just like you would to `ruby` on the "
"command line. This is handy for stuff like setting the warning level or "
"verbose mode[^opt]."
msgstr ""
"VMにはコマンドラインで `ruby` するときと同じオプションを渡せます。\n"
"警告水準や冗長モード[^opt]の設定に手頃です。"

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:136
msgid "{% highlight c %} {% include embed/options.c %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include embed/options.c %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:142
msgid ""
"The arguments to `ruby_options` are `argc` and `argv` just like a main "
"function.  And just like the main of the `ruby` program, the VM expects to "
"get some Ruby code when you call it. If you don't give it the filename of a "
"script to load or code to run with `-e`, it will try to read from `stdin`. "
"If you want to set options but _not_ run any Ruby code, you can pass it an "
"empty line: `\"-e \"`."
msgstr ""
"`ruby_options`への引数はmain関数と同じ`argc`と`argv`です。そして、`ruby`プロ"
"グラムのmainと同じように、呼び出したときはVMは何らかのRubyのコードがあるもの"
"としています。ロードするスクリプトのファイル名を与えていなかったり、`-e`で実"
"行するコードがないときは、`stdin`から読み込もうとします。オプションを設定した"
"いけれども、Rubyのコードを実行したく _ない_ ときには、`\"-e \"`のように空行を"
"渡せばよいです。"

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:151
msgid ""
"`ruby_options()` returns a \"node\" that represents the compiled Ruby code. "
"In some cases (such as a syntax error) the node will be invalid and you "
"shouldn't run it. `ruby_executable_node()` checks for this. If the node is "
"valid, you can run it with `ruby_exec_node()`. The state returned by "
"`ruby_executable_node()` (through the pointer) and by `ruby_exec_node()` "
"will be nonzero if an exception was raised while compiling or running the "
"code. You can [read the exception yourself](../c#rescue), or just pass "
"`state` to `ruby_cleanup()` and it will print an appropriate error message."
msgstr ""
"`ruby_options()` はコンパイルされたRubyのコードを表現する \"node\" を返しま"
"す。\n"
"場合によっては（文法エラーとか）nodeが不正で実行すべきでないときがありま"
"す。\n"
"`ruby_executable_node()` はこのnodeを検査します。\n"
"nodeが妥当であれば、 `ruby_exec_node()` で実行できます。\n"
"`ruby_executable_node()` で（ポインタを介して）返る状態は、\n"
"コンパイルの最中やコードの実行時に例外が発生したら、ゼロではない値になりま"
"す。\n"
"[例外を自前で読む](../c#rescue)こともできますし、\n"
"`ruby_cleanup()` に `state` を渡して適切なエラーメッセージを表示させることも"
"できます。"

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:154
msgid ""
"Ruby currently doesn't support any other way of compiling and running code "
"separately[^load]."
msgstr ""
"Rubyは今のところコードの他のコンパイル・実行を別々にする方法を提供していませ"
"ん[^load]。"

#. type: Title ##
#: ../_posts/2012-01-01-embed.markdown:155
#: ../_posts/2013-01-01-extend.markdown:105
#, no-wrap
msgid "Success"
msgstr "やったね"

#. type: Plain text
#: ../_posts/2012-01-01-embed.markdown:158
msgid "Now you're ready to interact with Ruby! Go back to the [C API](../c)."
msgstr ""
"これでRubyとやりとりできました！\n"
"[C API](../c)に戻りましょう。"

#. type: Footnote err
#: ../_posts/2012-01-01-embed.markdown:161
#, no-wrap
msgid ""
"[^err]: `ruby_init()` uses `error_print()` to get an error message, but this\n"
"        function isn't exposed to the API. Is this a normal exception?"
msgstr ""
"[^err]: `ruby_init()`では、エラーメッセージを取得するために`error_print()` を使います。\n"
"        しかし、この関数はAPIとして提供されていません。\n"
"        これは普通に例外的なものなのでしょうか。"

#. type: Footnote opt
#: ../_posts/2012-01-01-embed.markdown:164
#, no-wrap
msgid ""
"[^opt]: In my tests I couldn't get flags like `-w` and `-v` to do anything. This\n"
"        could be related to `ruby_prog_init()`. And really it should be possible\n"
"        to do this without parsing command line options."
msgstr ""
"[^opt]: 筆者の実験では、`-w` や `-v` といったフラグは得られませんでした。\n"
"        `ruby_prog_init()` が関係するのかもしれません。\n"
"        また、コマンドラインオプションを解析せず、これを実現できるはずです。"

#. type: Footnote load
#: ../_posts/2012-01-01-embed.markdown:168
#, no-wrap
msgid ""
"[^load]: It looks like the function `rb_load_file()` should do this, but I\n"
"         haven't had any luck getting it to work."
msgstr "[^load]: `rb_load_file()` 関数でこれができそうですが、動かせた試しがありません。"

#. type: Title ##
#: ../_posts/2013-01-01-extend.markdown:1
#: ../_posts/2014-01-01-examples.markdown:35
#, no-wrap
msgid "Running C in Ruby"
msgstr "RubyでCを実行する"

#. type: Plain text
#: ../_posts/2013-01-01-extend.markdown:11
msgid ""
"Compiling C code to be loaded as a Ruby extension requires some fancy "
"compiler options. Ruby's [`mkmf` stdlib][mkmf] makes it easy to do this by "
"generating an appropriate makefile for you."
msgstr ""
"C言語のコードを、Rubyの拡張としてロードできるようにコンパイルするには、\n"
"ちょっとしたコンパイラのオプションが要ります。\n"
"Rubyの [`mkmf` 標準ライブラリ][mkmf]があれば、\n"
"適切なmakefileを生成してくれるので、\n"
"コンパイルが楽になります。"

#. type: Title ###
#: ../_posts/2013-01-01-extend.markdown:12
#, no-wrap
msgid "Preparation"
msgstr "準備"

#. type: Plain text
#: ../_posts/2013-01-01-extend.markdown:15
msgid ""
"First create the file `extconf.rb` in the same directory as your C code:"
msgstr ""
"まず、C言語のコードがあるのと同じディレクトリに `extconf.rb` というファイルを"
"つくります。"

#. type: Plain text
#: ../_posts/2013-01-01-extend.markdown:19
msgid ""
"{% highlight ruby %} {% include extend/ext/extconf.rb %} {% endhighlight %}"
msgstr ""
"{% highlight ruby %}\n"
"{% include extend/ext/extconf.rb %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2013-01-01-extend.markdown:22
msgid ""
"The preparation section should perform actions similar to the standard UNIX "
"[`configure` script][conf] e.g."
msgstr ""
"準備する部分では、標準的なUNIXでの [`configure` スクリプト][conf]でするような"
"ことをします。\n"
"例えば次のようなことです。"

#. type: Bullet: '* '
#: ../_posts/2013-01-01-extend.markdown:26
msgid "Check features of the current platform"
msgstr "現在のプラットフォームの特徴を確認する"

#. type: Bullet: '* '
#: ../_posts/2013-01-01-extend.markdown:26
msgid "Check for existence of required libraries and functions"
msgstr "必要なライブラリと関数があることを確認する"

#. type: Bullet: '* '
#: ../_posts/2013-01-01-extend.markdown:26
msgid "Check for programs needed for building"
msgstr "ビルドするのに必要なプログラムがあることを確認する"

#. type: Link reference
#: ../_posts/2013-01-01-extend.markdown:27
#, no-wrap
msgid "[conf]: http://en.wikipedia.org/wiki/Configure_script"
msgstr "[conf]: http://en.wikipedia.org/wiki/Configure_script"

#. type: Plain text
#: ../_posts/2013-01-01-extend.markdown:32
msgid ""
"The most common of these actions are provided by `mkmf` (but you have all of "
"Ruby at your disposal if you need it). For example, an extension which uses "
"SDL2 and needs to know how big `int`s are might call:"
msgstr ""
"よくある機能は `mkmf` で提供されます（でも、必要とあらばRubyをまったく使わな"
"くてもいいです）。\n"
"例えば、SDL2を使っていて、それとは別に `int` の大きさを知らなければいけないよ"
"うな拡張であれば、\n"
"こんな感じで呼び出すことになります。"

#. type: Plain text
#: ../_posts/2013-01-01-extend.markdown:36
msgid ""
"{% highlight ruby %} {% include extend/ext/exex.rb %} {% endhighlight %}"
msgstr ""
"{% highlight ruby %}\n"
"{% include extend/ext/exex.rb %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2013-01-01-extend.markdown:40
msgid ""
"`create_header` creates the file `extconf.h` containing preprocessor "
"definitions based on the results of the `mkmf` functions you called "
"previously. For this example, `extconf.h` might contain"
msgstr ""
"`create_header` は、それより前に呼んだ `mkmf` の関数の結果に基づいて、\n"
"前処理器の定義を含む `extconf.h` ファイルをつくります。\n"
"この例では `extconf.h` は次のような内容を含みます。"

#. type: Plain text
#: ../_posts/2013-01-01-extend.markdown:44
msgid "{% highlight c %} {% include extend/ext/exh.h %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include extend/ext/exh.h %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2013-01-01-extend.markdown:52
msgid ""
"This header should be included in your C files so that you can adapt your "
"code to a variety of platforms. Note that you can and should abort the "
"`extconf.rb` script if a `mkmf` function returns a value that indicates that "
"the build will fail. For example, if SDL2 is a _requirement_ of your "
"extension you should exit with some meaningful error message if "
"`have_library('SDL2')` returns `false`.  This is preferred to generating the "
"Makefile anyway and leaving the user with an opaque compiler error."
msgstr ""
"このヘッダはC言語のファイルに取り込むとよいでしょう。\n"
"そうすれば様々なプラットフォームでコードが使えるようになります。\n"
"気に留めておいてほしいことは、\n"
"`mkmf` 関数がビルドの失敗を示す値を返したら、\n"
"`extconf.rb` スクリプトを頓挫させられますし、そうするべきだということです。\n"
"例えば、ある拡張にSDL2が _必須_ であれば、\n"
"`have_library('SDL2')` が `false` を返したときは、\n"
"何らかの有意味なエラーメッセージを吐いて終了するようなスクリプトにしましょ"
"う。\n"
"とりあえずMakefileを生成して、\n"
"よくわからないコンパイルエラーで利用者を置き去りにするよりはマシです。"

#. type: Plain text
#: ../_posts/2013-01-01-extend.markdown:57
msgid ""
"`create_makefile` obviously creates the Makefile, but its argument is "
"especially important: it defines the entry point of your C code, the name of "
"the compiled library, and thus the argument for `require` in Ruby! This "
"should be the name of your extension."
msgstr ""
"`create_makefile` はもちろんMakefileをつくりますが、\n"
"その引数が特に大切です：\n"
"C言語のコードの入口を決めるものであり、\n"
"コンパイルされたライブラリの名前であり、\n"
"Rubyで `require` するときの引数でもあるのです！\n"
"これは拡張の名前であるべきです。"

#. type: Plain text
#: ../_posts/2013-01-01-extend.markdown:63
msgid ""
"You can modify a few of the generated Makefile variables by modifying the "
"corresponding globals in Ruby: `$CFLAGS`, `$CPPFLAGS`, and "
"`$LDFLAGS`[^glob].  You can also use the `$objs` global to define a list of "
"object files for the Makefile if its method of automatically generating "
"targets doesn't work for your extension."
msgstr ""
"生成されるMakefileの変数のいくつかを変更するには、\n"
"Rubyでの対応する大域変数を変更します：\n"
"`$CFLAGS` や `$CPPFLAGS` や `$LDFLAGS` がそうです。\n"
"自動的な生成方法がうまくいかないときは、\n"
"Makefileでのオブジェクトファイルのリストを `$objs` 大域変数で指定することもで"
"きます。"

#. type: Plain text
#: ../_posts/2013-01-01-extend.markdown:68
msgid ""
"All of the `mkmf` functions and their options are well-documented [online]"
"[mkmf]. In addition to the functions for generating `extconf.h`, there are a "
"variety of functions for handling different source file layouts, different "
"file dependencies, etc."
msgstr ""
"全ての `mkmf` 関数とそれぞれのオプションは[オンライン][mkmf]で充分に文書化さ"
"れています。\n"
"`extconf.h` を生成する関数に加えて、\n"
"また違ったソースファイルの配置や依存関係を制御する様々な関数があります。"

#. type: Link reference
#: ../_posts/2013-01-01-extend.markdown:69
#, no-wrap
msgid "[mkmf]: http://www.ruby-doc.org/stdlib/libdoc/mkmf/rdoc/MakeMakefile.html"
msgstr "[mkmf]: http://www.ruby-doc.org/stdlib/libdoc/mkmf/rdoc/MakeMakefile.html"

#. type: Title ###
#: ../_posts/2013-01-01-extend.markdown:71
#, no-wrap
msgid "Execution"
msgstr "実行"

#. type: Plain text
#: ../_posts/2013-01-01-extend.markdown:74
msgid "The rest couldn't be simpler"
msgstr "あとはもう、これ以上簡単になりようがありません"

#. type: Plain text
#: ../_posts/2013-01-01-extend.markdown:79
msgid ""
"{% highlight shell_session %} $ ruby extconf.rb $ make {% endhighlight %}"
msgstr ""
"{% highlight shell_session %}\n"
"$ ruby extconf.rb\n"
"$ make\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2013-01-01-extend.markdown:81
msgid ""
"[^argv]But of course that won't do anything without some C code to compile."
msgstr ""
"[^argv] もちろん、C言語のコードがコンパイルできないことには話が進まないですけ"
"どね。"

#. type: Title ##
#: ../_posts/2013-01-01-extend.markdown:82
#, no-wrap
msgid "Init"
msgstr "初期化"

#. type: Plain text
#: ../_posts/2013-01-01-extend.markdown:89
msgid ""
"In your C code, you'll want to include `ruby.h` to access the API. Other "
"than that the only requirement is to define a function for the Ruby VM to "
"call when your library is `require`d. The name of the function is determined "
"by the argument you passed to `create_makefile` in `extconf.rb`. We used "
"\"foobar\" in our example, so we'll create `foobar.c` containing"
msgstr ""
"C言語のコードでは `ruby.h` を含めてAPIを使えるようにしたいのではないでしょう"
"か。\n"
"その他には、 `require` したときにRubyの仮想機械がライブラリを呼べるように、\n"
"関数を定義するだけでよいです。\n"
"関数の名前は、 `extconf.rb` で `create_makefile` に渡した引数で決まります。\n"
"ここまでの例で `\"foobar\"` を使ってきたので、\n"
"次の内容の `foobar.c` ファイルをつくります。"

#. type: Plain text
#: ../_posts/2013-01-01-extend.markdown:93
msgid "{% highlight c %} {% include extend/ext/foobar.c %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include extend/ext/foobar.c %}\n"
"{% endhighlight %}"

#. type: Title ###
#: ../_posts/2013-01-01-extend.markdown:94
#, no-wrap
msgid "Filenames"
msgstr "ファイル名"

#. type: Plain text
#: ../_posts/2013-01-01-extend.markdown:101
msgid ""
"If your extension has only a single C file, you should name it after your "
"extension as we did above. If your extensions has multiple C files _do not_ "
"name any of them after your extension. This is because the Makefile may "
"generate a `.o` file named after your extension for the linking stage, which "
"would cause a conflict if you also have a `.c` file which compiles to that "
"filename."
msgstr ""
"拡張に1つのC言語のファイルだけしかないなら、\n"
"さっきやったように拡張の名前と同じファイル名にしましょう。\n"
"逆に複数のC言語のファイルからなる場合、\n"
"拡張に _同じ名前を使わない_ ようにしましょう。\n"
"リンクする段階でMakefileが拡張名と同じ `.o` ファイルを生成すると、\n"
"それと同じファイル名にコンパイルされる `.c` ファイルがある場合に衝突してしま"
"うからです。"

#. type: Plain text
#: ../_posts/2013-01-01-extend.markdown:104
msgid ""
"Also avoid naming any files `conftest.c` as this file may be written to by "
"`mkmf`."
msgstr ""
"また、 `conftest.c` というファイル名も、 `mkmf` によって書き込まれるかもしれ"
"ないので避けます。"

#. type: Plain text
#: ../_posts/2013-01-01-extend.markdown:111
msgid ""
"Now make should compile a `.so` (or some other library) file which you can "
"`require` in Ruby. You can fill in your `Init` function with plain C code, "
"but you'll probably want to go back and learn about the [C API](../c) to do "
"more interesting stuff."
msgstr ""
"これにてmakeで`.so`（またはその他のライブラリ）にコンパイルして、Rubyで"
"`require`できるようになりました。\n"
"純粋なC言語のコードで`Init`関数を実装していくこともできますが、たぶんいったん"
"戻って、もっと面白いことをするために[C API](../c)を学ばれるのではないでしょう"
"か。"

#. type: Title ##
#: ../_posts/2013-01-01-extend.markdown:112
#, no-wrap
msgid "Gem"
msgstr "Gem"

#. type: Plain text
#: ../_posts/2013-01-01-extend.markdown:118
msgid ""
"After you've got your extension working nicely, you may want to bundle it up "
"as an easily distributable Ruby gem. rubygems.org has a [detailed guide]"
"[rbg] on creating gems, but as far as C extensions go you just need to tell "
"the spec about `extconf.rb`[^rbg]:"
msgstr ""
"いい感じに拡張が動くようになったら、簡単に配布できるRubyのgemとしてまとめたい"
"はずです。\n"
"rubygems.orgにはgemをつくる上での[詳細な手引き][rbg]がありますが、C拡張に関し"
"て言えば `extconf.rb` についてspecに記すだけでよいです[^rbg]。"

#. type: Plain text
#: ../_posts/2013-01-01-extend.markdown:122
msgid ""
"{% highlight ruby %} {% include extend/foobar.gemspec %} {% endhighlight %}"
msgstr ""
"{% highlight ruby %}\n"
"{% include extend/foobar.gemspec %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2013-01-01-extend.markdown:125
msgid ""
"If your gem includes multiple independent extensions, you can organize them "
"in subdirectories of `ext/` and pass all of the `extconf.rb`s to the spec."
msgstr ""
"gemが複数の拡張に依存していたら、\n"
"`ext/` のサブディレクトリにそれぞれ固めて、\n"
"specに各々の `extconf.rb` を記します。"

#. type: Link reference
#: ../_posts/2013-01-01-extend.markdown:126
#, no-wrap
msgid "[rbg]: http://guides.rubygems.org/make-your-own-gem/"
msgstr "[rbg]: http://guides.rubygems.org/make-your-own-gem/"

#. type: Footnote glob
#: ../_posts/2013-01-01-extend.markdown:130
#, no-wrap
msgid "[^glob]: Check the [official documentation][globals]."
msgstr "[^glob]: [公式の文書][globals]をご確認ください。"

#. type: Footnote argv
#: ../_posts/2013-01-01-extend.markdown:132
#, no-wrap
msgid ""
"[^argv]: The official documentation [hints][makefile] that `mkmf` parses certain\n"
"         command line flags e.g.  `--vendor`. But I can't find this documented\n"
"         anywhere."
msgstr ""
"[^argv]: 公式の文書は、`--vendor` のようなコマンドライン引数を `mkmf` がパースできると[仄めかしている][makefile] ようです。\n"
"         でも、このことはどこにも文書化されていないようです。"

# 空白を入れていないのは意図的です
#. type: Footnote rbg
#: ../_posts/2013-01-01-extend.markdown:136
#, no-wrap
msgid "[^rbg]: [http://guides.rubygems.org/gems-with-extensions/](http://guides.rubygems.org/gems-with-extensions/)"
msgstr "[^rbg]: [http://guides.rubygems.org/gems-with-extensions/](http://guides.rubygems.org/gems-with-extensions/)"

# 空白を空けないことによって意図しない改行を回避しています
#. type: Link reference
#: ../_posts/2013-01-01-extend.markdown:138
#, no-wrap
msgid "[globals]: https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-Prepare+extconf.rb"
msgstr "[globals]: https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-Prepare+extconf.rb"

# 空白を空けないことによって意図しない改行を回避しています
#. type: Link reference
#: ../_posts/2013-01-01-extend.markdown:139
#, no-wrap
msgid "[makefile]: https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-Generate+Makefile"
msgstr "[makefile]: https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-Generate+Makefile"

#. type: Plain text
#: ../_posts/2014-01-01-examples.markdown:14
msgid ""
"This example is a simple little game of tag. In the game there are two "
"squares: the blue square is controlled using the arrow keys on the keyboard "
"while the red square is controlled by a Ruby script. To make this work, "
"we'll use the C API to define a little Ruby API that the script can access, "
"and every couple of frames we'll call a method defined in the Ruby script "
"and pass objects encapsulating the data for the two squares."
msgstr ""
"この例はtagという単純で小さなゲームです。このゲームには2升あります。青升は"
"キーボード上の矢印キーを使って操作しますが赤升はRubyのスクリプトで操作しま"
"す。動かすためにC APIを使ってスクリプトがアクセスできる小さなRuby APIを定義"
"し、全てのフレーム毎にRubyスクリプトで定義されているメソッドを呼び出し2升用の"
"データをカプセル化するオブジェクトを渡します。"

#. type: Plain text
#: ../_posts/2014-01-01-examples.markdown:16
msgid "The Ruby script can look something like this:"
msgstr "Rubyスクリプトは以下のような見た目をしています。"

#. type: Plain text
#: ../_posts/2014-01-01-examples.markdown:20
msgid "{% highlight ruby %} {% include examples/ai.rb %} {% endhighlight %}"
msgstr ""
"{% highlight ruby %}\n"
"{% include examples/ai.rb %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2014-01-01-examples.markdown:24
msgid ""
"The C code uses SDL2 for graphics and input and uses `stat()` (which may not "
"be very portable) to hot-reload the AI script whenever the file is changed . "
"Here's `tag.c`:"
msgstr ""
"CのコードはグラフィックにSDL2と入力を使い、ファイルの変更に合わせてAIスクリプ"
"トが即座に再読み込みされるよう`stat()`（あまり可搬性は高くなさそうですが）を"
"使います。以下は`tag.c`です。"

#. type: Plain text
#: ../_posts/2014-01-01-examples.markdown:28
msgid "{% highlight c %} {% include examples/tag.c %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include examples/tag.c %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2014-01-01-examples.markdown:30
msgid "The Makefile is nothing special:"
msgstr "Makefileは何ということはありません。"

#. type: Plain text
#: ../_posts/2014-01-01-examples.markdown:34
msgid "{% highlight make %} {% include examples/Makefile %} {% endhighlight %}"
msgstr ""
"{% highlight make %}\n"
"{% include examples/Makefile %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2014-01-01-examples.markdown:42
msgid ""
"This example is a Ruby C extension that wraps the [GMP][gmp] C library for "
"arbitrary precision arithmetic. This is far from a complete example: it only "
"wraps the integer functions, implements only the basic functionality of the "
"library, and doesn't bother nicely integrating with Ruby's existing numeric "
"types. If you want a _really_ full example, check out the [GMP gem][gem]."
msgstr ""
"この例は任意精度計算用の[GMP][gmp] Cライブラリを包むRubyのC拡張です。これは完"
"全な例からはほど遠いものです。整数関数のみを包み、ライブラリの基本的な機能の"
"みを実装しています。またRubyの既存の数値型といい感じに統合することに心を砕い"
"てはいません。もし _本当の_ 完全な例が欲しければ [GMP gem][gem]をご確認くださ"
"い。"

#. type: Link reference
#: ../_posts/2014-01-01-examples.markdown:43
#, no-wrap
msgid "[gmp]: https://gmplib.org/"
msgstr ""

#. type: Link reference
#: ../_posts/2014-01-01-examples.markdown:44
#, no-wrap
msgid "[gem]: https://github.com/srawlins/gmp"
msgstr "[gem]: https://github.com/srawlins/gmp"

#. type: Plain text
#: ../_posts/2014-01-01-examples.markdown:47
msgid "Everything is in `gmp.c` where we define our `GMP::Integer` class:"
msgstr "全ては`GMP::Integer`クラスを定義している`gmp.c`にあります。"

#. type: Plain text
#: ../_posts/2014-01-01-examples.markdown:51
msgid "{% highlight c %} {% include examples/ext/gmp.c %} {% endhighlight %}"
msgstr ""
"{% highlight c %}\n"
"{% include examples/ext/gmp.c %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2014-01-01-examples.markdown:53
msgid "The `extconf.rb` is really simple."
msgstr "`extconf.rb`は本当に単純です。"

#. type: Plain text
#: ../_posts/2014-01-01-examples.markdown:57
msgid ""
"{% highlight ruby %} {% include examples/ext/extconf.rb %} {% endhighlight %}"
msgstr ""
"{% highlight ruby %}\n"
"{% include examples/ext/extconf.rb %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2014-01-01-examples.markdown:59
msgid "And now you can finally find out what your name means in base 62:"
msgstr "そしてこれで遂に基数62で自分の名前が何になるのかがわかります。"

#. type: Plain text
#: ../_posts/2014-01-01-examples.markdown:63
msgid ""
"{% highlight ruby %} {% include examples/gmp_ex.rb %} {% endhighlight %}"
msgstr ""
"{% highlight ruby %}\n"
"{% include examples/gmp_ex.rb %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../_posts/2014-01-01-examples.markdown:70
msgid ""
"For this example I tried to do everything in C, but practically that isn't "
"necessary (or desirable). If one of your C methods just calls a bunch of API "
"functions (like `to_i` and `==` in the example), you're probably only saving "
"yourself a couple CPU cycles compared to implementing the method in Ruby. "
"And of course that comes at the cost of needing to spend more time writing C "
"and less time writing Ruby. 😀"
msgstr ""
"この例ではCにおける全てを試そうとしましたが、実際は必要ではないです（し望まし"
"くもないです）。Cのメソッドの中に（例にある`to_i`や`==`のような）単に有象無象"
"のAPI関数を呼ぶだけのものがあるなら、恐らくRubyでメソッドを実装することに比較"
"して数CPUサイクル分しか稼いでいないでしょう。そしてもちろんCを書く時間が増え"
"てRubyを書く時間が減ってしまうツケを払うことになります。😀"

#. type: Plain text
#: ../_posts/2014-01-01-examples.markdown:75
msgid ""
"A common convention when writing extensions is to only implement the "
"\"meat\" of the extension in C and to do everything else in a regular Ruby "
"script that pulls in the compiled library. For example, we could have "
"written a `gmp.rb` script to significantly simplify our extension:"
msgstr ""
"拡張を書くときの共通する慣習はCでは拡張の「肝」だけを実装し、残りを通常のRuby"
"スクリプトでやってコンパイルされたライブラリに取り込むことです。\n"
"例えば`gmp.rb`スクリプトを書いて拡張を著しく単純にできます。"

#. type: Plain text
#: ../_posts/2014-01-01-examples.markdown:78
msgid "{% highlight ruby %} {% include examples/gmp.rb %} {% endhighlight %}"
msgstr ""
"{% highlight ruby %}\n"
"{% include examples/gmp.rb %}\n"
"{% endhighlight %}"

#. type: Plain text
#: ../README.md:3
msgid ""
"This is the source for my online guide to Ruby's C API. Visit the live site "
"[here][io]."
msgstr ""
"これはRubyのC APIのオンラインの手引きのソースです。実際のサイトは[こちら][io]"
"をご覧ください。"

#. type: Link reference
#: ../README.md:4
#, no-wrap
msgid "[io]: http://silverhammermba.github.io/emberb"
msgstr "[io]: http://silverhammermba.github.io/emberb"

#. type: Title #
#: ../README.md:6
#, no-wrap
msgid "Why I'm Making This Guide"
msgstr "なぜこの手引きを作ったか"

#. type: Plain text
#: ../README.md:11
msgid ""
"Oh my god there are so [many][g] [freaking][f] [guides][e] [to][d] [Ruby's]"
"[c] [C][b] [API][a]. Why make another one? Because from what I've seen of "
"the others:"
msgstr ""
"なんということでしょう、[Rubyの][c]、[Cの][b]、[API][a]、[についての][d]、[多"
"くの][g]、[興味を唆られる][f]、[手引き][e]が、こんなにもあります。なぜ別のも"
"のを作るのでしょうか。それは筆者が次のようなことに直面してきたからです。"

#. type: Bullet: '* '
#: ../README.md:18
msgid "Most of them are outdated"
msgstr "ほとんどが時代遅れである"

#. type: Bullet: '* '
#: ../README.md:18
msgid "Most fail to cover different approaches when they are available"
msgstr "ほとんどが、別の解決策が利用できるときも、それらを押さえられていない"

#. type: Bullet: '* '
#: ../README.md:18
msgid "Many cover only very specific use-cases"
msgstr "多くのものがかなり限定的な用例のみを押さえている"

#. type: Bullet: '* '
#: ../README.md:18
msgid "Many have bad recommendations"
msgstr "多くのものにあまりお勧めできない点がある"

#. type: Bullet: '* '
#: ../README.md:18
msgid "Many fail to explain _when_ and _why_ things are needed"
msgstr "多くが _いつ_ そして _なぜ_ それが必要なのかを説明できていない"

#. type: Bullet: '* '
#: ../README.md:18
msgid ""
"Many try to be exhaustive rather getting the reader up and running quickly"
msgstr ""
"多くが網羅的であろうとするがあまり、読者が手早く始められるようになっていない"

#. type: Plain text
#: ../README.md:22
msgid ""
"And it struck me that all of these problems come from these guides largely "
"being on media that do not promote community-driven updates. So I'm writing "
"a new guide that doesn't suck and is on Github so you too can help make it "
"not suck."
msgstr ""
"そして筆者が衝撃を受けたのはこれらの手引きによるこうした問題の全ては、コミュ"
"ニティ駆動の更新を推進しないメディアから出ていることが多いということでし"
"た。\n"
"そのためこうした詰まらないことが起きない新しい手引きを書き、Githubに置くこと"
"で、詰まらないことにならないよう読者のあなたが手助けできるようにしてあるので"
"す。"

#. type: Link reference
#: ../README.md:23
#, no-wrap
msgid "[a]: http://clalance.blogspot.com/2011/01/writing-ruby-extensions-in-c-part-1.html"
msgstr ""

#. type: Link reference
#: ../README.md:24
#, no-wrap
msgid "[b]: https://raw.githubusercontent.com/ruby/ruby/master/doc/extension.rdoc"
msgstr "[b]: https://raw.githubusercontent.com/ruby/ruby/master/doc/extension.rdoc"

#. type: Link reference
#: ../README.md:25
#, no-wrap
msgid "[c]: http://blog.jacius.info/ruby-c-extension-cheat-sheet/"
msgstr ""

#. type: Link reference
#: ../README.md:26
#, no-wrap
msgid "[d]: http://hugopl.github.io/2014/04/09/Embedding-Ruby-2.1-into-a-Cpp-application.html"
msgstr ""

#. type: Link reference
#: ../README.md:27
#, no-wrap
msgid "[e]: https://gist.github.com/jefftrull/1305431"
msgstr ""

#. type: Link reference
#: ../README.md:28
#, no-wrap
msgid "[f]: http://metaeditor.sourceforge.net/embed/"
msgstr ""

#. type: Link reference
#: ../README.md:29
#, no-wrap
msgid "[g]: http://ruby-doc.com/docs/ProgrammingRuby/html/ext_ruby.html"
msgstr ""

#. type: Yaml Front Matter Hash Value: layout
#: ../index.markdown:1
#, no-wrap
msgid "default"
msgstr "default"

#. type: Yaml Front Matter Hash Value: title
#: ../index.markdown:1
#, no-wrap
msgid "The Definitive Guide to Ruby's C API"
msgstr "RubyのC APIの手引き 決定版"

#. type: Plain text
#: ../index.markdown:10
#, no-wrap
msgid ""
"<div class=\"container\">\n"
"<div class=\"jumbotron\">\n"
"This site is a complete, practical guide to using Ruby's C API. Get started\n"
"[here][start].\n"
msgstr ""
"<div class=\"container\">\n"
"<div class=\"jumbotron\">\n"
"本サイトはRubyのC APIを使うための完全で実践的な手引きです。\n"
"[こちら][start]から始めてください。\n"

#. type: Plain text
#: ../index.markdown:17
#, no-wrap
msgid ""
"This site is generated from a [Github repo][repo]. If something isn't working\n"
"the way I described it or you notice a gaping hole in the guide, please [submit\n"
"an issue][iss]. If you know a better way of doing something than I do, please\n"
"consider [submitting a pull request][pull].\n"
"</div>\n"
"</div>\n"
msgstr ""
"本サイトは[Githubのリポジトリ][repo]から生成されました。\n"
"何か説明した通りに動かなかったり手引きの不備に気付いたら[チケットを立てて][iss]ください。\n"
"ここで書かれているものより良い方法を知っていたら[プルリクエストを送ることを][pull]ご検討ください。\n"
"</div>\n"
"</div>\n"

#. type: Link reference
#: ../index.markdown:18
#, no-wrap
msgid "[start]: c"
msgstr "[start]: c"

#. type: Link reference
#: ../index.markdown:19
#, no-wrap
msgid "[repo]: https://github.com/silverhammermba/emberb"
msgstr "[repo]: https://github.com/silverhammermba/emberb"

#. type: Link reference
#: ../index.markdown:20
#, no-wrap
msgid "[iss]: https://github.com/silverhammermba/emberb/issues/new"
msgstr "[iss]: https://github.com/silverhammermba/emberb/issues/new"

#. type: Link reference
#: ../index.markdown:21
#, no-wrap
msgid "[pull]: https://github.com/silverhammermba/emberb/pulls"
msgstr "[pull]: https://github.com/silverhammermba/emberb/pulls"

#. type: comment
#: ../_includes/embed/simple.c:5
#, no-wrap
msgid "construct the VM"
msgstr "VMを構築"

#. type: comment
#: ../_includes/embed/simple.c:8 ../_includes/embed/advanced.c:11
#, no-wrap
msgid "Ruby goes here"
msgstr "Rubyはここに入る"

#. type: comment
#: ../_includes/embed/simple.c:10
#, no-wrap
msgid "destruct the VM"
msgstr "VMを解体"

#. type: comment
#: ../_includes/embed/advanced.c:7
#, no-wrap
msgid "run code without Ruby"
msgstr "Rubyなしのコードを走らせる"

#. type: comment
#: ../_includes/embed/advanced.c:13
#, no-wrap
msgid "XXX rescue exceptions here!!!"
msgstr "XXX 絶対にここで例外をrescueすること"

#. type: comment
#: ../_includes/embed/options.c:18
#, no-wrap
msgid "handle exception, perhaps"
msgstr "例外に対処します。ないとは思いますが"

#. type: comment
#: ../_includes/examples/tag.c:11
#, no-wrap
msgid "constants"
msgstr "定数"

#. type: comment
#: ../_includes/examples/tag.c:16
#, no-wrap
msgid "for position and direction"
msgstr "位置と方向用"

#. type: comment
#: ../_includes/examples/tag.c:23
#, no-wrap
msgid "for the player and their opponent"
msgstr "プレーヤーと敵用"

#. type: double-slash-comment
#: ../_includes/examples/tag.c:28
#, no-wrap
msgid "top speed in pixels/millisecond"
msgstr "ピクセル毎ミリ秒での最高速度"

#. type: comment
#: ../_includes/examples/tag.c:32
#, no-wrap
msgid "wrapper for passing AI actor with AI script metadata"
msgstr "AIのアクターにAIのスクリプトのメタデータを渡すための梱包"

#. type: comment
#: ../_includes/examples/tag.c:42
#, no-wrap
msgid "set AI error state and possibly print exception"
msgstr "AIのエラー状態を設定し、例外を印字する可能性があります"

#. type: comment
#: ../_includes/examples/tag.c:51
#, no-wrap
msgid "print exception"
msgstr "例外を印字"

#. type: comment
#: ../_includes/examples/tag.c:58
#, no-wrap
msgid "clear AI error state"
msgstr "AIのエラー状態を消去"

#. type: comment
#: ../_includes/examples/tag.c:65
#, no-wrap
msgid "try to (re)load AI script"
msgstr "（再）読み込みしたAIスクリプトを試す"

#. type: comment
#: ../_includes/examples/tag.c:68
#, no-wrap
msgid "get script modification time"
msgstr "スクリプトの変更日時を得る"

#. type: comment
#: ../_includes/examples/tag.c:79
#, no-wrap
msgid "nothing to do if we've already loaded the script and it hasn't been updated"
msgstr "既にスクリプトを読み込んでおり更新されていなければ、することはありません"

#. type: comment
#: ../_includes/examples/tag.c:98
#, no-wrap
msgid "for rescuing exceptions in the AI script"
msgstr "AIのスクリプト中で例外をrescueするためのもの"

#. type: comment
#: ../_includes/examples/tag.c:106
#, no-wrap
msgid "run the AI script if possible"
msgstr "可能であればAIのスクリプトを走らせる"

#. type: comment
#: ../_includes/examples/tag.c:117
#, no-wrap
msgid "move actor after ms time has elapsed"
msgstr "msだけ時間が経ったらアクターを動かす"

#. type: comment
#: ../_includes/examples/tag.c:122
#, no-wrap
msgid "no movement"
msgstr "動きなし"

#. type: comment
#: ../_includes/examples/tag.c:125
#, no-wrap
msgid "allow actor to move slower than speed, but not faster"
msgstr "アクターがspeedに比べて遅くはあっても速くならない程度に動けるようにします"

#. type: comment
#: ../_includes/examples/tag.c:131
#, no-wrap
msgid "clamp position to screen"
msgstr "位置が画面内に来るよう切り詰めます"

#. type: comment
#: ../_includes/examples/tag.c:142
#, no-wrap
msgid "draw an actor as a colored box"
msgstr "アクターを色付きの箱として描画します"

#. type: comment
#: ../_includes/examples/tag.c:150
#, no-wrap
msgid "methods for the API we're defining for the AI script"
msgstr "AIのスクリプト用に定義する、API用のメソッド"

#. type: comment
#: ../_includes/examples/tag.c:151
#, no-wrap
msgid "time - returns total elapsed time in milliseconds"
msgstr "time - 合計の消費時間をミリ秒で返します"

#. type: comment
#: ../_includes/examples/tag.c:157
#, no-wrap
msgid "we don't need any mark/free/GC/etc. see later comment when we define the class"
msgstr "mark/free/GCなどは何ら必要ありません。クラスを定義するところにある後述のコメントを参照"

#. type: comment
#: ../_includes/examples/tag.c:160
#, no-wrap
msgid "Actor#pos - returns screen position x, y in pixels"
msgstr "Actor#pos - 画面の位置x, yをピクセルで返します"

#. type: comment
#: ../_includes/examples/tag.c:169
#, no-wrap
msgid "Actor#dir - returns last movement direction x, y. each is in the range (-1..1)"
msgstr "Actor#dir - 直近の動く方向x, yを返します。それぞれ (-1..1) の範囲内です"

#. type: comment
#: ../_includes/examples/tag.c:178
#, no-wrap
msgid "Actor#move - set next movement direction. x, y as in Actor#pos"
msgstr "Actor#move - 次の動く方向を設定します。x, yはActor#posと同様です"

#. type: comment
#: ../_includes/examples/tag.c:195
#, no-wrap
msgid "start Ruby TODO is this redundant?"
msgstr "Rubyを開始 TODO これは余計だろうか"

#. type: comment
#: ../_includes/examples/tag.c:201
#, no-wrap
msgid "set a nicer script name than <main>"
msgstr "<main>よりもいい名前を設定"

#. type: comment
#: ../_includes/examples/tag.c:204
#, no-wrap
msgid "define our own little API for use in the AI script"
msgstr "AIスクリプトで使う小振りの独自APIを定義"

#. type: comment
#: ../_includes/examples/tag.c:207
#, no-wrap
msgid "Actor will wrap struct actor for passing to Ruby"
msgstr "ActorはRubyに渡す上で構造体actorを梱包します"

#. type: multiline-comment
#: ../_includes/examples/tag.c:213
#, no-wrap
msgid ""
"\n"
" Notice that even though Actor wraps C data, we didn't define an\n"
" allocation or free function. That's because we're going to create all\n"
" the actors in C and expose them to Ruby. However we should make sure\n"
" that Ruby can't create new Actors, because they'll contain invalid data\n"
" pointers\n"
msgstr ""
"\n"
" ActorがCのデータを梱包していたとしても、割り当てや解放関数を定義しなかった点に注目です。\n"
" これは全てのアクターをCで作り、Rubyに露出させるつもりだからです。\n"
" しかしRubyが新しいActorを作れてしまうと不当なデータポインタを含んでしまうので、\n"
" Rubyがそうできないようにすべきです。\n"

#. type: comment
#: ../_includes/examples/tag.c:222
#, no-wrap
msgid "start SDL"
msgstr "SDLを開始"

#. type: comment
#: ../_includes/examples/tag.c:225
#, no-wrap
msgid "create window"
msgstr "ウィンドウを作成"

#. type: comment
#: ../_includes/examples/tag.c:240
#, no-wrap
msgid "create renderer"
msgstr "描画子を作成"

#. type: comment
#: ../_includes/examples/tag.c:249
#, no-wrap
msgid "create actors"
msgstr "アクターを作成"

#. type: comment
#: ../_includes/examples/tag.c:270
#, no-wrap
msgid "create Ruby objects for actors"
msgstr "アクター用のRubyオブジェクトを作成"

#. type: comment
#: ../_includes/examples/tag.c:271
#, no-wrap
msgid "we can use NULL for the free function because the data are on the stack"
msgstr "データがスタックにあるので解放関数にはNULLが使えます"

#. type: comment
#: ../_includes/examples/tag.c:275
#, no-wrap
msgid "don't allow the player to be moved via the AI script"
msgstr "プレーヤーがAIスクリプトを介して動くことがないようにします"

#. type: comment
#: ../_includes/examples/tag.c:278
#, no-wrap
msgid "set up timing"
msgstr "タイミングを取る"

#. type: comment
#: ../_includes/examples/tag.c:279
#, no-wrap
msgid "run AI at 30fps"
msgstr "30fpsでAIを走らせる"

#. type: comment
#: ../_includes/examples/tag.c:285
#, no-wrap
msgid "start up AI"
msgstr "AIを起動"

#. type: comment
#: ../_includes/examples/tag.c:289
#, no-wrap
msgid "for player input"
msgstr "プレーヤーの入力用"

#. type: comment
#: ../_includes/examples/tag.c:292
#, no-wrap
msgid "main loop"
msgstr "本体の繰り返し"

#. type: comment
#: ../_includes/examples/tag.c:297
#, no-wrap
msgid "update timers"
msgstr "タイマーを更新"

#. type: comment
#: ../_includes/examples/tag.c:303
#, no-wrap
msgid "event handling"
msgstr "イベントの制御"

#. type: comment
#: ../_includes/examples/tag.c:320
#, no-wrap
msgid "player movement"
msgstr "プレーヤーの動作"

#. type: comment
#: ../_includes/examples/tag.c:333
#, no-wrap
msgid "AI movement"
msgstr "AIの動作"

#. type: comment
#: ../_includes/examples/tag.c:342
#, no-wrap
msgid "game step"
msgstr "ゲームを停止"

#. type: comment
#: ../_includes/examples/tag.c:346
#, no-wrap
msgid "render"
msgstr "描画"

#. type: comment
#: ../_includes/examples/tag.c:355
#, no-wrap
msgid "let CPU rest"
msgstr "CPUを休止"

#. type: comment
#: ../_includes/examples/tag.c:359
#, no-wrap
msgid "clean up"
msgstr "整頓"

#. type: comment
#: ../_includes/examples/tag.c:363
#, no-wrap
msgid "stop SDL"
msgstr "SDLを停止"

#. type: comment
#: ../_includes/examples/tag.c:366
#, no-wrap
msgid "stop Ruby"
msgstr "Rubyを停止"

#. type: multiline-comment
#: ../_includes/examples/ext/gmp.c:5
#, no-wrap
msgid ""
"\n"
" we're going to be unwrapping VALUEs to get the C data A LOT.\n"
" It's not that hard, but it gets tedious. This lets us go\n"
" straight from a VALUE to the underlying data\n"
msgstr ""
"\n"
" Cのデータを得るためにVALUEを開封することがしょっちゅうになるでしょう。\n"
" そこまで大変ではないですが、面倒になってきます。\n"
" これがあるとVALUEから奥底にあるデータに直通できるようにするものです。\n"

#. type: multiline-comment
#: ../_includes/examples/ext/gmp.c:14
#, no-wrap
msgid ""
"\n"
" we're also going to be pretty strict about accepting only\n"
" objects of our GMP::Integer type, so this will be a frequent test\n"
msgstr ""
"\n"
" またGMP::Integer型のオブジェクトのみ受け付けるように大変厳密にしていきます。\n"
" なのでこれを頻繁に検査します。\n"

#. type: comment
#: ../_includes/examples/ext/gmp.c:22
#, no-wrap
msgid "it's nice to have these as globals for easy access in methods"
msgstr "メソッドで簡単にアクセスできるので、これらを大域的にしているのはいいことです"

#. type: comment
#: ../_includes/examples/ext/gmp.c:26
#, no-wrap
msgid "function to free data wrapped in GMP::Integer"
msgstr "GMP::Integerに梱包されたデータを解放する関数"

#. type: comment
#: ../_includes/examples/ext/gmp.c:29
#, no-wrap
msgid "free memory allocated by GMP"
msgstr "GMPにより割り当てられたメモリを解放"

#. type: comment
#: ../_includes/examples/ext/gmp.c:39
#, no-wrap
msgid "probably should set .dsize but I don't know how to write it for mpz_t..."
msgstr "恐らく.dsizeを設定すべきなのでしょうがどうmpz_tに書き込めばいいか分かりません……"

#. type: comment
#: ../_includes/examples/ext/gmp.c:44
#, no-wrap
msgid "GMP::Integer.allocate"
msgstr "GMP::Integer.allocate"

#. type: comment
#: ../_includes/examples/ext/gmp.c:48
#, no-wrap
msgid "GMP initialization"
msgstr "GMPの初期化"

#. type: multiline-comment
#: ../_includes/examples/ext/gmp.c:54
#, no-wrap
msgid ""
" GMP::Integer#initialize\n"
"\n"
" Sets internal mpz_t using first argument\n"
"\n"
" If the first argument is a String, you can supply a second Fixnum argument\n"
" as the base for interpreting the String. The default base of 0 means that\n"
" the base will be determined by the String's prefix.\n"
msgstr ""
" GMP::Integer#initialize\n"
"\n"
" 最初の引数を使って内部のmpz_tを設定します\n"
"\n"
" 最初の引数が文字列なら2つ目のFixnum引数を文字列を解釈するための基数として与えられます。\n"
" 既定の0の基数は基数がStringの前置詞から決定することを意味しています。\n"

#. type: comment
#: ../_includes/examples/ext/gmp.c:66 ../_includes/examples/ext/gmp.c:137
#, no-wrap
msgid "check for optional base argument"
msgstr "基数のオプション引数を確認"

#. type: comment
#: ../_includes/examples/ext/gmp.c:71
#, no-wrap
msgid "base only makes sense with a string"
msgstr "基数は文字列のみが認識されます"

#. type: comment
#: ../_includes/examples/ext/gmp.c:77 ../_includes/examples/ext/gmp.c:145
#, no-wrap
msgid "GMP only accepts certain bases"
msgstr "GMPは特定の基数のみを受け付けます"

#. type: comment
#: ../_includes/examples/ext/gmp.c:89
#, no-wrap
msgid "easy case"
msgstr "簡単な場合"

#. type: comment
#: ../_includes/examples/ext/gmp.c:93
#, no-wrap
msgid "this is the easiest way to safely convert"
msgstr "これが安全に変換する上で一番簡単な方法です"

#. type: comment
#: ../_includes/examples/ext/gmp.c:101
#, no-wrap
msgid "copy another GMP::Integer"
msgstr "別のGMP::Integerを複製"

#. type: comment
#: ../_includes/examples/ext/gmp.c:110
#, no-wrap
msgid "break intentionally omitted"
msgstr "breakは意図的に省かれています"

#. type: comment
#: ../_includes/examples/ext/gmp.c:116
#, no-wrap
msgid "assign"
msgstr "代入"

#. type: multiline-comment
#: ../_includes/examples/ext/gmp.c:129
#, no-wrap
msgid ""
" GMP::Integer#to_s\n"
"\n"
" Accepts an optional Fixnum argument for the base of the String (default 10)\n"
msgstr ""
" GMP::Integer#to_s\n"
"\n"
" Stringの基数（既定は10）のためにオプションのFixnum引数を受け付けます\n"

#. type: comment
#: ../_includes/examples/ext/gmp.c:152
#, no-wrap
msgid "get C string from GMP"
msgstr "GMPからCの文字列を得る"

#. type: comment
#: ../_includes/examples/ext/gmp.c:156
#, no-wrap
msgid "create Ruby String"
msgstr "Rubyの文字列を作成"

#. type: comment
#: ../_includes/examples/ext/gmp.c:159
#, no-wrap
msgid "free memory"
msgstr "メモリを解放"

#. type: comment
#: ../_includes/examples/ext/gmp.c:165
#, no-wrap
msgid "GMP::Integer#to_i"
msgstr "GMP::Integer#to_i"

#. type: comment
#: ../_includes/examples/ext/gmp.c:168
#, no-wrap
msgid "safest and easiest way to convert is to call to_s.to_i"
msgstr "最も安全かつ簡単に変換する方法はto_s.to_iを呼び出すことです"

#. type: comment
#: ../_includes/examples/ext/gmp.c:172
#, no-wrap
msgid "GMP::Integer#<=>"
msgstr "GMP::Integer#<=>"

#. type: comment
#: ../_includes/examples/ext/gmp.c:180
#, no-wrap
msgid "shortcut for identical objects"
msgstr "同値なオブジェクトのための早道"

#. type: comment
#: ../_includes/examples/ext/gmp.c:187
#, no-wrap
msgid "GMP::Integer#=="
msgstr "GMP::Integer#=="

#. type: comment
#: ../_includes/examples/ext/gmp.c:190
#, no-wrap
msgid "for GMP::Integers, use <=>"
msgstr "GMP::Integerについては<=>を使用"

#. type: comment
#: ../_includes/examples/ext/gmp.c:197
#, no-wrap
msgid "GMP::Integer#+"
msgstr "GMP::Integer#+"

#. type: multiline-comment
#: ../_includes/examples/ext/gmp.c:205
#, no-wrap
msgid ""
"\n"
" we need a new GMP::Integer to store the result, but there's no need\n"
" to actually use the `new` method\n"
msgstr ""
"\n"
" 結果を補完するために新しいGMP::Integerが必要ですが、\n"
" 実際に`new`メソッドを使う必要は全くありません。\n"

#. type: comment
#: ../_includes/examples/ext/gmp.c:216
#, no-wrap
msgid "multiplication and subtraction would be defined nearly identically"
msgstr "乗算と減算はほぼ同様に定義されるでしょう"

#. type: comment
#: ../_includes/examples/ext/gmp.c:218
#, no-wrap
msgid "GMP::Integer#-@"
msgstr "GMP::Integer#-@"

#. type: comment
#: ../_includes/examples/ext/gmp.c:223
#, no-wrap
msgid "bypassing `new` as in the + method"
msgstr "+メソッド中なので`new`を迂回"

#. type: comment
#: ../_includes/examples/ext/gmp.c:232
#, no-wrap
msgid "entry point"
msgstr "入口"

#. type: comment
#: ../_includes/examples/ext/gmp.c:237
#, no-wrap
msgid "define GMP::Integer"
msgstr "GMP::Integerを定義"

#. type: comment
#: ../_includes/extend/ext/foobar.c:6
#, no-wrap
msgid "code run by `require`"
msgstr "`require`により走るコード"

#. type: comment
#: ../_includes/c/constant.h:3
#, no-wrap
msgid "shortcut for defining under rb_cObject"
msgstr "rb_cObjectの元に定義される早道"

#. type: comment
#: ../_includes/c/rescue2.h:3 ../_includes/c/eval.h:7
#: ../_includes/c/protect.h:12 ../_includes/c/ensure.h:15
#, no-wrap
msgid "handle exception"
msgstr "例外に対処"

#. type: comment
#: ../_includes/c/rescue2.h:9 ../_includes/c/rescue2.h:16
#: ../_includes/c/mark.h:1 ../_includes/c/mark.h:14 ../_includes/c/mark.h:17
#: ../_includes/c/mark.h:19 ../_includes/c/mark.h:30 ../_includes/c/thread.h:3
#: ../_includes/c/thread.h:8 ../_includes/c/thread.h:14
#: ../_includes/c/wrap.h:46 ../_includes/c/wrap.h:53
#: ../_includes/c/methodex.h:23 ../_includes/c/methodc.h:4
#: ../_includes/c/methodc.h:10 ../_includes/c/methodc.h:16
#: ../_includes/c/global2.h:15 ../_includes/c/global2.h:31
#: ../_includes/c/with_gvl.h:1 ../_includes/c/with_gvl.h:10
#: ../_includes/c/with_gvl.h:14 ../_includes/c/with_gvl.h:17
#: ../_includes/c/protect.h:3 ../_includes/c/protect.h:19
#: ../_includes/c/gvl.h:3 ../_includes/c/gvl.h:12 ../_includes/c/gvl.h:16
#: ../_includes/c/type.h:14 ../_includes/c/ensure.h:21
#: ../_includes/c/ensure.h:25 ../_includes/c/block.h:10
#: ../_includes/c/block.h:17
#, no-wrap
msgid "..."
msgstr "..."

#. type: comment
#: ../_includes/c/rescue2.h:13
#, no-wrap
msgid "rescue TypeError and RangeError"
msgstr "TypeErrorとRangeErrorをレスキューする"

#. type: comment
#: ../_includes/c/checkblock.h:1
#, no-wrap
msgid "raise a LocalJumpError if we don't have a block"
msgstr "ブロックがなければLocalJumpErrorを投げる"

#. type: comment
#: ../_includes/c/checkblock.h:4
#, no-wrap
msgid "or the softer approach"
msgstr "あるいはより柔軟な手法"

#. type: comment
#: ../_includes/c/checkblock.h:7
#, no-wrap
msgid "code to run when we have a block"
msgstr "ブロックがあるときに走るコード"

#. type: comment
#: ../_includes/c/danger.h:3
#, no-wrap
msgid "code that could raise an exception"
msgstr "例外を投げる可能性があるコード"

#. type: comment
#: ../_includes/c/yield.h:3
#, no-wrap
msgid "yield a value. To yield nothing, use Qundef"
msgstr "値をyieldします。何もyieldしないならQundefを使います"

#. type: comment
#: ../_includes/c/yield.h:5
#, no-wrap
msgid "yield several values"
msgstr "複数の値をyield"

#. type: comment
#: ../_includes/c/yield.h:7
#, no-wrap
msgid "splat a Ruby array and yield it"
msgstr "Rubyの配列をスプラットしてyield"

#. type: comment
#: ../_includes/c/mark.h:26 ../_includes/c/wrap.h:29
#, no-wrap
msgid "wrap"
msgstr "梱包"

#. type: comment
#: ../_includes/c/proc.h:3
#, no-wrap
msgid "assuming proc is assigned a Proc from somewhere"
msgstr "procはどこかでProcが代入された前提です"

#. type: comment
#: ../_includes/c/require.h:3
#, no-wrap
msgid "or, using a Ruby String (first argument is ignored)"
msgstr "もしくはRubyの文字列を使用（最初の引数は無視されます）"

#. type: comment
#: ../_includes/c/gvl2.h:5
#, no-wrap
msgid "slow code that DOES NOT USE THE API"
msgstr "APIを全く使わない低速なコード"

#. type: comment
#: ../_includes/c/gvl2.h:10
#, no-wrap
msgid "arg parsing, API stuff, etc."
msgstr "引数の譲渡、API関連など"

#. type: comment
#: ../_includes/c/gvl2.h:14
#, no-wrap
msgid "more API stuff. probably turn the result of slow_func into a VALUE"
msgstr "さらにAPI関連のもの。slow_funcの結果をVALUEに変えることが多い"

#. type: comment
#: ../_includes/c/wrap.h:26
#, no-wrap
msgid "allocate"
msgstr "割り当て"

#. type: comment
#: ../_includes/c/wrap.h:36
#, no-wrap
msgid "unwrap"
msgstr "開封"

#. type: comment
#: ../_includes/c/printf.h:7
#, no-wrap
msgid "pi = 3.141593. Hello, world! inspected: \"Hello, world!\""
msgstr "pi = 3.141593. Hello, world! inspected: \"Hello, world!\""

#. type: comment
#: ../_includes/c/const_get.h:3
#, no-wrap
msgid "if not defined, call const_missing hook"
msgstr "定義されていなければconst_missingフックを呼ぶ"

#. type: comment
#: ../_includes/c/const_get.h:6
#, no-wrap
msgid "if not defined, look for it up the inheritance chain, call const_missing if still not found"
msgstr "定義されていなければ継承の連鎖を遡る。それでも見付からなければconst_missingを呼ぶ"

#. type: comment
#: ../_includes/c/const_get.h:9
#, no-wrap
msgid "same as previous, but print a warning if the constant ends up coming from Object (i.e. toplevel)"
msgstr "前と同じですが、定数がObject由来（トップレベル）に落ち着いたときに警告を印字"

#. type: multiline-comment
#: ../_includes/c/methodex.h:3
#, no-wrap
msgid ""
"\n"
" We want to define a method like\n"
"\n"
"     def my_method man1, opt1 = true, opt2 = false, *splat, man2, **opts, &blk\n"
msgstr ""
"\n"
" 次のようなメソッドを定義したいです。\n"
"\n"
"     def my_method man1, opt1 = true, opt2 = false, *splat, man2, **opts, &blk\n"

#. type: comment
#: ../_includes/c/methodex.h:17
#, no-wrap
msgid "you must manually set the default values for optional arguments"
msgstr "オプション引数に手動で既定値を設定しなければいけません"

#. type: comment
#: ../_includes/c/methodex.h:20
#, no-wrap
msgid "opts will be nil (rather than {}) if no keyword arguments were passed"
msgstr "キーワード引数が全く渡されなければoptsは（{}ではなく）nilになります"

#. type: comment
#: ../_includes/c/methodc.h:1
#, no-wrap
msgid "normal mandatory args (can have up to 16 args not counting self)"
msgstr "通常は必須の引数（selfを除いて16以内）"

#. type: comment
#: ../_includes/c/methodc.h:7
#, no-wrap
msgid "or, slurp all args into a Ruby Array"
msgstr "あるいは全ての引数をRubyのArrayに丸呑みする"

#. type: comment
#: ../_includes/c/methodc.h:13
#, no-wrap
msgid "or, pass all args as a C array"
msgstr "あるいは全ての引数をCの配列として渡す"

#. type: comment
#: ../_includes/c/module.h:4
#, no-wrap
msgid "toplevel module Foo"
msgstr "最上位のモジュールFoo"

#. type: comment
#: ../_includes/c/module.h:6
#, no-wrap
msgid "nested module Foo::Bar"
msgstr "入れ子のモジュールFoo::Bar"

#. type: comment
#: ../_includes/c/load.h:5
#, no-wrap
msgid "or, handle exceptions like rb_eval_string_protect() does"
msgstr "あるいはrb_eval_string_protect()のように例外を制御"

#. type: comment
#: ../_includes/c/load.h:11
#, no-wrap
msgid "got exception"
msgstr "例外があった"

#. type: comment
#: ../_includes/c/global2.h:5
#, no-wrap
msgid "return some VALUE, probably based on global"
msgstr "何らかのVALUEを返す。多くの場合大域変数に基づく"

#. type: comment
#: ../_includes/c/global2.h:10
#, no-wrap
msgid "set global, probably based on val"
msgstr "大域変数を設定する。多くの場合valに基づく"

#. type: comment
#: ../_includes/c/global2.h:17
#, no-wrap
msgid "initialize global first!"
msgstr "まず大域変数を初期化すること"

#. type: comment
#: ../_includes/c/global2.h:19
#, no-wrap
msgid "$w can be changed freely in Ruby"
msgstr "$wはRubyで自由に変えられます"

#. type: comment
#: ../_includes/c/global2.h:22
#, no-wrap
msgid "assigning a new value to $x in Ruby will raise a NameError"
msgstr "Rubyで新しい値を$xに代入するとNameErrorが投げられます"

#. type: comment
#: ../_includes/c/global2.h:25
#, no-wrap
msgid "$y can be changed freely in Ruby, but through the specified functions"
msgstr "特定の関数を通じてですが、$yはRubyで自由に変えられます"

#. type: comment
#: ../_includes/c/global2.h:28
#, no-wrap
msgid "same as previous, but there's no corresponding VALUE!"
msgstr "前と同じですが対応するVALUEがありませんよ"

#. type: comment
#: ../_includes/c/check_p.h:1
#, no-wrap
msgid "like RB_TYPE_P(obj, T_FIXNUM)"
msgstr "RB_TYPE_P(obj, T_FIXNUM)と同様"

#. type: comment
#: ../_includes/c/check_p.h:2
#, no-wrap
msgid "like RB_TYPE_P(obj, T_FLOAT)"
msgstr "RB_TYPE_P(obj, T_FLOAT)と同様"

#. type: comment
#: ../_includes/c/check_p.h:3
#, no-wrap
msgid "like RB_TYPE_P(obj, T_SYMBOL)"
msgstr "RB_TYPE_P(obj, T_SYMBOL)と同様"

#. type: comment
#: ../_includes/c/check_p.h:4
#, no-wrap
msgid "like RB_TYPE_P(obj, T_NIL)"
msgstr "RB_TYPE_P(obj, T_NIL)と同様"

#. type: comment
#: ../_includes/c/check_p.h:5
#, no-wrap
msgid "return true if obj is \"truthy\" i.e. not nil or false"
msgstr "objが「真値」のときtrueを返す。つまりnilでもfalseでもありません"

#. type: comment
#: ../_includes/c/class.h:4
#, no-wrap
msgid "toplevel class Foo < Object"
msgstr "最上位のクラスFoo < Object"

#. type: comment
#: ../_includes/c/class.h:6
#, no-wrap
msgid "nested class Foo::Bar < Array"
msgstr "入れ子のクラスFoo::Bar < Array"

#. type: comment
#: ../_includes/c/with_gvl.h:5
#, no-wrap
msgid "call API functions"
msgstr "API関数を呼び出す"

#. type: comment
#: ../_includes/c/checktype.h:1
#, no-wrap
msgid "return true if obj is a String"
msgstr "objが文字列ならtrueを返す"

#. type: comment
#: ../_includes/c/checktype.h:2
#, no-wrap
msgid "or, raise a TypeError unless obj is a String"
msgstr "あるいはobjが文字列でなければTypeErrorを投げる"

#. type: comment
#: ../_includes/c/protect.h:16
#, no-wrap
msgid "no exception occured"
msgstr "例外の発生無し"

#. type: comment
#: ../_includes/c/etc.h:1
#, no-wrap
msgid "klass.include module"
msgstr "klass.include module"

#. type: comment
#: ../_includes/c/etc.h:4
#, no-wrap
msgid "klass.prepend module"
msgstr "klass.prepend module"

#. type: comment
#: ../_includes/c/etc.h:7
#, no-wrap
msgid "obj.extend module"
msgstr "obj.extend module"

#. type: comment
#: ../_includes/c/etc.h:10
#, no-wrap
msgid "klass.class_eval { undef :method }"
msgstr "klass.class_eval { undef :method }"

#. type: comment
#: ../_includes/c/etc.h:13
#, no-wrap
msgid "klass.class_eval { alias :meth2 :meth1 }"
msgstr "klass.class_eval { alias :meth2 :meth1 }"

#. type: comment
#: ../_includes/c/etc.h:16
#, no-wrap
msgid "klass.attr_reader :x"
msgstr "klass.attr_reader :x"

#. type: comment
#: ../_includes/c/etc.h:18
#, no-wrap
msgid "klass.attr_writer :x"
msgstr "klass.attr_writer :x"

#. type: comment
#: ../_includes/c/etc.h:20
#, no-wrap
msgid "klass.attr_accessor :x"
msgstr "klass.attr_accessor :x"

#. type: comment
#: ../_includes/c/etc.h:23
#, no-wrap
msgid "obj.singleton_class # handy in combination with the other functions"
msgstr "obj.singleton_class # 他の関数と組み合わせると便利"

#. type: comment
#: ../_includes/c/makestruct.h:13
#, no-wrap
msgid "allocate and wrap. note that it needs the type to allocate"
msgstr "割り当てて梱包します。なお型が割り当てられている必要があります"

#. type: comment
#: ../_includes/c/methodr.h:1
#, no-wrap
msgid "the usual"
msgstr "通常"

#. type: comment
#: ../_includes/c/methodr.h:3
#, no-wrap
msgid "or, like a toplevel def (by defining a method in Kernel)"
msgstr "または（Kernelでメソッドを定義することによる）最上位のdefと同様"

#. type: comment
#: ../_includes/c/methodr.h:6
#, no-wrap
msgid "or, with access control"
msgstr "もしくはアクセス制御付き"

#. type: comment
#: ../_includes/c/methodr.h:10
#, no-wrap
msgid "or, in the singleton class"
msgstr "もしくはシングルトンクラス中で"

#. type: comment
#: ../_includes/c/gvl.h:7
#, no-wrap
msgid "somehow tell slow_func to return early"
msgstr "どうにかしてslow_funcに早めに返るよう伝える"

#. type: comment
#: ../_includes/c/type.h:6
#, no-wrap
msgid "handle NilClass"
msgstr "NilClassを扱う"

#. type: comment
#: ../_includes/c/type.h:9
#, no-wrap
msgid "handle Fixnum"
msgstr "Fixnumを扱う"

#. type: comment
#: ../_includes/c/type.h:12
#, no-wrap
msgid "handle String"
msgstr "文字列を扱う"

#. type: comment
#: ../_includes/c/ensure.h:3
#, no-wrap
msgid "stuff to always run after dangerous_func"
msgstr "dangerous_funcの後に常に走るもの"

#. type: comment
#: ../_includes/c/ensure.h:7
#, no-wrap
msgid "wrap rb_ensure so we can rescue an exception"
msgstr "例外をレスキューできるようrb_ensureで梱包"

#. type: comment
#: ../_includes/c/handle.h:1
#, no-wrap
msgid "get last exception"
msgstr "直近の例外を得る"

#. type: comment
#: ../_includes/c/handle.h:2
#, no-wrap
msgid "clear last exception"
msgstr "直近の例外を消去"

#. type: comment
#: ../_includes/c/block.h:3
#, no-wrap
msgid "block_arg will be the first yielded value"
msgstr "block_argは最初のyieldされる値です"

#. type: comment
#: ../_includes/c/block.h:4
#, no-wrap
msgid "data will be the last argument you passed to rb_block_call"
msgstr "dataはrb_block_callに渡される最後の引数です"

#. type: comment
#: ../_includes/c/block.h:5
#, no-wrap
msgid "if multiple values are yielded, use argc/argv to access them"
msgstr "複数の値がyieldされる場合、アクセスするにはargc/argvを使います"

#. type: comment
#: ../_includes/examples/ext/test.rb:27
#, no-wrap
msgid "only accept base with strings"
msgstr "文字列付きの基数のみを受け付けます"

#. type: comment
#: ../_includes/examples/ext/test.rb:29
#, no-wrap
msgid "only accept fixnum bases"
msgstr "fixnumの基数のみ受け付けます"

#. type: comment
#: ../_includes/examples/ext/test.rb:31 ../_includes/examples/ext/test.rb:46
#, no-wrap
msgid "wrong base range"
msgstr "間違った基数の範囲"

#. type: comment
#: ../_includes/examples/ext/test.rb:33
#, no-wrap
msgid "invalid base for string"
msgstr "文字列が不正な基数"

# 「可」ぐらいでいいけれども
#. type: comment
#: ../_includes/examples/ext/test.rb:35 ../_includes/examples/ext/test.rb:48
#, no-wrap
msgid "good"
msgstr "ヨシ"

#. type: comment
#: ../_includes/examples/ext/test.rb:44
#, no-wrap
msgid "base must be Fixnum"
msgstr "基数はFixnumでなければなりません"

#. type: comment
#: ../_includes/examples/ai.rb:2
#, no-wrap
msgid "get my position"
msgstr "位置を得る"

#. type: comment
#: ../_includes/examples/ai.rb:5
#, no-wrap
msgid "get direction that player moved"
msgstr "プレーヤーが動いた方向を得る"

#. type: comment
#: ../_includes/examples/ai.rb:8
#, no-wrap
msgid "... movement logic ..."
msgstr "……動作の仕組み……"

#. type: comment
#: ../_includes/examples/ai.rb:12
#, no-wrap
msgid "move in this direction"
msgstr "この方向に動く"

#. type: comment
#: ../_includes/examples/gmp_ex.rb:4
#, no-wrap
msgid "1283471748369"
msgstr "1283471748369"

#. type: comment
#: ../_includes/extend/ext/extconf.rb:4
#, no-wrap
msgid "preparation for compilation goes here"
msgstr "コンパイルのための準備がここに来ます"

#. type: comment
#: ../_includes/c/new.rb:9
#, no-wrap
msgid "create and return an empty instance"
msgstr "空のインスタンスを作って返します"

#. type: comment
#: ../_includes/examples/Makefile:1
#, no-wrap
msgid "this is just a hack to get the Ruby version in this guide"
msgstr "これは本手引きでのRubyのバージョンを得るための単なるハックです"

#. type: comment
#: ../_includes/examples/Makefile:2
#, no-wrap
msgid "you can just hard-code it e.g. RUBY=2.4"
msgstr "単にハードコードできます 例：RUBY=2.4"

#, no-wrap
#~ msgid "There's also `rb_eval_string_wrap()` which _should_ be useful, but is"
#~ msgstr "[^wrap]: `rb_eval_string_wrap()`もあり、さぞ便利なのだろうと _思いきや_ 、[バグ][bug2]があるため、`rb_eval_string_protect()`と実は同じです。"

# "[control]:"の直後で空白を入れていないのは意図的です。
# これがないとここで改行が入ってしまうので正しいMarkdownの解釈になりません。
# 解消するにはpo4aが正しくリンクの参照を構文解析できるようにする必要があります。
#~ msgid ""
#~ "[control]: https://github.com/ruby/ruby/blob/master/doc/extension."
#~ "rdoc#label-Control+Structure [bug2]: https://bugs.ruby-lang.org/"
#~ "issues/10466"
#~ msgstr ""
#~ "[control]:https://github.com/ruby/ruby/blob/master/doc/extension."
#~ "rdoc#label-Control+Structure\n"
#~ "[bug2]: https://bugs.ruby-lang.org/issues/10466"

# 空白を入れていないのは意図的です。
#~ msgid ""
#~ "[globals]: https://github.com/ruby/ruby/blob/master/doc/extension."
#~ "rdoc#label-Prepare+extconf.rb [makefile]: https://github.com/ruby/ruby/"
#~ "blob/master/doc/extension.rdoc#label-Generate+Makefile"
#~ msgstr ""
#~ "[globals]:https://github.com/ruby/ruby/blob/master/doc/extension."
#~ "rdoc#label-Prepare+extconf.rb\n"
#~ "[makefile]:https://github.com/ruby/ruby/blob/master/doc/extension."
#~ "rdoc#label-Generate+Makefile"

#~ msgid ""
#~ "[a]: http://clalance.blogspot.com/2011/01/writing-ruby-extensions-in-c-"
#~ "part-1.html [b]: https://raw.githubusercontent.com/ruby/ruby/master/doc/"
#~ "extension.rdoc [c]: http://blog.jacius.info/ruby-c-extension-cheat-sheet/ "
#~ "[d]: http://hugopl.github.io/2014/04/09/Embedding-Ruby-2.1-into-a-Cpp-"
#~ "application.html [e]: https://gist.github.com/jefftrull/1305431 [f]: "
#~ "http://metaeditor.sourceforge.net/embed/ [g]: http://ruby-doc.com/docs/"
#~ "ProgrammingRuby/html/ext_ruby.html"
#~ msgstr ""
#~ "[a]:http://clalance.blogspot.com/2011/01/writing-ruby-extensions-in-c-"
#~ "part-1.html\n"
#~ "[b]:https://raw.githubusercontent.com/ruby/ruby/master/doc/extension."
#~ "rdoc\n"
#~ "[c]:http://blog.jacius.info/ruby-c-extension-cheat-sheet/\n"
#~ "[d]:http://hugopl.github.io/2014/04/09/Embedding-Ruby-2.1-into-a-Cpp-"
#~ "application.html\n"
#~ "[e]:https://gist.github.com/jefftrull/1305431\n"
#~ "[f]:http://metaeditor.sourceforge.net/embed/\n"
#~ "[g]:http://ruby-doc.com/docs/ProgrammingRuby/html/ext_ruby.html"

#~ msgid ""
#~ "[start]: c [repo]: https://github.com/silverhammermba/emberb [iss]: "
#~ "https://github.com/silverhammermba/emberb/issues/new [pull]: https://"
#~ "github.com/silverhammermba/emberb/pulls"
#~ msgstr ""
#~ "[start]: c\n"
#~ "[repo]: https://github.com/silverhammermba/emberb\n"
#~ "[iss]: https://github.com/silverhammermba/emberb/issues/new\n"
#~ "[pull]: https://github.com/silverhammermba/emberb/pulls"
