---
layout: chapter
title: 'RubyのC API'
---

## 始める前に ##

この手引きを完全に理解するためには、C言語はそこそこ、Rubyは _かなり_ 慣れ親しんでいるとよいでしょう。

RubyのC
APIを使うのに発展的なC言語の概念は要りませんが、APIは**膨大**で大半が**文書化されていません**。APIを使い始めだすと、いつの日にか、はっきりしない関数やマクロの挙動を調べるためにRubyのソースコードを探ることになるでしょう。Rubyのソースはそこそこ洗練されたC言語で書かれているので、すいすい読めはするでしょうけれども。

C
APIは、普通のRubyのコードよりもデカくてゴチャっとした書き方だと見なせます。とはいえ、簡素で明快なRubyの様式は、ひとたびAPIの言葉に翻訳されるとかなり非直感的になることがあります。Rubyの内部的な仕組みと設計の背景にある思想に裏打ちされたしっかりとした直感があれば、長い旅路のさなかでも正しいAPI関数へと進み続けられるでしょう。

## 分岐点 ##

公式のRubyインタプリタはC言語で書かれています。
Rubyでできるあらゆることは、RubyのC APIを呼び出す関数を使ってもできます。
いったいなぜそんなことをするのでしょうか？
もっともな理由が2つあります。

1. 意匠を凝らしたC言語ないしC++のアプリケーションを書いている最中で、
   Rubyの動的な柔軟性をコードのいくつかの箇所に使って、
   効果を引き出そうとするとき。
   アプリケーションの内部でRubyインタプリタを実行でき、
   Rubyのコードの結果をAPIで受け取ることができます。
2. 意匠を凝らしたRubyのアプリケーションを書いている最中で、
   C言語（もしくは既にあるC言語のライブラリ）の速度と能力を
   コードのいくつかの箇所に使って、
   効果を引き出そうとするとき。
   APIを使えば、RubyにC言語のコードをさらけ出すことができます。
   そうしてできた特別なライブラリをコンパイルするとRubyから `require` できます。

目標によってC言語のコードの組み立てかたは変わってきます。
C言語にRubyインタプリタを組込みたければ、[C言語でRubyを実行する](../embed)をお読みください。
コンパイルされたC言語のライブラリを `require` したければ、[RubyでC言語を実行する](../extend)をお読みください。
どちらかを読み終えたら、ここに戻ってきてAPIについて学びましょう。

## Eval ##

ちゃちゃっと雑にCでRubyを動かすには、 `eval` します。

{% highlight c %}
{% include c/eval.h %}
{% endhighlight %}

これはやりたいことをするためのAPI関数が見つからないときは選択肢に入ります[^wrap]。`rb_eval_string_protect()`
はRubyのコードの結果を返し、何か例外が発生したときはゼロではない値を `state` に設定します。`VALUE`
はあらゆるRubyのオブジェクトのためのCのデータ型です。次の節で後述します。

`state` がゼロではないとき、`result` は `nil` を表す `VALUE`
になっているでしょうから、そのときは例外に対処しなければいけません。代わりに `rb_eval_string()` を使うこともできます。この関数は引数
`state`
を取らず、通常の方法で例外を発生させます。これら2つの場合での制御方法については[例外](#exceptions)の節を参照してください。

Rubyでの`eval`とは異なり、これらの関数は何かしらを`require`したときに、独立したbindingのようなものの中で文字列を評価します。
そのため文字列中の局所変数は他所から参照できませんし、逆もまた然りです。

しかし、Rubyで `eval` するときのように、
これらの関数を使うことはあまりよくありません。
パーサが起動されなければいけないのが非効率ですし、
Cで書くことの利点が失われています。
Rubyのメソッドを呼びたいだけであれば、
もっといい方法を[後述](#send)します。

## VALUE ##

先に進む前に、
`VALUE` について理解しなければいけません。
VMの内部をめちゃくちゃにしてしまう危険があるので、
APIからは直接Rubyのオブジェクトを扱えません[^intern]。
その代わり、CのコードはRubyのオブジェクトへの _ポインタ_
を保持したり受け渡したりします（Rubyの変数がオブジェクトへのポインタを持つのと同じです）。
ポインタはさまざまなAPIの関数やマクロに渡すことができ、
そのためRubyのオブジェクトに安全にアクセスしたり操作したりできます。
`VALUE` はAPIで定義されたCの型で、このポインタを扱います。

おそらく最も頻繁に湧いてくる疑問は次のようなものでしょう。
「この `VALUE` は正しい型なのだろうか？」
この疑問に答えるマクロは2つあり、
そのどちらも[`T_` 定数](datatypes)を引数に取ります。
この定数は比較したい型に対応するRubyのクラスです。
例えば `T_STRING` や `T_ARRAY` などです。

[datatypes]:https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-Data+Types

{% highlight c %}
{% include c/checktype.h %}
{% endhighlight %}

この検査はサブクラスでも同様にはたらきます。
`Array` のサブクラスであることを確認したいときは `T_ARRAY` を使いますし、
`Object` のサブクラスであることを確認したいときには `T_OBJECT` を使います[^tdata]。
つまり、この検査は _`is_a?` と同じではない_ ということでもあります。
Rubyのありとあらゆるものについて `is_a? Object` であるにせよ、
`T_OBJECT` に対する検査は、
他にもっと適した定数がないときにのみ真となります。

特定のクラスについては、前述したものより少し便利なマクロが使えます。

{% highlight c %}
{% include c/check_p.h %}
{% endhighlight %}

いくつかの型を取りうる `VALUE` を扱いたいときは、前述のマクロはちょっと不恰好です。そんな場合は `TYPE()` マクロを使って `T_`
定数を取得し、`switch` 文で制御できます。

{% highlight c %}
{% include c/type.h %}
{% endhighlight %}

### 定数 ###

ほとんどの標準的なRubyの定数はAPIで大域的な `VALUE`
が定義されています。したがってそうした定数を使うのにAPIの呼び出しは要りません。モジュールは `rb_m`
で前置されます。例えば`rb_mKernel` です。クラスは `rb_c` で前置されます。例えば`rb_cObject`
です。`Exception` のサブクラスは `rb_e` で前置されます。例えば`rb_eRubtimeError` です。標準的なIOストリームは
`rb_` で前置されます。例えば`rb_stderr` です。`nil`, `false`, `true` は `Q` で前置されます。例えば
`Qnil` です[^undef]。便宜上、 `Qfalse` はCの偽値 (`0`) でもあります。

### 変換 ###

いくつかのRubyのクラスはCの型に対応します。
この対応する組み合わせは、CとRubyの間のデータのやりとりにうってつけです。

#### Fixnum ####

Rubyの `Fixnum` はCの `long` に対応します。
`FIX2LONG()` マクロにより、 `long` を `Fixnum` に変換できます。
より小さいCの型については、
`FIX2UINT()`, `FIX2INT()`, `FIX2SHORT()` があります。
しかし、これらのマクロは変換時に数値が大きすぎて収まらない場合は `RangeError` を生じます。

逆向きの変換もできて、
`LONG2FIX()` は `long` *に加えて* `long` より小さい全てのCの整数型からの変換に使えます。

#### Bignum ####

Rubyの `Bignum` は `Fixnum` より大きいあらゆる整数に使えます。例えば `long long`
が必要なときとかです。`rb_big2()` と `rb_big2u()` を使えば、 `Bignum` からそれぞれ `long long` や
`unsigned long long` に直せます（直せなければ`RangeError` が発生します）。

逆向きの変換については [Numeric](#numeric) を参照してください。

#### Float ####

Rubyの `Float` はCの `double` に対応します。
`RFLOAT_VALUE()` マクロを使えば、 `Float` から `double` が得られます。

逆向きの変換については [Numeric](#numeric) を参照してください。

#### Numeric ####

たくさんの "NUM" マクロがあり、
ダックタイピングっぽい使いかたをしています。
これらのマクロはCの型を適切と思われるRubyの `Numeric` のサブクラス（のインスタンス）に変換します。

* `INT2NUM()` は `int` からの変換用
* `UINT2NUM()` は `unsigned int` からの変換用
* `LONG2NUM()` は `long` からの変換用
* `ULONG2NUM()` は `unsigned long` からの変換用
* `LL2NUM()` は `long long` からの変換用
* `ULL2NUM()` は `unsigned long long` からの変換用
* `DBL2NUM()` は `double` からの変換用

そして、逆方向のマクロもあります。
これらのマクロは、あらゆる `Numeric` な数値から欲しいCの型の値への変換を試みるものです。
値が範囲に収まらなかったときは `RangeError` を発生させますし、
暗黙の数値の変換ができなかったときは `TypeError` が発生します（なので `Numeric` ではないオブジェクトを渡しても大丈夫です）。

* `NUM2CHR()` は `char` からの変換用（`unsigned char` からでも変換できます）
* `NUM2SHORT()` は `short` からの変換用
* `NUM2USHORT()` は `unsigned short` からの変換用
* `NUM2INT()` は `int` からの変換用
* `NUM2UINT()` は `unsigned int` からの変換用
* `NUM2LONG()` は `long` からの変換用
* `NUM2ULONG()` は `unsigned long` からの変換用
* `NUM2LL()` は `long long` からの変換用
* `NUM2ULL()` は `unsigned long long` からの変換用
* `NUM2DBL()` は `double` からの変換用

これらのマクロについて **特に** 注意すべき点は、符号なしの型に変換に変換する *どの*
マクロも、負値を渡したときに例外が発生しないということです（驚くべきことに[バグではありません][bug]）。`NUM2CHR()`
にはもう2つ妙なところがあります。変換前の値が _int_ には大きすぎるときに `RangeError` のみ生じることと、文字列を渡したときに
`TypeError` を発生させず最初の文字の数値を返すということです。

変換が安全だとわかっていれば、
前の節のマクロのほうを使うべきです。
なぜなら範囲の確認を省けるためです。

[bug]: https://bugs.ruby-lang.org/issues/9089

#### String ####

Rubyの `String` はだいたいCの `char*` に対応します。もっとも簡素なマクロは `StringValueCStr()`
です。このマクロは `String` からnull終端付きの `char*` を返します。ただしこれには問題があって、Rubyの `String` が
*nullを含むかもしれません*。そのような場合には `StringValueCStr()` は `ArgumentError`
を発生させます！その代わりに `StringValuePtr()` マクロと `RSTRING_LEN()`
マクロを使えば、それぞれ（終端が付いていない可能性がある）`char*` とその長さの `long` 値を取得できます。

逆に、null終端付きの `char*` からRubyの `String` への変換には、`rb_str_new_cstr()` が使えます。
そして、もし `String` にnullを含めたいときは、`rb_str_new()` を使います。
`rb_str_new()` は `char*` と文字列の長さ（型は `long`）を引数に取ります。
これらの文字列のエンコーディングは `ASCII-8BIT` なのですが、Ruby側のコードで望んだものではないこともあります。
そんなときは文字列の `VALUE` を `rb_str_export_locale()` に渡して、自分のロケールのエンコーディングでの
`VALUE` を取得できます。

もっと複雑な文字列を構築したければ、`printf` のような関数
`rb_sprintf()`があります。この関数では通常の変換での全ての指定子だけではなく、APIで定義された指定子 `PRIsVALUE`
も使えます。`PRIsVALUE` は対応する `VALUE` を引数に取ります。この変換指定子はオブジェクトに `to_s`
メッセージを送って文字列に置き換えます。`+` フラグを加えることで `inspect` を使った結果の文字列に置き換えることもできます。

{% highlight c %}
{% include c/printf.h %}
{% endhighlight %}

この独自の指定子はAPIにあるあらゆる `printf` っぽい関数で使えるでしょう。`PRIsVALUE` は `i`
変換指定子を間借りすることで実現されているので、Rubyに「それって実は `VALUE` なんじゃないか」と勘違いさせないように、`int`
を文字列にするときは `d` を使うべきです。

#### Symbol ####

APIではRubyの `Symbol` に対応するCの型 `ID` が定義されています。Rubyが `Symbol`
をメソッドや変数名として受け渡しするように、多くのAPI呼び出しでメソッドや変数の名前として`ID` を使うようにしています。`Symbol` と
`ID` を変換するには、 `SYM2ID()` と `ID2SYM()` マクロを使います。`Symbol` ではなくCの文字列 `char*`
と相互に変換したいときもあるでしょう。`char*` から `ID` を取得するためには `rb_intern()` を、その逆向きでは
`rb_id2name()` を使います。

多くのAPI関数が `ID` を必要としていますが、適切な `ID` が手元にないことも沢山あるでしょう。
そのため、代わりに `char*` を引数に取って自動で `rb_intern()` してくれる関数も沢山あります。
これらの関数はより読みやすく、 `rb_intern()` の呼び出しでのオーバーヘッドは無視できる程度なので、本手引きでは可能な限り `char*`
バージョンのAPI関数が使われる傾向にあります。
特定のCの文字列をAPIの呼出しで頻繁に使う場合は、`ID` に変換して保管しておき、`ID`
バージョンの関数を使うことでいくらかの効率性の向上を確かめられるかもしれません（Rubyのヘッダから自分で見つける必要がありますが）。

## send ##

この節には直接Rubyのメソッドを呼び出すAPI関数が含まれます。`rb_eval_string()`などより、できるだけ常にこれらの関数を贔屓すべきです。これらの関数では構文解析の過程が飛ばされますし、いくつかのコンパイル時検査が免除されるのでより速いのです。

一番簡単な方法はオブジェクトにメソッドをこのように送ることです。

{% highlight c %}
{% include c/funcall.h %}
{% endhighlight %}

これは大雑把には次のRubyコードと同じです。

{% highlight ruby %}
{% include c/funcall.rb %}
{% endhighlight %}

最初の引数はレシーバです。その次はメソッド名用の[`ID`](#symbol)です。3つ目の引数はメソッド引数の数です。この引数が必要なのは`rb_funcall()`がvarargs関数だからです。それから実際メソッド引数に行き着きます。

これに代えて4つ目の引数が引数のCの配列を指す`VALUE*`になっている`rb_funcallv()`を使うことができます。これにもRubyでの`public_send`のような派生、`rb_funcallv_public()`があります。

### ブロックを渡す ###

`Proc`をブロックとしてメソッドに渡したければ話は早いです。
関数はほぼ`rb_funcallv()`と同じですが後ろにprocが付きます。

{% highlight c %}
{% include c/proc.h %}
{% endhighlight %}

ブロック用のprocがなければ、ブロックを表現する何らかの類のC関数を定義する必要があります。それから`rb_funcallv()`の異なる派生形で、ブロック用に2つ引数が追加されたものがあります。

{% highlight c %}
{% include c/block.h %}
{% endhighlight %}

`rb_block_call()`への最後の引数はブロック関数のスコープの外側にある値を渡すのに便利ですが、この例ではその必要はありません（なので`nil`にしています）。
また、1つの値だけがyieldされることを**確信**していない限り、最初の引数を使うことはお勧めしません。
いつでも全ての引数を`argv`から手に入れられるので、危うきに近寄らずともいいじゃないですか[^break]。

## 組み込みの機能 ##

多くのRubyの組み込みクラスには、その中でも飛びっきり便利なメソッド用に定義されたAPI関数があります。
それらを使えば、`rb_funcall()`を使ってばかりで冗長になるのを避けられたり、より良いコンパイル時の検証がもたらされるかもしれません。
関数があまりにも多すぎて一覧にするにはここは狭すぎるので、ヘッダファイル`ruby/intern.h`を眺めることを推奨します。

関数はおおよそ`rb_（クラス）_（メソッド）`のように命名されていて少なくとも1つの`VALUE`引数（レシーバ）を取ります。
例えば`rb_ary_pop()`は`Array#pop`用ですし、`rb_obj_dup()`は`Object#dup`用、といった具合です。

## require ##

APIには何らかのRubyコードをスクリプトから読み込むための、`require`と等価なものがあります。

{% highlight c %}
{% include c/require.h %}
{% endhighlight %}

`require`するときは例外が発生し得ます。
対処方法については[次節](#exceptions)を読んでください。

スクリプトを複数回読み込みたければ、`load`用の関数もあります。

{% highlight c %}
{% include c/load.h %}
{% endhighlight %}

ちょうど[Rubyの`load`][rbload]と同じように、こうした関数は読み込まれたコードを匿名のモジュールに包んで大域名前空間を保護するのに使えます。単に非ゼロの値を2つ目の引数に渡せばよいのです。

[rbload]: http://www.ruby-doc.org/core/Kernel.html#method-i-load

## 例外 ##

### raise ###

例外を投げるには以下を使ってください。

{% highlight c %}
{% include c/raise.h %}
{% endhighlight %}

1つ目と2つ目の引数は例外クラスと文言で、Rubyの`raise`のような感じです。
大きな違いは、文言が（[ちょうど`rb_sprintf()`のような](#string)）書式文字列である点で、有用な文言をより簡単に構築できます。

また`rb_exc_new_cstr`、`rb_exc_new`、`rb_exc_new_str`を直接使って例外オブジェクトを構築することもできます。これら全ては例外クラスを1つ目の引数に受け取り、そうしてそれぞれの関数に対応する[文字列](#string)に対してはたらきます。すなわち例外はそれぞれnull終端文字列、非null終端文字列、`String`オブジェクトを使って構築されます。それから`rb_exc_raise`で例外オブジェクトを投げられます。

### rescue ###

APIを使って例外を捕捉するにはいくつか方法があります。
全ての方法で保護対象のコードは単一の`VALUE`を取って返す関数の中にある必要があります。

{% highlight c %}
{% include c/danger.h %}
{% endhighlight %}

厳密にこの型の関数を救出したいのでない限り、恐らくこの形式で所望のコードを走らせる梱包関数を作る必要があるでしょう。救出された例外にアクセスする方法もまた、救出される方法とは独立です。

{% highlight c %}
{% include c/handle.h %}
{% endhighlight %}

`rb_errinfo()`により、欠かせないRubyの`$!`（1つも例外が起こらなければ`Qnil`になります）の`VALUE`が与えられます。Rubyとは異なり読んだ後で例外を手動で消し去らなければなりません[^clear]。さもなくばその後のAPI呼び出しが古い値を読んで別の例外が起こったと考えるかもしれません。

次に救出するための方法をいくつか眺めていきます。どれでも好きなものを使ってよいですが、一般に正しい選択はAPIの[用途](#the-two-paths)により決まると考えています。

#### rb_rescue2 ####

Rubyによって読み込まれるライブラリをコンパイルしている場合、話は簡単です。
APIで投げられるいかなる例外もいつも通りRubyのコードで救出できます。
APIで例外を救出したければRubyの`rescue`と似ている`rb_rescue2()`を使うことができます。

{% highlight c %}
{% include c/rescue2.h %}
{% endhighlight %}

始めから2つの引数は保護する関数とその引数です。その次の2つは例外が投げられた場合に呼ばれる関数とその引数です。`rb_rescue2()`はvarargs関数なのでその後には救出したい例外クラスのリストが来ます。最後の引数は常に`0`で、クラスのリストの末尾を示します。Rubyの`rescue`のように、このリストにない例外は何も救出されません。もし（Rubyでの空の`rescue`のように）`StandardError`を救出したいだけなら、`rb_rescue2()`の最初の4つの引数だけを取る`rb_rescue()`を使うことができます。

Rubyとは違い、APIではそれぞれの例外クラス用に救出コードを走らせる簡単な方法を提供していません。一旦欲しい全てのクラスを救出して、switchの類を使って個別に取り扱う必要があります。

またAPIはRubyの`else`と等価なもの、つまり _何ら_
例外が投げられなかったときに走るコード、を直接は提供していません。このための1つの方法は`rb_rescue2()`の返り値を使うことです。もし1つも例外が投げられなければ最初の（危険な）関数の返り値を、さもなくば2つ目の（救出）関数の返り値を返します。これらが返すもの、ここでは`Qtrue`と`Qfalse`としましょう、を受け取ることによって、どちらの場合になっているのかを検出できます。

#### rb_protect ####

RubyインタプリタをCに埋め込みたい場合、例外を投げ得るAPI関数を呼ぶときは _極めて慎重_ にならねばなりません。
**捕捉されない例外はVMをセグフォルトさせてプログラムをキルする**のです。
`rb_eException`と共に`rb_rescue2()`を呼ぶようにできますが、全ての例外を救出する別の手法があります。

{% highlight c %}
{% include c/protect.h %}
{% endhighlight %}

`rb_rescue2()`と同様、最初2つの引数は保護する関数を呼び出すためのものです。しかし、`rb_eval_string_protect()`のように、例外が投げられれば`Qnil`を返し`state`を非ゼロの値に設定します。例外を再度投げたければ`state`を`rb_jump_tag()`に渡してください（これは他の`*_protect()`関数からの状態についても同じことが言えます）。

### ensure ###

`rb_ensure()`は`rb_rescue()`に似ていますが、例外を関知しないことと2つ目の関数が _常に_
1つ目のものの後に呼ばれる点で異なります。充分に単純に思われるかもしれませんが、これが意味しているのは、もしRubyでするような通常の`begin;
rescue; end`の構造が欲しければ、梱包に別の層が必要になってくるということです。

{% highlight c %}
{% include c/ensure.h %}
{% endhighlight %}

Rubyでの`ensure`のように、`ensure_func()`の返り値は決して使われません。何も例外が起きなければ`rb_rescue()`は`begin_func()`の値を返します。ここで、`begin_func()`は`dangerous_func()`の値を返します。もし例外が発生したら`rb_rescue()`は`rescue_func()`の値を返します。

## 定義、宣言 ##

ここまでVMのメモリ内で直接オブジェクトを作ったり変更したりしてきましたが、どのAPI呼び出しも _Rubyのコードの内部_
での目に見える効果はありませんでした。
`rb_str_new_cstr()`で作られた`String`は、既定ではCからのみアクセスできます。

Rubyから見えるようにするにはいくつかの方法がありますが、全て同じ汎用的な仕組みではたらきます。その共通するところはRubyがアクセスできる何らかの名前を定義するという点です。例えば変数名やメソッド名などです。しかし注意を呼び掛けておきましょう。Rubyとは違い、**APIでは不正な名前を与えることができます**。クラスに`foo`（定数でない）やインスタンス変数に`bar`（`@`がない）を名付けようとするとRubyは`SyntaxError`や`NameError`を投げるでしょうが、APIは嬉々としてそうした名前で作り、**不正な名前をRubyにさらけ出さない**
ようにして対処します。そうしたいわけではないでしょうから、選ぶ名前はダブルチェックしてくださいね。

この節のほとんどのAPI関数はRubyのメタプログラミングに近いです。APIを使って何かしようとするときは、Rubyでメタプログラミングのメソッド呼び出しだけを使ってするとしたらどうするだろうと考えると役立つことがあります。例えば`class
Foo; def bar; end`とするのではなく、`Foo = Class.new; Foo.define_method(:bar)
{}`と考えるのです。

### 大域変数 ###

大域変数を扱う一番簡単な方法は以下です。

{% highlight c %}
{% include c/global.h %}
{% endhighlight %}

Rubyの大域変数に頻繁にアクセスするときは`VALUE`を準備しておけば自動的に同期が取られます。

{% highlight c %}
{% include c/global2.h %}
{% endhighlight %}

`VALUE`はRubyで大域変数を作る前に初期化するべきで、そうしておけばCでも大域変数になります。
Rubyが使っている間はスコープを外れてほしくはないですからね。
`rb_define_hooked_variable()`にすると、そうした操作で通常の同期をしたい場合にゲッターやセッターに`NULL`を渡すことができます。
もしくは`rb_define_virtual_variable()`で完全に`global`を投げ出すこともできますが、もちろんゲッターとセッターはそうした場合で定義されている*必要*があります。

Rubyに露出 _しない_
大域変数`VALUE`をCで作った場合、中途半端に掃除されてしまうのを防ぐためにガベージコレクタにそのことを伝えなければなりません。

{% highlight c %}
{% include c/gc.h %}
{% endhighlight %}

### クラスとインスタンス変数 ###

インスタンス変数の取得と設定は大域変数にアクセスする単純な方法と似ていますが、もちろん変数を取得してくるオブジェクトが必要です。

{% highlight c %}
{% include c/ivar.h %}
{% endhighlight %}

大域変数もそうでしたがインスタンス変数を同期する自動化された方法はありません。

全てのインスタンス変数を巡回するには`rb_ivar_foreach`を使ってください。

クラス変数については、メソッドは`rb_cv_get()`と`rb_cv_set()`があり、もちろん最初の引数はクラスオブジェクトです。

### 定数

定数は似たように定義されていますが、それらを配下に置くためのモジュールを伴います。

{% highlight c %}
{% include c/constant.h %}
{% endhighlight %}

`Qundef`を設定すると定数は未定義にされます。定数の`VALUE`の取得に関しては少しずつ違います。定数が指定されたモジュールで定義されて
_いない_ ときに何が起こってほしいのかに依って呼び出すべきAPI関数が決まります。

{% highlight c %}
{% include c/const_get.h %}
{% endhighlight %}

これら全てのAPIはプライベート定数も取得します。

### モジュールとクラス ###

モジュールの定義は超簡単です。

{% highlight c %}
{% include c/module.h %}
{% endhighlight %}

クラスも同じやり方ですが、こちらはスーパークラスも必要になります。

{% highlight c %}
{% include c/class.h %}
{% endhighlight %}

### メソッド ###

ここから面白くなってきます。メソッド定義のためのAPI呼び出しには多くの種類がありますが、どれかを使う前にそのメソッドを呼び出すC関数が必要です。その関数は`VALUE`を返しメソッドのレシーバ用の`VALUE`引数を1つ持たねばなりません。他の引数を定義するのには3つの方法があります。

{% highlight c %}
{% include c/methodc.h %}
{% endhighlight %}

なので本当のところAPIでは2つの種類のメソッドのみが定義できるのです。且つは固定数の引数を取り、且つは全ての引数を一飲みします。Rubyの素敵な引数の機能はどうなったのでしょうか。オプション引数、オプションハッシュ、ブロック、これらの混在はどこにあるのでしょうか。

#### 引数を解析する ####

さて、様々な個数の引数を受け付けられたら、メソッド内で自力で全ての仕組みをコードに書くことができ、あたかもRubyで凝ったメソッドを定義したように
_振る舞わ_
せられます。ありがたいことにAPIにはちょうどそういうことをするための早道があります。それにはC配列関数の定義を使うとよく、それから`argc`と`argv`を以下の流れに沿って渡すことができます。

{% highlight c %}
{% include c/scan.h %}
{% endhighlight %}

ここで`fmt`はメソッド引数がRubyでどのような見た目をしているのかを記述する書式文字列です。文字列は最大6個の文字を持つことができ、そこではそれぞれの文字はそれぞれ異なる節の引数を記述するのです。6つの節と（順番通りに）対応する文字は以下の通りです。

1. 先頭にある必須引数の数：数字
2. オプション引数の数：数字
3. 展開される引数：`*`
4. 後ろに続く必須引数の数：数字
5. キーワード引数：`:`
6. ブロック引数：`&`

それぞれの節は省略できるので、必要ではないものについてはそのための文字を空けたままにできます。書式文字列の解析は貪欲に行われる点に注意してください。`1*`は必須引数と展開を持つメソッドを示しています。1つの
_オプション_ 引数と展開であってほしければ`01*`と指定せねばなりません。書式文字列にしたがってそれぞれの _Ruby_
の引数用に`VALUE*`を渡さなければなりません。渡されるポインタの数は6つの節の「合計」に等しいのですが、関心のない引数については`NULL`を渡すことができます。例えば書式文字列`21*&`には5つの`VALUE*`が渡されなければなりません（2つの必須引数、1つのオプション引数、1つの展開、1つのブロックです）。

`rb_scan_args()`は渡した`VALUE*`を使って`argv`を開封し、もし誤った数の引数が渡されたときは符牒が合わない旨の例外を投げます。

{% highlight c %}
{% include c/methodex.h %}
{% endhighlight %}

`rb_scan_args()`の返り値を使って、関数がどう呼ばれたのかを確定することもできます。そうすることでRubyで渡された引数の数が返ります。

#### ブロックの扱い ####

Cのメソッドがブロック付きで呼ばれたかどうかを確認する方法は2つあります。

{% highlight c %}
{% include c/checkblock.h %}
{% endhighlight %}

Procとしてブロックを捕捉する方法は2つあります。メソッド引数に`rb_scan_args()`を使っている場合、書式文字列に`&`を含めるだけで取得できます。`rb_scan_args()`を使っていなければメソッドのブロックをProcに変換する`Proc.new`と等価なAPI呼び出しがあります。

    VALUE block;
    block = rb_block_proc();

ブロックを捉えたくなければ、yieldする方法が2つあります。

{% highlight c %}
{% include c/yield.h %}
{% endhighlight %}

`rb_yield_values()`に似た`rb_yield_values2()`もあり、`varargs`の代わりに2つ目の引数が`VALUE*`になっています[^yield]。

#### super ####

メソッドで`super`を呼びたいことがあるかもしれません。

{% highlight c %}
{% include c/super.h %}
{% endhighlight %}

Rubyとは異なり、引数を1つも与えなければ`rb_call_super()`はメソッドの引数をsuperに暗黙に渡すことは**ありません**。明示的に正しい`argc`及び`argv`を渡さなければならないのです（`self`を自動的に渡し*ます*）。そういった理由から`rb_call_super()`を使いたければCの配列スタイルのメソッド定義を使うことをお勧めします。

#### 定義 ####

Cの関数を用意するのは大変ですが、Ruby用にメソッドを定義するのは簡単です。メソッドをつくるAPI呼び出しは全て最低でもメソッド名
(`char*`)、Cの関数へのポインタ、引数を表す`argc`を取ります。`argc`は以下のようなものです。

1. 引数が一定数のときは、その引数の数（レシーバは数えません）
2. Cの配列中の引数の数が可変なときは、`-1`
3. Rubyの配列中の引数の数が可変なときは、`-2`

これ以降の全てはかなりそれ自体が分かりやすいものです。

{% highlight c %}
{% include c/methodr.h %}
{% endhighlight %}

モジュール _と_ そのシングルトンクラス中でメソッドを定義する早道もあります。例えば`Math`で多用されており、例として`include
Math`とすることで一々メソッド呼び出しで`Math.`と打つのを避けられます。

{% highlight c %}
{% include c/modulefunc.h %}
{% endhighlight %}

### その他のもの ###

クラスやメソッドの定義のための単純なAPI関数があります。

{% highlight c %}
{% include c/etc.h %}
{% endhighlight %}

## データ ##

今となってはAPIを使ってRubyのクラスを作ったり操作したりできるでしょう。しかしCの世界でデータをカプセル化するRubyのクラスを作るにはどうすればよいのでしょうか。データが自然に`VALUE`に翻訳できるのであれば簡単です。いつも通り変換してインスタンス変数に代入すればよいです。でもデータに、Rubyでいうところのこれ、といったものがないとしたらどうでしょうか（例：何らかのCのライブラリで定義されたデータ構造）。

APIを使うと、所望の`VALUE`を作り、Rubyのオブジェクトの中にCのデータを指す`void*`を格納することで、Cのデータをカプセル化できます。そうしてCのデータにアクセスする必要が生じたら、ポインタを開封して正しい型に変換し戻せばよいのです。しかしどの時点でこのカプセル化は起こるのでしょうか。その質問へは次の質問でもって答えましょう。`new`を使ってオブジェクトを作るようRubyに伝えたとき何が起こるでしょうか。基本的にはこうです。

{% highlight ruby %}
{% include c/new.rb %}
{% endhighlight %}

私達がよく知っている _インスタンスメソッド_ `initialize`を呼ぶ前に、`new`は最初に _クラスメソッド_
`allocate`を呼んで実際にオブジェクトを作るのです。これこそが、Cのデータを包み込むオブジェクトが欲しい場合に定義する必要のあるメソッドです。以下の例は`initialize`によって設定できる`int`を包むクラス`Foo`を作っています。

{% highlight c %}
{% include c/wrap.h %}
{% endhighlight %}

ほとんどの場合（`struct`のような）もっと複雑なものを包むことになりそうですが、基本は変わりません。Cのデータをアロケートした後は、`TypedData_Wrap_Struct()`[^oldwrap]マクロを使って`VALUE`中のポインタを包みます。この梱包には3引数要ります。オブジェクトのクラス（クラスメソッドにいるので`self`です）、構造体へのポインタ、そして梱包されるデータのポインタです。引っ掛かりやすいところは構造体ポインタにあります。このポインタはRubyが内部的に使う追加情報を提供するものです。

* `wrap_struct_name`はRubyによって使われる文字列で、型を識別するために使われます。意味が通っていて一意である限り本当に何でも構いません
* `function`はガベージコレクタによって使われるいくつかの関数ポインタを含む構造体です
* `dmark`については後述しますが、CのデータがRubyのオブジェクトを指さない限り不要です
* `dfree`が呼ばれるのは、オブジェクトが破棄されオブジェクトによってアロケートされた全てのメモリが解放されるときです
* `dsize`はがRubyから呼ばれるのはオブジェクトがどの位メモリを取っているのか確認するときです。省略も _可能_
  ですが、含めておくのが誠実というものです
* `data`は任意のデータを指すことができます。Cのデータをクラス水準で包んだものと考えてください。こちらも必須ではありません
* `flags`を使うとオブジェクトがガベージコレクトされたときの追加の最適化を有効にします。`dfree`関数が[GVL](#c-in-ruby-threads)を解放しない限り（そうしたいことなんてあるのでしょうか）、`RUBY_TYPED_FREE_IMMEDIATELY`を安全に設定することで僅かに効率性の向上が得られます

これらの要素を設定しない場合はRubyがうっかりゴミデータを読まないようにゼロにしてしまうべきです。上の例でC99の[明示初期化子][desinit]構文を使っているのはそのためです。どの要素を省いてもコンパイラによって安全に掃除された状態になっています

[desinit]: https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html

Cのデータを包む`VALUE`は、[`TYPE()`マクロ](#value)に関しては型`T_DATA`を持ちます。これはRuby固有のオブジェクトとCのデータを包んでいるオブジェクトとの間の区別を明確にする補助になります。

一旦Cのデータを包み込む作業が全部終わったら、元に戻すのは簡単です。`TypedData_Get_Struct()`は開封するオブジェクト、通底するデータのCの型、前と同じ構造体ポインタ、そしてデータを代入するポインタを取ります。

このアロケーションと初期化は[RAII](raii)を誤魔化すことはないので、C++を使っているなら恐らくデータを開封するときに[配置new][place]を使うことになるでしょう。
アロケーションと初期化を分離するのが難しければデータを`struct`に包み*実際の*アロケーションを`initialize`ですることもできます。

[raii]: http://wikipedia.org/wiki/Resource_Acquisition_Is_Initialization
[place]: http://en.cppreference.com/w/cpp/language/new#Allocation

（前の例のような）単純な場合ではコードをもっと冗長にならないようにできます。
例にあるようにデータを解放するのに`free()`を呼ぶだけなら、`dfree`に`RUBY_DEFAULT_FREE`を渡すことでRubyが代わりに解放してくれます（メモリリークがお好みでなければ`NULL`を使わ*ない*でください）。
同様にアロケーションで上の例のように単に`malloc()`だけでいいなら、`TypedData_Make_Struct()`がアロケーションをやってくれて、*且つ*梱包もしてくれます。
以前の例を以下のように短くできます。

{% highlight c %}
{% include c/makestruct.h %}
{% endhighlight %}

### マークする ###

上の型構造体中の`dmark`ポインタはオブジェクトの「マーク関数」へのポインタです。これはガベージコレクタの「マーク・アンド・スイープ」アルゴリズムに因んでいます。マーク・アンド・スイープの背景にある基本的な考え方において、ガベージコレクタがメモリを解放する必要があるときに2つの工程を実施します。最初の工程（マーク）では全ての
_参照されている_ Rubyのオブジェクトを巡回し活性と印を付けます。それから2つ目の工程（スイープ）では全ての _アロケートされた_
Rubyのオブジェクトを巡回し、活性と印が付けられていないものを解放します。

このことはCのデータを包むことに関係してきます。
なぜかというとRubyの`VALUE`を含むCの`struct`を包む可能性があるからです。
ガベージコレクタはこの`VALUE`を消し去る使命があります。
ガベージコレクタは（Cのポインタではなく）*Rubyで*参照された`VALUE`だけはそれと気付きますが、この場合は`VALUE`を活性だと印を付けられません。
結果として、ガベージコレクタがメモリを解放する必要が生じるやいなや、Cのデータは不在のRubyのオブジェクトを参照することになってしまうでしょう。
なおこういった類の、Cのデータの中にRubyのデータを包むことは本当に悪い考え方で、正にこれに類する問題が理由です。
でももし本当にそうしなければならないとすれば……。

以下の例では`VALUE`を含むCの`struct`を包みます。マーク関数は解放関数と同じシグネチャを持っており、`struct`中の`VALUE`に印を付けて回ることだけに関するものです。

{% highlight c %}
{% include c/mark.h %}
{% endhighlight %}

`struct`が`VALUE`のCの配列へのポインタを含む場合は、代わりに2つの引数を取る`rb_gc_mark_locations()`を使うことができます。この2引数は配列の先頭と末尾へのポインタです（末尾は先頭のポインタに配列の長さを足したものと等しいです）[^maybe]。

## スレッド ##

### Cのスレッドの中のRuby ###

沢山のAPI呼び出しをしたり沢山のRubyのコードをCから走らせたりする場合、ある時点でふと我に返って、「APIを使ってこの遅いRubyのコードを全部走らせているな。スレッドっぽいものでコードを速く保てるかもしれないぞ」と思うかもしれません。なるほど理に適った考えですが、**Ruby
VMは全くもってスレッド安全ではない**と気に留めておくことに目をつぶればの話です。理想的にはAPIのコード全部は単一スレッドで走らせるべきです。そうでなければ恐らく全てのAPI呼び出しをロックされたミューテックスに包む必要があるでしょう。同時に複数のスレッドがAPIとやり取りすることがないようにするためです。

単にAPIを使う普通のRubyの`Thread`を作りたいだけなら（そして次節で述べるGVLが気にならなければ）、簡単な方法があります。

{% highlight c %}
{% include c/thread.h %}
{% endhighlight %}

他の`Thread`の関数は`ruby/intern.h`にあります（しかしどんなものであれいつでも`rb_funcall()`があります）。

### Rubyのスレッドの中のC ###

他方で、重いCのコードをAPIでRubyにさらけ出す場合（例えばCのライブラリを包む拡張を書いている場合など）、大域的VMロック (GVL)
と呼ばれる頭痛の種には時間を取って考えてみることです。ほとんどのAPIは`Thread`安全ではないですから、一度に単一の`Thread`だけが走るように、GVLはほぼ全てのRubyのコードをロックしてしまいます。これが俗に`Thread`では真の並列性がないと言われる所以です。

またVMはRubyにさらけ出すCのコードには漏れなくGVLを適用します。
Cのコードを`Thread`の中から呼ぶときに暴発を心配せずAPIを使えるのはそのためです。
このことの欠点はCのコードを走らせるのに時間が掛かることで、`Thread`で呼ぶことによる効率性の利点が見られないということです。
なぜならそのスレッドが走っているときは**他の全てのスレッドをブロックしている**からです。
しかしGVLはAPI呼び出しを保護するためだけに必要なものです。
APIを使わないCのコードがあるとき、スレッド中でコードを走らせる前にGVLを免除してほしいとVMに伝え、処理が完了したあとにGVLを再装填できます。
こうすれば真の並列性が得られます。
GVLを封鎖したり解除したりすると効率性への影響はあるので、ブロックされたスレッドによる顕著な問題を抱えていると気付いたときだけこの方法に頼るようにしてください。

こういったことをするコードはRubyで開発している人にとっては酷だと思われるので、実際には使用する別のヘッダを含める必要があるでしょう。まずGVLを解除する少しだけ単純なやり方を見ていきます。

{% highlight c %}
{% include c/gvl2.h %}
{% endhighlight %}

GVLなしに走る関数が`void*`を使うデータを取得したり返したりしているので、ポインタを介してデータを渡すために`struct`を定義したいところでしょう。

上のようにGVLを解除するとコードは確かに並列で走るものの、（シグナルや`Thread.kill`などによって）中断できないことに気付かれるでしょう。中断できるようにするには末尾の2引数を使ってブロック解除関数を渡さなければいけません。

{% highlight c %}
{% include c/gvl.h %}
{% endhighlight %}

ブロック解除関数は中断のイベント中に呼ばれます。動作させるためには恐らくポインタを両方の関数に渡して、中断が一方から他方へと伝わるようにするために使う必要があるでしょう。中断された関数は早期に返る前に必要な片付けを実施します。

代えて中断された関数が特別な片付けをする _必要_
がないならば、（ブロック解除引数を無視する）組み込みのブロック解除関数`RUBY_UBF_IO`[^ubf]が使えます。これは単純に中断を走っているスレッドに転送します[^int]。

GVLを解除するためにこうした一通りの骨折りをした後で、ブロックが解除されたスレッドでAPI呼び出しをする必要があるとわかった場合のみ、一時的にGVLを再装填する関数があります。

{% highlight c %}
{% include c/with_gvl.h %}
{% endhighlight %}

## 参考文献 ##

### extension.rdoc ###

Rubyには確かに[公式のAPIドキュメント][readme]があります。（私の感想としては）少々むらがあってお勧めしにくいのですが、特定の話題についてはもう少しつまびらかにされていたりもします。筆者が意図的に書かずにおいたところは沢山ありますが、それは有益と思われなかったりもっと良いドキュメントがどこかにあったりするからなのです。

[readme]: https://github.com/ruby/ruby/blob/master/doc/extension.rdoc

### ヘッダ ###

最も敷居の高い資料はRubyのヘッダ自体だと思っています。
完全なAPI（すなわち`ruby.h`を含めることで手に入る全てのもの）はゆうに千を越える関数、マクロ、定数、大域変数からなります。
そのほとんどは全くドキュメントがありません。
しかし*ほとんど*のものは理に適った命名でヘッダから何をするものなのかを調べることができるでしょう。
必要になるもののほとんどは`ruby/ruby.h`と`ruby/intern.h`のヘッダにあります。
前者はVMとメタプログラミング関数についての全てがあり、後者にはRubyに組み込みクラスとやり取りする関数の全てがあります。

`ruby.h`では取り込まれ _ない_ ヘッダもあり、含めることで追加のAPI機能が得られるものがあります。
いつの日か本手引きで節を改めることがあるかもしれません。

* `ruby/debug.h`（実験的）プロファイリングとコードの追跡用の関数
* `ruby/encoding.h` 文字列エンコーディングを扱う関数
* `ruby/io.h` RubyのIOクラス用の追加の関数
* `ruby/re.h` RubyのRegexpクラス用の追加の関数
* `ruby/thread.h` [GVL](#c-in-ruby-threads)を扱うための関数
* `ruby/version.h` バージョンを調べる関数。これを機能を検出するコードに使わないように
* `ruby/vm.h`（実験的）VM制御用の関数

### ソース ###

どこにもドキュメント化されていないヘッダ中の関数を見付けたら、次なる一手はRubyのソースコードです。

{% highlight shell_session %}
$ git clone https://github.com/ruby/ruby.git
{% endhighlight %}

ソースコードを一読する際は常にヘッダを控えておきましょう。ソースコードには本当に役立ちそうでいてAPIにありそうに _見える_
関数が沢山あります。ほとんどの場合その役に立つ関数を呼び出すために梱包するAPI関数があることでしょう。

### 例 ###

[例](../examples)のページには短くてコンパイルできる、実際のAPIの例があるので読んでみてください。

### 貢献する ###

これで本手引きを読み終わりましたが、何か著しく書き漏らしたものがあるでしょうか。
粗忽な誤りがなかったでしょうか。このサイトの[ソース][gh]をGithubで確認してイシューを報告したりプルリクエストを送ってください。
またGithubから全てのコード例をダウンロードできます。

[gh]: https://github.com/silverhammermba/emberb

## 脚註 ##

[^intern]: That's a blatant lie. The API _definitely_ lets you mess around with the
internal data structures of objects (look for things with names starting
with capital R). But it's generally not a good idea and not necessary.

[^undef]: There's also `Qundef` representing an undefined value, but this has no Ruby
equivalent and is [rarely](#handling-blocks)  [used](#constants-1). In fact,
outside of those rare occasions, `Qundef` can segfault the VM if Ruby was
expecting a normal `VALUE`.

[^wrap]: There's also `rb_eval_string_wrap()` which _should_ be useful, but is
actually the same as `rb_eval_string_protect()` due to a [bug][bug2].

[^chr]: There is a `CHR2FIX()` macro, but in my tests this sometimes gave unexpected
results. `LONG2FIX()` should work.

[^wchar]: I don't know what the best way is to handle `wchar_t`. In my tests I had
some success just treating them as `char`s, but I think that may have been a
happy accident, and could certainly fail on different platforms.

[^clear]: The documentation [states][control] that "You have to clear the error
info... when ignoring the caught exception" during `rb_protect`. But I can't
find any documentation of when it would be cleared for you—it seems like you
_always_ have to clear it.

[^yield]: And there's `rb_yield_block()` which takes two unused arguments and is never
called by anything in Ruby. Odd.

[^break]: The documentation [mentions][control] `rb_iter_break()` and
`rb_iter_break_value()` for breaking out of a block, but can't you just
return early? I can't think of a use-case for these.

[^int]: There is also the function `rb_thread_call_without_gvl2()`. The
documentation in `thread.c` says that if it "detects interrupt, it returns
immediately," but I'm not sure what this means. If the unblocking function
doesn't kill the thread, it still waits for the thread to finish on its own
before returning.

[^ubf]: You can also use `RUBY_UBF_PROCESS`, but this seems to be a leftover from
deprecated code and has the exact same effect.

[^oldwrap]: The `TypedData*` macros are the preferred way to wrap data since Ruby
1.9.2. If you're using an older version of Ruby you can check out an older
version of this guide on Github to see how it used to be done.

[^maybe]: There's also the enigmatically named `rb_gc_mark_maybe()`, but I'm not sure
when it is needed.

[^tdata]: Or use `T_DATA` if the object [wraps a C pointer](#data).

[control]: https://github.com/ruby/ruby/blob/master/doc/extension.rdoc#label-Control+Structure
[bug2]: https://bugs.ruby-lang.org/issues/10466
